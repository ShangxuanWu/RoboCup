###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     06/Jul/2014  14:13:54 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\robot _init\robot\lib\LPLD\HAL_CAN.c                  #
#    Command line =  "F:\robot _init\robot\lib\LPLD\HAL_CAN.c" -D IAR -D      #
#                    LPLD_K60 -lCN "F:\robot _init\robot\project\robot_car_co #
#                    m\iar\FLASH\List\" -lB "F:\robot                         #
#                    _init\robot\project\robot_car_com\iar\FLASH\List\" -o    #
#                    "F:\robot _init\robot\project\robot_car_com\iar\FLASH\Ob #
#                    j\" --no_cse --no_unroll --no_inline --no_code_motion    #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M4 -e --fpu=None            #
#                    --dlib_config "D:\IAR Systems\Embedded Workbench         #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I "F:\robot         #
#                    _init\robot\project\robot_car_com\iar\..\app\" -I        #
#                    "F:\robot _init\robot\project\robot_car_com\iar\..\..\.. #
#                    \lib\common\" -I "F:\robot _init\robot\project\robot_car #
#                    _com\iar\..\..\..\lib\cpu\" -I "F:\robot                 #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\cpu\h #
#                    eaders\" -I "F:\robot _init\robot\project\robot_car_com\ #
#                    iar\..\..\..\lib\drivers\adc16\" -I "F:\robot            #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\enet\" -I "F:\robot _init\robot\project\robot_car_com #
#                    \iar\..\..\..\lib\drivers\lptmr\" -I "F:\robot           #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\mcg\" -I "F:\robot _init\robot\project\robot_car_com\ #
#                    iar\..\..\..\lib\drivers\pmc\" -I "F:\robot              #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\rtc\" -I "F:\robot _init\robot\project\robot_car_com\ #
#                    iar\..\..\..\lib\drivers\uart\" -I "F:\robot             #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\wdog\" -I "F:\robot _init\robot\project\robot_car_com #
#                    \iar\..\..\..\lib\platforms\" -I "F:\robot               #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\LPLD\ #
#                    " -I "F:\robot _init\robot\project\robot_car_com\iar\..\ #
#                    ..\..\lib\LPLD\FatFs\" -I "F:\robot                      #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\LPLD\ #
#                    USB\" -I "F:\robot _init\robot\project\robot_car_com\iar #
#                    \..\..\..\lib\iar_config_files\" -Ol                     #
#    List file    =  F:\robot _init\robot\project\robot_car_com\iar\FLASH\Lis #
#                    t\HAL_CAN.lst                                            #
#    Object file  =  F:\robot _init\robot\project\robot_car_com\iar\FLASH\Obj #
#                    \HAL_CAN.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\robot _init\robot\lib\LPLD\HAL_CAN.c
      1          /*
      2           * --------------"拉普兰德K60底层库"-----------------
      3           *
      4           * 测试硬件平台:LPLD_K60 Card
      5           * 版权所有:北京拉普兰德电子技术有限公司
      6           * 该函数代码部分参考苏大程序
      7           * 网络销售:http://laplenden.taobao.com
      8           * 公司门户:http://www.lpld.cn
      9           *
     10           * 文件名: HAL_CAN.h
     11           * 用途: CAN底层模块相关函数
     12           * 最后修改日期: 20120711
     13           *
     14           * 开发者使用协议:
     15           *  本代码面向所有使用者开放源代码，开发者可以随意修改源代码。但本段及以上注释应
     16           *  予以保留，不得更改或删除原版权所有者姓名。二次开发者可以加注二次版权所有者，
     17           *  但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           */
     19          
     20          /*
     21           *******需用到FTM中断，请在isr.h中粘贴一下代码:*********
     22          
     23          //FTM模块中断服务定义
     24          
     25          #undef  VECTOR_045
     26          #define VECTOR_045 LPLD_CAN_Isr
     27          #undef  VECTOR_046
     28          #define VECTOR_046 LPLD_CAN_Isr
     29          #undef  VECTOR_047
     30          #define VECTOR_047 LPLD_CAN_Isr
     31          #undef  VECTOR_048
     32          #define VECTOR_048 LPLD_CAN_Isr
     33          #undef  VECTOR_049
     34          #define VECTOR_049 LPLD_CAN_Isr
     35          #undef  VECTOR_050
     36          #define VECTOR_050 LPLD_CAN_Isr
     37          #undef  VECTOR_051
     38          #define VECTOR_051 LPLD_CAN_Isr
     39          #undef  VECTOR_052
     40          #define VECTOR_052 LPLD_CAN_Isr
     41          #undef  VECTOR_053
     42          #define VECTOR_053 LPLD_CAN_Isr
     43          
     44          //以下函数在LPLD_Kinetis底层包，不必修改
     45          extern void LPLD_CAN_Isr(void);
     46          
     47           ***********************代码结束*************************
     48          */
     49          
     50          #include "HAL_CAN.h"
     51          //#include "common.h"
     52          //#include "arm_cm4.h"
     53          
     54          
     55          //用户自定义中断服务函数数组

   \                                 In section .bss, align 4
     56          CAN_ISR_CALLBACK CAN_ISR[16];
   \                     CAN_ISR:
   \   00000000                      DS8 64
     57          
     58          //GPIO映射地址数组

   \                                 In section .data, align 4
     59          volatile CAN_MemMapPtr CANx_Ptr[5] = {CAN0_BASE_PTR, 
   \                     CANx_Ptr:
   \   00000000   0x40024000         DC32 40024000H, 400A4000H
   \              0x400A4000   
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     60                                                CAN1_BASE_PTR};
     61          
     62          //定义内部函数
     63          static uint8 LPLD_CAN_SetBaud(CANx, uint32);
     64          
     65          
     66          
     67          /*
     68           * LPLD_CAN_Init
     69           * 该函数用于Flex_CAN模块初始化
     70           * 参数:
     71           *    canx--设置CAN模块号
     72           *      |__CAN0             --CAN0号模块
     73           *      |__CAN1             --CAN1号模块
     74           *    baud_khz--设置CAN总线波特率
     75           *      |__0
     76           *      |__....
     77           *    selfloop--设置CAN总线自循环模式
     78           *      |__CAN_NOSELFLOOP   --不循环
     79           *      |__CAN_SELFLOOP     --循环 
     80           * 输出:
     81           *    0:配置出现错误
     82           *    1:配置成功
     83           */

   \                                 In section .text, align 2, keep-with-next
     84          uint8 LPLD_CAN_Init(CANx canx, uint32 baud_khz, uint8 selfloop)
     85          {
   \                     LPLD_CAN_Init:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     86              int8 i;
     87              CAN_MemMapPtr canptr = CANx_Ptr[canx];
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000000A   0xF850 0x5024      LDR      R5,[R0, R4, LSL #+2]
     88            
     89              //使能FlexCAN外部时钟
     90              OSC_CR |= OSC_CR_ERCLKEN_MASK | OSC_CR_EREFSTEN_MASK;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40065000
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0xF050 0x00A0      ORRS     R0,R0,#0xA0
   \   00000018   0x.... 0x....      LDR.W    R3,??DataTable12_1  ;; 0x40065000
   \   0000001C   0x7018             STRB     R0,[R3, #+0]
     91              
     92              //使能CAN模块时钟
     93              if(canx == CAN0)
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD108             BNE.N    ??LPLD_CAN_Init_0
     94                  SIM_SCGC6 |= SIM_SCGC6_FLEXCAN0_MASK;//使能CAN0的时钟模块 
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x4004803c
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000002E   0x.... 0x....      LDR.W    R3,??DataTable12_2  ;; 0x4004803c
   \   00000032   0x6018             STR      R0,[R3, #+0]
   \   00000034   0xE007             B.N      ??LPLD_CAN_Init_1
     95              else
     96                  SIM_SCGC3 |= SIM_SCGC3_FLEXCAN1_MASK;//使能CAN1的时钟模块
   \                     ??LPLD_CAN_Init_0:
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40048030
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000040   0x.... 0x....      LDR.W    R3,??DataTable12_3  ;; 0x40048030
   \   00000044   0x6018             STR      R0,[R3, #+0]
     97              
     98              //配置CAN_RX/TX复用引脚功能
     99              if(canx == CAN0)
   \                     ??LPLD_CAN_Init_1:
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD10A             BNE.N    ??LPLD_CAN_Init_2
    100              {
    101          	//CAN0_TX
    102                  PORTA_PCR12 = PORT_PCR_MUX(2) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; //Tx上拉
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40049030
   \   00000050   0xF240 0x2303      MOVW     R3,#+515
   \   00000054   0x6003             STR      R3,[R0, #+0]
    103                  //CAN0_RX
    104          	PORTA_PCR13 = PORT_PCR_MUX(2) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; //RX上拉
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40049034
   \   0000005A   0xF240 0x2303      MOVW     R3,#+515
   \   0000005E   0x6003             STR      R3,[R0, #+0]
   \   00000060   0xE009             B.N      ??LPLD_CAN_Init_3
    105              }
    106              else
    107              {
    108              	PORTE_PCR24 = PORT_PCR_MUX(2) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; //Tx上拉
   \                     ??LPLD_CAN_Init_2:
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x4004d060
   \   00000066   0xF240 0x2303      MOVW     R3,#+515
   \   0000006A   0x6003             STR      R3,[R0, #+0]
    109              	PORTE_PCR25 = PORT_PCR_MUX(2) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; //Rx上拉
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x4004d064
   \   00000070   0xF240 0x2303      MOVW     R3,#+515
   \   00000074   0x6003             STR      R3,[R0, #+0]
    110              } 
    111              //注：CTRL1不能在FRZ（冻结）模式下设置
    112              //选择时钟源，外设时钟48MHz，内部时钟：12MHz
    113              //选择内部时钟
    114              CAN_CTRL1_REG(canptr)|= CAN_CTRL1_CLKSRC_MASK;    
   \                     ??LPLD_CAN_Init_3:
   \   00000076   0x6868             LDR      R0,[R5, #+4]
   \   00000078   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000007C   0x6068             STR      R0,[R5, #+4]
    115               
    116              //使能CAN模块
    117              CAN_MCR_REG(canptr) &= ~CAN_MCR_MDIS_MASK;
   \   0000007E   0x6828             LDR      R0,[R5, #+0]
   \   00000080   0x0040             LSLS     R0,R0,#+1        ;; ZeroExtS R0,R0,#+1,#+1
   \   00000082   0x0840             LSRS     R0,R0,#+1
   \   00000084   0x6028             STR      R0,[R5, #+0]
    118              
    119              //在时钟初始化完毕和CAN总线使能完毕后，
    120              //单片机自动进入冻结模式
    121              //只有在冻结模式下才能配置大多数CAN总线寄存器
    122              //使能冻结模式
    123              CAN_MCR_REG(canptr) |= CAN_MCR_FRZ_MASK; 
   \   00000086   0x6828             LDR      R0,[R5, #+0]
   \   00000088   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   0000008C   0x6028             STR      R0,[R5, #+0]
    124              //确认不在低功耗模式，如果在低功耗模式下软件复位无法完成
    125              while((CAN_MCR_REG(canptr) & CAN_MCR_LPMACK_MASK ));
   \                     ??LPLD_CAN_Init_4:
   \   0000008E   0x6828             LDR      R0,[R5, #+0]
   \   00000090   0x02C0             LSLS     R0,R0,#+11
   \   00000092   0xD4FC             BMI.N    ??LPLD_CAN_Init_4
    126              
    127              //软件复位
    128              //受影响的registers： MCR (except the MDIS bit), TIMER, ECR, ESR1, ESR2,
    129              //                    IMASK1, IMASK2, IFLAG1, IFLAG2 and CRCR.
    130              //不受影响的registers：CTRL1, CTRL2, RXIMR0CRXIMR63, RXMGMASK, RX14MASK,
    131              //                     RX15MASK, RXFGMASK, RXFIR, all Message Buffers
    132              //复位后MCR中RFEN=0，因而Rx FIFO并没有使能  --------重要
    133              //因而“使能冻结模式位”被复位
    134              
    135              //CAN 总线软件复位，复位后该自动清零
    136              CAN_MCR_REG(canptr) |= CAN_MCR_SOFTRST_MASK; 
   \   00000094   0x6828             LDR      R0,[R5, #+0]
   \   00000096   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \   0000009A   0x6028             STR      R0,[R5, #+0]
    137              //等待复位完成
    138              while(CAN_MCR_SOFTRST_MASK & CAN_MCR_REG(canptr)); 
   \                     ??LPLD_CAN_Init_5:
   \   0000009C   0x6828             LDR      R0,[R5, #+0]
   \   0000009E   0x0180             LSLS     R0,R0,#+6
   \   000000A0   0xD4FC             BMI.N    ??LPLD_CAN_Init_5
    139              
    140              //退出正常模式，再次使能冻结模式 ,因为软件复位使冻结模式退出 
    141              CAN_MCR_REG(canptr) |= CAN_MCR_FRZ_MASK;  
   \   000000A2   0x6828             LDR      R0,[R5, #+0]
   \   000000A4   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   000000A8   0x6028             STR      R0,[R5, #+0]
    142              //等待进入冻结模式 
    143              while(!(CAN_MCR_REG(canptr) & CAN_MCR_FRZACK_MASK));
   \                     ??LPLD_CAN_Init_6:
   \   000000AA   0x6828             LDR      R0,[R5, #+0]
   \   000000AC   0x01C0             LSLS     R0,R0,#+7
   \   000000AE   0xD5FC             BPL.N    ??LPLD_CAN_Init_6
    144              
    145              //=================Initialize the Module Configuration Register=============
    146              //1 Enable the individual filtering per MB and reception queue features by setting the IRMQ bit
    147              //1设置全匹配蔽位，并配置与之相关的寄存器
    148              CAN_CTRL2_REG(canptr) &= ~CAN_CTRL2_EACEN_MASK;//接收邮箱过滤IDE匹配，RTR不匹配
   \   000000B0   0x6B68             LDR      R0,[R5, #+52]
   \   000000B2   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   000000B6   0x6368             STR      R0,[R5, #+52]
    149              CAN_CTRL2_REG(canptr) &= ~CAN_CTRL2_RRS_MASK;  //不自动产生远程请求帧产生
   \   000000B8   0x6B68             LDR      R0,[R5, #+52]
   \   000000BA   0xF430 0x3000      BICS     R0,R0,#0x20000
   \   000000BE   0x6368             STR      R0,[R5, #+52]
    150              CAN_MCR_REG(canptr)   &= ~CAN_MCR_IRMQ_MASK;   //使能全局匹配寄存器      
   \   000000C0   0x6828             LDR      R0,[R5, #+0]
   \   000000C2   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   000000C6   0x6028             STR      R0,[R5, #+0]
    151              CAN_CTRL2_REG(canptr) |= CAN_CTRL2_MRP_MASK;   //ID首先从邮箱中匹配
   \   000000C8   0x6B68             LDR      R0,[R5, #+52]
   \   000000CA   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   000000CE   0x6368             STR      R0,[R5, #+52]
    152              CAN_CTRL1_REG(canptr) |= CAN_CTRL1_LBUF_MASK;  //发送的时候从低优先级发送
   \   000000D0   0x6868             LDR      R0,[R5, #+4]
   \   000000D2   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000000D6   0x6068             STR      R0,[R5, #+4]
    153              CAN_RXMGMASK_REG(canptr) = 0x1FFFFFFF;         //28位ID全部匹配
   \   000000D8   0xF07F 0x4060      MVNS     R0,#-536870912
   \   000000DC   0x6128             STR      R0,[R5, #+16]
    154              CAN_RX14MASK_REG(canptr) = 0x00000000;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x6168             STR      R0,[R5, #+20]
    155              CAN_RX15MASK_REG(canptr) = 0x00000000;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x61A8             STR      R0,[R5, #+24]
    156              //2 WRN_EN bit
    157              //2设置是否产生警告中断
    158              CAN_MCR_REG(canptr)  &= ~CAN_MCR_WRNEN_MASK;    //不产生警告中断
   \   000000E6   0x6828             LDR      R0,[R5, #+0]
   \   000000E8   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   000000EC   0x6028             STR      R0,[R5, #+0]
    159              //3 SRX_DIS bit
    160              //3设置是否自我接受
    161              //CAN_MCR_REG(canptr)  |= CAN_MCR_SRXDIS_MASK;  //禁止CAN自我接收
    162              //4 Enable the Rx FIFO by setting the RFEN bit
    163              //4 设置是否使能RX FIFO
    164              CAN_MCR_REG(canptr)  &= ~CAN_MCR_RFEN_MASK ;    //禁止接收FIFO
   \   000000EE   0x6828             LDR      R0,[R5, #+0]
   \   000000F0   0xF030 0x5000      BICS     R0,R0,#0x20000000
   \   000000F4   0x6028             STR      R0,[R5, #+0]
    165              //5 Enable the abort mechanism by setting the AEN bit
    166              CAN_MCR_REG(canptr)  &= ~CAN_MCR_AEN_MASK;   
   \   000000F6   0x6828             LDR      R0,[R5, #+0]
   \   000000F8   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   000000FC   0x6028             STR      R0,[R5, #+0]
    167              //6 Enable the local priority feature by setting the LPRIO_EN bit
    168              CAN_MCR_REG(canptr)  &= ~CAN_MCR_LPRIOEN_MASK;
   \   000000FE   0x6828             LDR      R0,[R5, #+0]
   \   00000100   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000104   0x6028             STR      R0,[R5, #+0]
    169              
    170          
    171              //模式选择：回环模式或正常模式
    172              if(selfloop)
   \   00000106   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000108   0x2A00             CMP      R2,#+0
   \   0000010A   0xD004             BEQ.N    ??LPLD_CAN_Init_7
    173                CAN_CTRL1_REG(canptr) |= CAN_CTRL1_LPB_MASK;   //使用回环模式
   \   0000010C   0x6868             LDR      R0,[R5, #+4]
   \   0000010E   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000112   0x6068             STR      R0,[R5, #+4]
   \   00000114   0xE003             B.N      ??LPLD_CAN_Init_8
    174              else
    175                CAN_CTRL1_REG(canptr) &= ~CAN_CTRL1_LPB_MASK;  //使用正常模式
   \                     ??LPLD_CAN_Init_7:
   \   00000116   0x6868             LDR      R0,[R5, #+4]
   \   00000118   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   0000011C   0x6068             STR      R0,[R5, #+4]
    176              //->Initialize the Control Register
    177              //Determine the bit timing parameters: PROPSEG, PSEG1, PSEG2, RJW
    178              //Determine the bit rate by programming the PRESDIV field
    179              //Determine the internal arbitration mode (LBUF bit)
    180              //设置波特率
    181              if(LPLD_CAN_SetBaud(canx,baud_khz))//若设置错误
   \                     ??LPLD_CAN_Init_8:
   \   0000011E   0x0020             MOVS     R0,R4
   \   00000120   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000122   0x.... 0x....      BL       LPLD_CAN_SetBaud
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD001             BEQ.N    ??LPLD_CAN_Init_9
    182              {
    183                  return 0;
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0xE104             B.N      ??LPLD_CAN_Init_10
    184              }
    185              //“SYNC” message 使能同步功能
    186              CAN_MCR_REG(canptr)  |= CAN_CTRL1_TSYN_MASK;
   \                     ??LPLD_CAN_Init_9:
   \   0000012E   0x6828             LDR      R0,[R5, #+0]
   \   00000130   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000134   0x6028             STR      R0,[R5, #+0]
    187              CAN_TIMER_REG(canptr) = 0x0000;
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0x60A8             STR      R0,[R5, #+8]
    188              //->Initialize the Message Buffers
    189              //The Control and Status word of all Message Buffers must be initialized
    190              //If Rx FIFO was enabled, the ID filter table must be initialized
    191              //Other entries in each Message Buffer should be initialized as required
    192              //将16个邮箱缓冲区内容清0
    193              for(i=0;i<16;i++)
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0xE018             B.N      ??LPLD_CAN_Init_11
    194              {
    195                canptr->MB[i].CS    = 0x00000000;
   \                     ??LPLD_CAN_Init_12:
   \   0000013E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000140   0xEB15 0x1100      ADDS     R1,R5,R0, LSL #+4
   \   00000144   0x2200             MOVS     R2,#+0
   \   00000146   0xF8C1 0x2080      STR      R2,[R1, #+128]
    196                canptr->MB[i].ID    = 0x00000000;
   \   0000014A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014C   0xEB15 0x1100      ADDS     R1,R5,R0, LSL #+4
   \   00000150   0x2200             MOVS     R2,#+0
   \   00000152   0xF8C1 0x2084      STR      R2,[R1, #+132]
    197                canptr->MB[i].WORD0 = 0x00000000;
   \   00000156   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000158   0xEB15 0x1100      ADDS     R1,R5,R0, LSL #+4
   \   0000015C   0x2200             MOVS     R2,#+0
   \   0000015E   0xF8C1 0x2088      STR      R2,[R1, #+136]
    198                canptr->MB[i].WORD1 = 0x00000000;
   \   00000162   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000164   0xEB15 0x1100      ADDS     R1,R5,R0, LSL #+4
   \   00000168   0x2200             MOVS     R2,#+0
   \   0000016A   0xF8C1 0x208C      STR      R2,[R1, #+140]
    199              }
   \   0000016E   0x1C40             ADDS     R0,R0,#+1
   \                     ??LPLD_CAN_Init_11:
   \   00000170   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000172   0x2810             CMP      R0,#+16
   \   00000174   0xD3E3             BCC.N    ??LPLD_CAN_Init_12
    200              //初始化所需要的接受邮箱，设置邮箱的ID，即filter的ID值
    201              LPLD_CAN_Enable_RX_Buf(canx,MB_NUM_1,FILTER_SLAVEA_ID);//1
   \   00000176   0x2201             MOVS     R2,#+1
   \   00000178   0x2101             MOVS     R1,#+1
   \   0000017A   0x0020             MOVS     R0,R4
   \   0000017C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000017E   0x.... 0x....      BL       LPLD_CAN_Enable_RX_Buf
    202              LPLD_CAN_Enable_RX_Buf(canx,MB_NUM_2,FILTER_SLAVEB_ID);//2
   \   00000182   0x2202             MOVS     R2,#+2
   \   00000184   0x2102             MOVS     R1,#+2
   \   00000186   0x0020             MOVS     R0,R4
   \   00000188   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000018A   0x.... 0x....      BL       LPLD_CAN_Enable_RX_Buf
    203              LPLD_CAN_Enable_RX_Buf(canx,MB_NUM_3,FILTER_SLAVEC_ID);//3
   \   0000018E   0x2203             MOVS     R2,#+3
   \   00000190   0x2103             MOVS     R1,#+3
   \   00000192   0x0020             MOVS     R0,R4
   \   00000194   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000196   0x.... 0x....      BL       LPLD_CAN_Enable_RX_Buf
    204              LPLD_CAN_Enable_RX_Buf(canx,MB_NUM_4,FILTER_SLAVED_ID);//4
   \   0000019A   0x2204             MOVS     R2,#+4
   \   0000019C   0x2104             MOVS     R1,#+4
   \   0000019E   0x0020             MOVS     R0,R4
   \   000001A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A2   0x.... 0x....      BL       LPLD_CAN_Enable_RX_Buf
    205              LPLD_CAN_Enable_RX_Buf(canx,MB_NUM_5,FILTER_SLAVEE_ID);//5
   \   000001A6   0x2205             MOVS     R2,#+5
   \   000001A8   0x2105             MOVS     R1,#+5
   \   000001AA   0x0020             MOVS     R0,R4
   \   000001AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001AE   0x.... 0x....      BL       LPLD_CAN_Enable_RX_Buf
    206              LPLD_CAN_Enable_RX_Buf(canx,MB_NUM_6,FILTER_SLAVEF_ID);//6
   \   000001B2   0x2206             MOVS     R2,#+6
   \   000001B4   0x2106             MOVS     R1,#+6
   \   000001B6   0x0020             MOVS     R0,R4
   \   000001B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001BA   0x.... 0x....      BL       LPLD_CAN_Enable_RX_Buf
    207              LPLD_CAN_Enable_RX_Buf(canx,MB_NUM_7,FILTER_SLAVEG_ID);//7
   \   000001BE   0x2207             MOVS     R2,#+7
   \   000001C0   0x2107             MOVS     R1,#+7
   \   000001C2   0x0020             MOVS     R0,R4
   \   000001C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001C6   0x.... 0x....      BL       LPLD_CAN_Enable_RX_Buf
    208              LPLD_CAN_Enable_RX_Buf(canx,MB_NUM_8,FILTER_SLAVEH_ID);//8
   \   000001CA   0x2208             MOVS     R2,#+8
   \   000001CC   0x2108             MOVS     R1,#+8
   \   000001CE   0x0020             MOVS     R0,R4
   \   000001D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001D2   0x.... 0x....      BL       LPLD_CAN_Enable_RX_Buf
    209              LPLD_CAN_Enable_RX_Buf(canx,MB_NUM_9,FILTER_SLAVEI_ID);//9
   \   000001D6   0x2209             MOVS     R2,#+9
   \   000001D8   0x2109             MOVS     R1,#+9
   \   000001DA   0x0020             MOVS     R0,R4
   \   000001DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001DE   0x.... 0x....      BL       LPLD_CAN_Enable_RX_Buf
    210              LPLD_CAN_Enable_RX_Buf(canx,MB_NUM_10,FILTER_SLAVEJ_ID);//10
   \   000001E2   0x220A             MOVS     R2,#+10
   \   000001E4   0x210A             MOVS     R1,#+10
   \   000001E6   0x0020             MOVS     R0,R4
   \   000001E8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001EA   0x.... 0x....      BL       LPLD_CAN_Enable_RX_Buf
    211              LPLD_CAN_Enable_RX_Buf(canx,MB_NUM_11,FILTER_SLAVEK_ID);//11
   \   000001EE   0x220B             MOVS     R2,#+11
   \   000001F0   0x210B             MOVS     R1,#+11
   \   000001F2   0x0020             MOVS     R0,R4
   \   000001F4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F6   0x.... 0x....      BL       LPLD_CAN_Enable_RX_Buf
    212              LPLD_CAN_Enable_RX_Buf(canx,MB_NUM_12,FILTER_SLAVEL_ID);//12
   \   000001FA   0x220C             MOVS     R2,#+12
   \   000001FC   0x210C             MOVS     R1,#+12
   \   000001FE   0x0020             MOVS     R0,R4
   \   00000200   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000202   0x.... 0x....      BL       LPLD_CAN_Enable_RX_Buf
    213              //->Initialize the Rx Individual Mask Registers
    214              //设置每个邮箱的匹配寄存器，用到那个邮箱设置哪给
    215              canptr->RXIMR[0]  = 0x00000000;
   \   00000206   0x2000             MOVS     R0,#+0
   \   00000208   0xF8C5 0x0880      STR      R0,[R5, #+2176]
    216              canptr->RXIMR[1]  = 0x1FFFFFFF; //设置28位屏蔽位
   \   0000020C   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000210   0xF8C5 0x0884      STR      R0,[R5, #+2180]
    217              canptr->RXIMR[2]  = 0x1FFFFFFF; //设置28位屏蔽位
   \   00000214   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000218   0xF8C5 0x0888      STR      R0,[R5, #+2184]
    218              canptr->RXIMR[3]  = 0x1FFFFFFF; //设置28位屏蔽位
   \   0000021C   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000220   0xF8C5 0x088C      STR      R0,[R5, #+2188]
    219              canptr->RXIMR[4]  = 0x1FFFFFFF; //设置28位屏蔽位
   \   00000224   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000228   0xF8C5 0x0890      STR      R0,[R5, #+2192]
    220              canptr->RXIMR[5]  = 0x1FFFFFFF; //设置28位屏蔽位
   \   0000022C   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000230   0xF8C5 0x0894      STR      R0,[R5, #+2196]
    221              canptr->RXIMR[6]  = 0x1FFFFFFF; //设置28位屏蔽位
   \   00000234   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000238   0xF8C5 0x0898      STR      R0,[R5, #+2200]
    222              canptr->RXIMR[7]  = 0x1FFFFFFF; //设置28位屏蔽位
   \   0000023C   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000240   0xF8C5 0x089C      STR      R0,[R5, #+2204]
    223              canptr->RXIMR[8]  = 0x1FFFFFFF; //设置28位屏蔽位
   \   00000244   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000248   0xF8C5 0x08A0      STR      R0,[R5, #+2208]
    224              canptr->RXIMR[9]  = 0x1FFFFFFF; //设置28位屏蔽位
   \   0000024C   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000250   0xF8C5 0x08A4      STR      R0,[R5, #+2212]
    225              canptr->RXIMR[10] = 0x1FFFFFFF; //设置28位屏蔽位
   \   00000254   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000258   0xF8C5 0x08A8      STR      R0,[R5, #+2216]
    226              canptr->RXIMR[11] = 0x1FFFFFFF; //设置28位屏蔽位
   \   0000025C   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000260   0xF8C5 0x08AC      STR      R0,[R5, #+2220]
    227              canptr->RXIMR[12] = 0x1FFFFFFF; //设置28位屏蔽位
   \   00000264   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000268   0xF8C5 0x08B0      STR      R0,[R5, #+2224]
    228              canptr->RXIMR[13] = 0x1FFFFFFF; //设置28位屏蔽位
   \   0000026C   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000270   0xF8C5 0x08B4      STR      R0,[R5, #+2228]
    229              canptr->RXIMR[14] = 0x1FFFFFFF; //设置28位屏蔽位
   \   00000274   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000278   0xF8C5 0x08B8      STR      R0,[R5, #+2232]
    230              canptr->RXIMR[15] = 0x1FFFFFFF; //设置28位屏蔽位
   \   0000027C   0xF07F 0x4060      MVNS     R0,#-536870912
   \   00000280   0xF8C5 0x08BC      STR      R0,[R5, #+2236]
    231              //Set required interrupt mask bits in the IMASK Registers (for all MB interrupts), in
    232              //CTRL Register (for Bus Off and Error interrupts) and in MCR Register for Wake-Up interrupt
    233              //清除所有邮箱的标志位
    234              LPLD_CAN_ClearAllFlag(canx);
   \   00000284   0x0020             MOVS     R0,R4
   \   00000286   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000288   0x.... 0x....      BL       LPLD_CAN_ClearAllFlag
    235              //使能接受邮箱中断
    236              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_1);
   \   0000028C   0x2101             MOVS     R1,#+1
   \   0000028E   0x0020             MOVS     R0,R4
   \   00000290   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000292   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    237              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_2);
   \   00000296   0x2102             MOVS     R1,#+2
   \   00000298   0x0020             MOVS     R0,R4
   \   0000029A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000029C   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    238              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_3);
   \   000002A0   0x2103             MOVS     R1,#+3
   \   000002A2   0x0020             MOVS     R0,R4
   \   000002A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002A6   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    239              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_4);
   \   000002AA   0x2104             MOVS     R1,#+4
   \   000002AC   0x0020             MOVS     R0,R4
   \   000002AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002B0   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    240              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_5);
   \   000002B4   0x2105             MOVS     R1,#+5
   \   000002B6   0x0020             MOVS     R0,R4
   \   000002B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002BA   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    241              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_6);
   \   000002BE   0x2106             MOVS     R1,#+6
   \   000002C0   0x0020             MOVS     R0,R4
   \   000002C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002C4   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    242              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_7);
   \   000002C8   0x2107             MOVS     R1,#+7
   \   000002CA   0x0020             MOVS     R0,R4
   \   000002CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002CE   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    243              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_8);
   \   000002D2   0x2108             MOVS     R1,#+8
   \   000002D4   0x0020             MOVS     R0,R4
   \   000002D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002D8   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    244              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_9);
   \   000002DC   0x2109             MOVS     R1,#+9
   \   000002DE   0x0020             MOVS     R0,R4
   \   000002E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002E2   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    245              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_10);
   \   000002E6   0x210A             MOVS     R1,#+10
   \   000002E8   0x0020             MOVS     R0,R4
   \   000002EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002EC   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    246              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_11);
   \   000002F0   0x210B             MOVS     R1,#+11
   \   000002F2   0x0020             MOVS     R0,R4
   \   000002F4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002F6   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    247              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_12);
   \   000002FA   0x210C             MOVS     R1,#+12
   \   000002FC   0x0020             MOVS     R0,R4
   \   000002FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000300   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    248              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_13);
   \   00000304   0x210D             MOVS     R1,#+13
   \   00000306   0x0020             MOVS     R0,R4
   \   00000308   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000030A   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    249              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_14);
   \   0000030E   0x210E             MOVS     R1,#+14
   \   00000310   0x0020             MOVS     R0,R4
   \   00000312   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000314   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    250              LPLD_CAN_Enable_Interrupt(canx,MB_NUM_15);
   \   00000318   0x210F             MOVS     R1,#+15
   \   0000031A   0x0020             MOVS     R0,R4
   \   0000031C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000031E   0x.... 0x....      BL       LPLD_CAN_Enable_Interrupt
    251              //Negate the HALT bit in MCR
    252              
    253              //只有在冻结模式下才能配置，配置完推出冻结模式
    254              CAN_MCR_REG(canptr) &= ~(CAN_MCR_HALT_MASK);
   \   00000322   0x6828             LDR      R0,[R5, #+0]
   \   00000324   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   00000328   0x6028             STR      R0,[R5, #+0]
    255              //等待直到退出冻结模式
    256              while( CAN_MCR_REG(canptr) & CAN_MCR_FRZACK_MASK);    
   \                     ??LPLD_CAN_Init_13:
   \   0000032A   0x6828             LDR      R0,[R5, #+0]
   \   0000032C   0x01C0             LSLS     R0,R0,#+7
   \   0000032E   0xD4FC             BMI.N    ??LPLD_CAN_Init_13
    257              //等到不在冻结模式，休眠模式或者停止模式
    258              while((CAN_MCR_REG(canptr) & CAN_MCR_NOTRDY_MASK));
   \                     ??LPLD_CAN_Init_14:
   \   00000330   0x6828             LDR      R0,[R5, #+0]
   \   00000332   0x0100             LSLS     R0,R0,#+4
   \   00000334   0xD4FC             BMI.N    ??LPLD_CAN_Init_14
    259              //Starting with the last event, FlexCAN attempts to synchronize to the CAN bus.
    260              return 1;
   \   00000336   0x2001             MOVS     R0,#+1
   \                     ??LPLD_CAN_Init_10:
   \   00000338   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    261          }
    262          
    263          /*
    264           * LPLD_CAN_SetIsr
    265           * 该函数用于Flex_CAN模块的16个中断源配置
    266           * 参数:
    267           *    canx--设置CAN模块号
    268           *      |__CAN0             -CAN0号模块
    269           *      |__CAN1             -CAN1号模块
    270           *    can_int_type--配置中断方式
    271           *      |__FLEXCAN_MB_INT               -邮箱中断
    272           *      |__FLEXCAN_BUS_OFF_INT          -总线关闭
    273           *      |__FLEXCAN_ERROR_INT            -错误中断
    274           *      |__FLEXCAN_TRANS_WARNING_INT    -发送警告中断
    275           *      |__FLEXCAN_RECV_WARNING_INT     -接收警告中断
    276           *      |__FLEXCAN_WAKEUP_INT           -唤醒中断
    277           *      |__FLEXCAN_IMEU_INT             -独立匹配元素更新
    278           *      |__FLEXCAN_LOST_RECV_INT        -接收丢失中断 
    279           *    isr_func--用户中断程序入口地址
    280           *      |__用户在工程文件下定义的中断函数名，函数必须为:无返回值,无参数(eg. void isr(void);)
    281           * 输出:
    282           *    无
    283           */

   \                                 In section .text, align 2, keep-with-next
    284          void LPLD_CAN_SetIsr(CANx canx, uint8 can_int_type, CAN_ISR_CALLBACK isr_func)
    285          {
   \                     LPLD_CAN_SetIsr:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    286            //参数检查
    287            ASSERT( canx <=  CAN0);                                 //模块号
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD305             BCC.N    ??LPLD_CAN_SetIsr_0
   \   0000000E   0xF240 0x111F      MOVW     R1,#+287
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable12_8
   \   00000016   0x.... 0x....      BL       assert_failed
    288            ASSERT( can_int_type <= FLEXCAN_LOST_RECV_INT);         //中断类型
   \                     ??LPLD_CAN_SetIsr_0:
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D08             CMP      R5,#+8
   \   0000001E   0xD305             BCC.N    ??LPLD_CAN_SetIsr_1
   \   00000020   0xF44F 0x7190      MOV      R1,#+288
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable12_8
   \   00000028   0x.... 0x....      BL       assert_failed
    289            
    290            enable_irq(29 + canx*8 + can_int_type);
   \                     ??LPLD_CAN_SetIsr_1:
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x00E0             LSLS     R0,R4,#+3
   \   00000030   0xFA50 0xF085      UXTAB    R0,R0,R5
   \   00000034   0x301D             ADDS     R0,R0,#+29
   \   00000036   0x.... 0x....      BL       enable_irq
    291            CAN_ISR[canx*8 + can_int_type] = isr_func;
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x00E0             LSLS     R0,R4,#+3
   \   0000003E   0xFA50 0xF085      UXTAB    R0,R0,R5
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable12_9
   \   00000046   0xF841 0x6020      STR      R6,[R1, R0, LSL #+2]
    292            
    293          }
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    294          
    295          
    296          /*
    297           * LPLD_CAN_SendData
    298           * 该函数用于Flex_CAN模块向总线发送数据
    299           * 参数:
    300           *    canx--设置CAN总线通道
    301           *      |__CAN0             -CAN0号模块
    302           *      |__CAN1             -CAN1号模块
    303           *    mbx--对应的邮箱号
    304           *      |__MB_NUM_0         --邮箱0
    305           *      |__...              --...
    306           *      |__MB_NUM_15        --邮箱15
    307           *    id--目标位置的id号  
    308           *    len--发送数据的字节数，最大8个字节   
    309           *    *data--发送数据的缓冲区
    310           * 输出:
    311           *    0:配置出现错误
    312           *    1:配置成功
    313           */

   \                                 In section .text, align 2, keep-with-next
    314          uint8 LPLD_CAN_SendData(CANx canx, uint16 mbx, uint32 id, uint8 len, uint8 *data)
    315          {
   \                     LPLD_CAN_SendData:
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
    316              int16  i,j,k;
    317              uint32 word[2] = {0};
   \   00000004   0xAC00             ADD      R4,SP,#+0
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0xC460             STM      R4!,{R5,R6}
   \   0000000C   0x3C08             SUBS     R4,R4,#+8
    318              CAN_MemMapPtr canptr = CANx_Ptr[canx];
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable12
   \   00000014   0xF854 0x0020      LDR      R0,[R4, R0, LSL #+2]
    319              
    320              //判断缓冲区和数据长度设置错误
    321              if(mbx >= MB_MAX_NO || len > MB_MAX_DATA)
   \   00000018   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001A   0x2910             CMP      R1,#+16
   \   0000001C   0xD202             BCS.N    ??LPLD_CAN_SendData_0
   \   0000001E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000020   0x2B09             CMP      R3,#+9
   \   00000022   0xD301             BCC.N    ??LPLD_CAN_SendData_1
    322                  return 0; //超出范围
   \                     ??LPLD_CAN_SendData_0:
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE09E             B.N      ??LPLD_CAN_SendData_2
    323              
    324              //将8个字节转换成32位的word存储
    325              //首先判断当前数据包含字节数
    326              j = (len-1)/4; //是否超过4字节
   \                     ??LPLD_CAN_SendData_1:
   \   00000028   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002A   0x1E5C             SUBS     R4,R3,#+1
   \   0000002C   0x2504             MOVS     R5,#+4
   \   0000002E   0xFB94 0xF4F5      SDIV     R4,R4,R5
    327              k = (len-1)%4; //
   \   00000032   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000034   0x1E5E             SUBS     R6,R3,#+1
   \   00000036   0x2704             MOVS     R7,#+4
   \   00000038   0xFB96 0xF5F7      SDIV     R5,R6,R7
   \   0000003C   0xFB05 0x6517      MLS      R5,R5,R7,R6
   \   00000040   0x9E08             LDR      R6,[SP, #+32]
    328              if(j > 0)         //长度大于4(即发送数据超过4字节)
   \   00000042   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000044   0x2C01             CMP      R4,#+1
   \   00000046   0xDB0F             BLT.N    ??LPLD_CAN_SendData_3
    329              {
    330                word[0] = ((data[0]<<24) | (data[1]<<16) | (data[2]<< 8) |  data[3] );
   \   00000048   0x7837             LDRB     R7,[R6, #+0]
   \   0000004A   0xF896 0xC001      LDRB     R12,[R6, #+1]
   \   0000004E   0xEA5F 0x4C0C      LSLS     R12,R12,#+16
   \   00000052   0xEA5C 0x6707      ORRS     R7,R12,R7, LSL #+24
   \   00000056   0xF896 0xC002      LDRB     R12,[R6, #+2]
   \   0000005A   0xEA57 0x270C      ORRS     R7,R7,R12, LSL #+8
   \   0000005E   0xF896 0xC003      LDRB     R12,[R6, #+3]
   \   00000062   0xEA5C 0x0707      ORRS     R7,R12,R7
   \   00000066   0x9700             STR      R7,[SP, #+0]
    331              }
    332              for(i = 0; i <= k ; i++)
   \                     ??LPLD_CAN_SendData_3:
   \   00000068   0x2700             MOVS     R7,#+0
   \   0000006A   0xE01A             B.N      ??LPLD_CAN_SendData_4
    333              {
    334                 word[j] |= data[(j<<2)+i] << (24-(i<<3)); 
   \                     ??LPLD_CAN_SendData_5:
   \   0000006C   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000006E   0xF10D 0x0C00      ADD      R12,SP,#+0
   \   00000072   0xF85C 0xC024      LDR      R12,[R12, R4, LSL #+2]
   \   00000076   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000078   0xEA5F 0x0E84      LSLS     LR,R4,#+2
   \   0000007C   0xFA0E 0xFE87      SXTAH    LR,LR,R7
   \   00000080   0xF81E 0xE006      LDRB     LR,[LR, R6]
   \   00000084   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000086   0xEA5F 0x08C7      LSLS     R8,R7,#+3
   \   0000008A   0xF1D8 0x0818      RSBS     R8,R8,#+24
   \   0000008E   0xFA1E 0xFE08      LSLS     LR,LR,R8
   \   00000092   0xEA5E 0x0C0C      ORRS     R12,LR,R12
   \   00000096   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000098   0xF10D 0x0E00      ADD      LR,SP,#+0
   \   0000009C   0xF84E 0xC024      STR      R12,[LR, R4, LSL #+2]
    335              }
   \   000000A0   0x1C7F             ADDS     R7,R7,#+1
   \                     ??LPLD_CAN_SendData_4:
   \   000000A2   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \   000000A4   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   000000A6   0x42BD             CMP      R5,R7
   \   000000A8   0xDAE0             BGE.N    ??LPLD_CAN_SendData_5
    336              
    337              //通过id判断帧类型――扩展帧
    338              j = (id &  CAN_MSG_IDE_MASK)>>CAN_MSG_IDE_BIT_NO;  //IDE
   \   000000AA   0x0FD4             LSRS     R4,R2,#+31
    339              //通过id判断帧类型――远程帧
    340              k = (id &  CAN_MSG_TYPE_MASK)>>CAN_MSG_TYPE_BIT_NO;//RTR
   \   000000AC   0x0F95             LSRS     R5,R2,#+30
   \   000000AE   0xF015 0x0501      ANDS     R5,R5,#0x1
    341              
    342              //获得ID位数
    343              i =  j? 0: FLEXCAN_MB_ID_STD_BIT_NO;
   \   000000B2   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   000000B4   0x2C00             CMP      R4,#+0
   \   000000B6   0xD001             BEQ.N    ??LPLD_CAN_SendData_6
   \   000000B8   0x2700             MOVS     R7,#+0
   \   000000BA   0xE000             B.N      ??LPLD_CAN_SendData_7
   \                     ??LPLD_CAN_SendData_6:
   \   000000BC   0x2712             MOVS     R7,#+18
    344              
    345              if(canptr->IFLAG1 & (1<<mbx))
   \                     ??LPLD_CAN_SendData_7:
   \   000000BE   0x6B06             LDR      R6,[R0, #+48]
   \   000000C0   0xF05F 0x0C01      MOVS     R12,#+1
   \   000000C4   0xFA1C 0xFC01      LSLS     R12,R12,R1
   \   000000C8   0xEA16 0x0F0C      TST      R6,R12
   \   000000CC   0xD002             BEQ.N    ??LPLD_CAN_SendData_8
    346                canptr->IFLAG1 = (1<<mbx);
   \   000000CE   0x2601             MOVS     R6,#+1
   \   000000D0   0x408E             LSLS     R6,R6,R1
   \   000000D2   0x6306             STR      R6,[R0, #+48]
    347              //以下四步骤为发送过程
    348              //先缓冲区写激活码
    349              canptr->MB[mbx].CS = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_INACTIVE);
   \                     ??LPLD_CAN_SendData_8:
   \   000000D4   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D6   0xEB10 0x1601      ADDS     R6,R0,R1, LSL #+4
   \   000000DA   0xF05F 0x6C00      MOVS     R12,#+134217728
   \   000000DE   0xF8C6 0xC080      STR      R12,[R6, #+128]
    350              
    351              //向缓冲区写目标ID
    352              canptr->MB[mbx].ID = (1 << FLEXCAN_MB_ID_PRIO_BIT_NO) | ((id & ~(CAN_MSG_IDE_MASK|CAN_MSG_TYPE_MASK))<<i);  
   \   000000E2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000E4   0xEB10 0x1601      ADDS     R6,R0,R1, LSL #+4
   \   000000E8   0x0092             LSLS     R2,R2,#+2        ;; ZeroExtS R2,R2,#+2,#+2
   \   000000EA   0x0892             LSRS     R2,R2,#+2
   \   000000EC   0x40BA             LSLS     R2,R2,R7
   \   000000EE   0xF052 0x5200      ORRS     R2,R2,#0x20000000
   \   000000F2   0xF8C6 0x2084      STR      R2,[R6, #+132]
    353              
    354              //向缓冲区写数据
    355              canptr->MB[mbx].WORD0 = word[0];
   \   000000F6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000F8   0xEB10 0x1201      ADDS     R2,R0,R1, LSL #+4
   \   000000FC   0x9E00             LDR      R6,[SP, #+0]
   \   000000FE   0xF8C2 0x6088      STR      R6,[R2, #+136]
    356              canptr->MB[mbx].WORD1 = word[1];  
   \   00000102   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000104   0xEB10 0x1201      ADDS     R2,R0,R1, LSL #+4
   \   00000108   0x9E01             LDR      R6,[SP, #+4]
   \   0000010A   0xF8C2 0x608C      STR      R6,[R2, #+140]
    357              
    358              //通过制定的发送代码开始发送
    359              canptr->MB[mbx].CS = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_TX_ONCE)//写激活代码
    360                                         | (j<<FLEXCAN_MB_CS_IDE_BIT_NO)          //缓冲区写IDE位
    361          			       | (k<<FLEXCAN_MB_CS_RTR_BIT_NO)          //缓冲区写RTR位
    362                                         | FLEXCAN_MB_CS_LENGTH(len);            //缓冲区写数据长度
   \   0000010E   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000110   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \   00000112   0x052A             LSLS     R2,R5,#+20
   \   00000114   0xEA52 0x5244      ORRS     R2,R2,R4, LSL #+21
   \   00000118   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000011A   0xF013 0x030F      ANDS     R3,R3,#0xF
   \   0000011E   0xEA52 0x4203      ORRS     R2,R2,R3, LSL #+16
   \   00000122   0xF052 0x6240      ORRS     R2,R2,#0xC000000
   \   00000126   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000128   0xEB10 0x1301      ADDS     R3,R0,R1, LSL #+4
   \   0000012C   0xF8C3 0x2080      STR      R2,[R3, #+128]
    363              for(i = 0;i <1000;i++); //等待缓冲区装载完成
   \   00000130   0x2700             MOVS     R7,#+0
   \   00000132   0xE000             B.N      ??LPLD_CAN_SendData_9
   \                     ??LPLD_CAN_SendData_10:
   \   00000134   0x1C7F             ADDS     R7,R7,#+1
   \                     ??LPLD_CAN_SendData_9:
   \   00000136   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000138   0xF5B7 0x7F7A      CMP      R7,#+1000
   \   0000013C   0xDBFA             BLT.N    ??LPLD_CAN_SendData_10
    364          							
    365              //限时等待发送完成（如果使用中断则限时等待语句可删除）
    366              i=0;
   \   0000013E   0x2700             MOVS     R7,#+0
    367              while(!(canptr->IFLAG1 & (1<<mbx)))
   \                     ??LPLD_CAN_SendData_11:
   \   00000140   0x6B02             LDR      R2,[R0, #+48]
   \   00000142   0x2301             MOVS     R3,#+1
   \   00000144   0x408B             LSLS     R3,R3,R1
   \   00000146   0x421A             TST      R2,R3
   \   00000148   0xD108             BNE.N    ??LPLD_CAN_SendData_12
    368              {
    369              	if((i++)>0x1000)
   \   0000014A   0x003A             MOVS     R2,R7
   \   0000014C   0x1C57             ADDS     R7,R2,#+1
   \   0000014E   0xF241 0x0301      MOVW     R3,#+4097
   \   00000152   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   00000154   0x429A             CMP      R2,R3
   \   00000156   0xDBF3             BLT.N    ??LPLD_CAN_SendData_11
    370                    return 0;
   \   00000158   0x2000             MOVS     R0,#+0
   \   0000015A   0xE004             B.N      ??LPLD_CAN_SendData_2
    371              }
    372              //清报文缓冲区中断标志
    373              canptr->IFLAG1 = (1<<mbx);
   \                     ??LPLD_CAN_SendData_12:
   \   0000015C   0x2201             MOVS     R2,#+1
   \   0000015E   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000162   0x6301             STR      R1,[R0, #+48]
    374              return 1;
   \   00000164   0x2001             MOVS     R0,#+1
   \                     ??LPLD_CAN_SendData_2:
   \   00000166   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    375          }
    376          
    377          /*
    378           * LPLD_CAN_Enable_RX_Buf
    379           * 该函数用于使能Flex_CAN模块的接收缓冲区
    380           * 参数:
    381           *    canx--设置CAN总线通道
    382           *      |__CAN0             --CAN0号模块
    383           *      |__CAN1             --CAN1号模块
    384           *    mbx--对应的邮箱号
    385           *      |__MB_NUM_0         --邮箱0
    386           *      |__...              --...
    387           *      |__MB_NUM_15        --邮箱15
    388           *    id--接收缓冲的ID，用于和接收到的ID进行匹配。
    389           * 输出:
    390           *    无
    391           *
    392           */

   \                                 In section .text, align 2, keep-with-next
    393          void LPLD_CAN_Enable_RX_Buf(CANx canx, uint16 mbx, uint32 id)
    394          {
   \                     LPLD_CAN_Enable_RX_Buf:
   \   00000000   0xB430             PUSH     {R4,R5}
    395              uint32 idemp;
    396              //获得当前缓冲区的CODE值0X0100
    397              uint32 cs = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_EMPTY); 
   \   00000002   0xF05F 0x6380      MOVS     R3,#+67108864
    398              CAN_MemMapPtr canptr = CANx_Ptr[canx];
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x....             LDR.N    R4,??DataTable12
   \   0000000A   0xF854 0x4020      LDR      R4,[R4, R0, LSL #+2]
    399          
    400              //将MB配置为非激活状态
    401              canptr->MB[mbx].CS = FLEXCAN_MB_CS_CODE(FLEXCAN_MB_CODE_RX_INACTIVE); 	
   \   0000000E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000010   0xEB14 0x1001      ADDS     R0,R4,R1, LSL #+4
   \   00000014   0x2500             MOVS     R5,#+0
   \   00000016   0xF8C0 0x5080      STR      R5,[R0, #+128]
    402              
    403              //取出29位单独的ID
    404              idemp = id & 0x1FFFFFFF;
   \   0000001A   0x00D0             LSLS     R0,R2,#+3        ;; ZeroExtS R0,R2,#+3,#+3
   \   0000001C   0x08C0             LSRS     R0,R0,#+3
    405              
    406              //设置ID用于接收的数据帧和邮箱的ID进行匹配
    407              if(id & CAN_MSG_IDE_MASK)//扩展帧
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD507             BPL.N    ??LPLD_CAN_Enable_RX_Buf_0
    408              {
    409                  canptr->MB[mbx].ID = idemp;
   \   00000022   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000024   0xEB14 0x1201      ADDS     R2,R4,R1, LSL #+4
   \   00000028   0xF8C2 0x0084      STR      R0,[R2, #+132]
    410                  cs |= FLEXCAN_MB_CS_IDE;//置位IDE位，设置为扩展帧
   \   0000002C   0xF453 0x1300      ORRS     R3,R3,#0x200000
   \   00000030   0xE005             B.N      ??LPLD_CAN_Enable_RX_Buf_1
    411              }
    412              else//标准帧
    413              {
    414                  //将ID左移18位存储在标准帧的ID位置
    415                  canptr->MB[mbx].ID = (idemp << FLEXCAN_MB_ID_STD_BIT_NO); //取标准帧的ID号          
   \                     ??LPLD_CAN_Enable_RX_Buf_0:
   \   00000032   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000034   0xEB14 0x1201      ADDS     R2,R4,R1, LSL #+4
   \   00000038   0x0480             LSLS     R0,R0,#+18
   \   0000003A   0xF8C2 0x0084      STR      R0,[R2, #+132]
    416              }
    417              
    418              //激活接收缓冲区，code写0100
    419              canptr->MB[mbx].CS = cs;  //设置为接受缓冲区，用于接受数据    
   \                     ??LPLD_CAN_Enable_RX_Buf_1:
   \   0000003E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000040   0xEB14 0x1001      ADDS     R0,R4,R1, LSL #+4
   \   00000044   0xF8C0 0x3080      STR      R3,[R0, #+128]
    420          }
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
    421          
    422          /*
    423           * LPLD_CAN_RecvData
    424           * 该函数用于接收Flex_CAN模块从总线获取的数据
    425           * 参数:
    426           *    canx--设置CAN总线通道
    427           *      |__CAN0             --CAN0号模块
    428           *      |__CAN1             --CAN1号模块
    429           *    mbx--对应的邮箱号
    430           *      |__MB_NUM_0         --邮箱0
    431           *      |__...              --...
    432           *      |__MB_NUM_15        --邮箱15
    433           *    *id--接收到的ID   
    434           *    *len--接收到的数据长度指针
    435           *    *data--接收到的数据缓冲区指针
    436           * 输出:
    437           *    0:配置时出现错误
    438           *    1:配置时成功
    439           */

   \                                 In section .text, align 2, keep-with-next
    440          uint8 LPLD_CAN_RecvData(CANx canx, uint16 mbx, uint32 *id, uint8 *len, uint8 *data)  
    441          {
   \                     LPLD_CAN_RecvData:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x4690             MOV      R8,R2
   \   00000008   0x001C             MOVS     R4,R3
   \   0000000A   0x9D06             LDR      R5,[SP, #+24]
    442              int8   i,j,k;
    443              int8   format;
    444              uint16 code;
    445              int16  length;   
    446              uint8  *pMBData;
    447              uint8  *pBytes = data;
    448              CAN_MemMapPtr canptr = CANx_Ptr[canx];
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x....             LDR.N    R1,??DataTable12
   \   00000010   0xF851 0x7020      LDR      R7,[R1, R0, LSL #+2]
    449              
    450              //读timer值解除邮箱自锁
    451              //在一般模式（相对于FIFO接收）下，必须首先解锁邮箱
    452              LPLD_CAN_Unlock_MBx(CAN0);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       LPLD_CAN_Unlock_MBx
    453              
    454              code = FLEXCAN_GET_CODE(canptr->MB[mbx].CS);
   \   0000001A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001C   0xEB17 0x1006      ADDS     R0,R7,R6, LSL #+4
   \   00000020   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   00000024   0x0E00             LSRS     R0,R0,#+24
   \   00000026   0xF010 0x000F      ANDS     R0,R0,#0xF
    455              //如果是 FULL 或 OVERRUN状态 证明接受到数据
    456              if(code != RX_BUF_STATUS_FULL && code != RX_BUF_STATUS_OVERRUN)
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD006             BEQ.N    ??LPLD_CAN_RecvData_0
   \   00000030   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000032   0x2806             CMP      R0,#+6
   \   00000034   0xD003             BEQ.N    ??LPLD_CAN_RecvData_0
    457              {
    458                *len = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7020             STRB     R0,[R4, #+0]
    459                return 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE079             B.N      ??LPLD_CAN_RecvData_1
    460              }
    461              length = FLEXCAN_GET_LENGTH(canptr->MB[mbx].CS);  //取MB结构中CS的DLC值
   \                     ??LPLD_CAN_RecvData_0:
   \   0000003E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000040   0xEB17 0x1006      ADDS     R0,R7,R6, LSL #+4
   \   00000044   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   00000048   0x0C00             LSRS     R0,R0,#+16
   \   0000004A   0xF010 0x000F      ANDS     R0,R0,#0xF
    462              
    463              if(length <1)//接收到的数据长度小于1，返回错误
   \   0000004E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xDA03             BGE.N    ??LPLD_CAN_RecvData_2
    464              {
    465                *len = 0;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x7020             STRB     R0,[R4, #+0]
    466                return 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE06A             B.N      ??LPLD_CAN_RecvData_1
    467              }
    468             
    469              //判断是标准帧还是扩展帧
    470              format = (canptr->MB[mbx].CS & FLEXCAN_MB_CS_IDE)? 1:0;//判断IDE位
   \                     ??LPLD_CAN_RecvData_2:
   \   0000005C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000005E   0xEB17 0x1106      ADDS     R1,R7,R6, LSL #+4
   \   00000062   0xF8D1 0x1080      LDR      R1,[R1, #+128]
   \   00000066   0xF3C1 0x5140      UBFX     R1,R1,#+21,#+1
   \   0000006A   0xF011 0x0101      ANDS     R1,R1,#0x1
    471              *id    = (canptr->MB[mbx].ID & FLEXCAN_MB_ID_EXT_MASK); //在接受回来的帧中，先按扩展帧提取ID，之后根据format判断后，进一步处理ID
   \   0000006E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000070   0xEB17 0x1206      ADDS     R2,R7,R6, LSL #+4
   \   00000074   0xF8D2 0x2084      LDR      R2,[R2, #+132]
   \   00000078   0x00D2             LSLS     R2,R2,#+3        ;; ZeroExtS R2,R2,#+3,#+3
   \   0000007A   0x08D2             LSRS     R2,R2,#+3
   \   0000007C   0xF8C8 0x2000      STR      R2,[R8, #+0]
    472           
    473              if(!format) //format=0,标准帧
   \   00000080   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000082   0x2900             CMP      R1,#+0
   \   00000084   0xD105             BNE.N    ??LPLD_CAN_RecvData_3
    474              {
    475                *id >>= FLEXCAN_MB_ID_STD_BIT_NO; // 获得标准帧号
   \   00000086   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   0000008A   0x0C89             LSRS     R1,R1,#+18
   \   0000008C   0xF8C8 0x1000      STR      R1,[R8, #+0]
   \   00000090   0xE005             B.N      ??LPLD_CAN_RecvData_4
    476              }
    477              else   
    478              { 
    479                *id |= CAN_MSG_IDE_MASK; //标记扩展的ID        
   \                     ??LPLD_CAN_RecvData_3:
   \   00000092   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   00000096   0xF051 0x4100      ORRS     R1,R1,#0x80000000
   \   0000009A   0xF8C8 0x1000      STR      R1,[R8, #+0]
    480              }
    481             //判断是远程帧or数据帧
    482              format = (canptr->MB[mbx].CS & FLEXCAN_MB_CS_RTR)? 1:0;  
   \                     ??LPLD_CAN_RecvData_4:
   \   0000009E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000A0   0xEB17 0x1106      ADDS     R1,R7,R6, LSL #+4
   \   000000A4   0xF8D1 0x1080      LDR      R1,[R1, #+128]
   \   000000A8   0xF3C1 0x5100      UBFX     R1,R1,#+20,#+1
   \   000000AC   0xF011 0x0101      ANDS     R1,R1,#0x1
    483              if(format)
   \   000000B0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B2   0x2900             CMP      R1,#+0
   \   000000B4   0xD005             BEQ.N    ??LPLD_CAN_RecvData_5
    484              {
    485                *id |= CAN_MSG_TYPE_MASK; //标记为远程帧类型       
   \   000000B6   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   000000BA   0xF051 0x4180      ORRS     R1,R1,#0x40000000
   \   000000BE   0xF8C8 0x1000      STR      R1,[R8, #+0]
    486              }
    487              //读取报文数据
    488              j = (length-1)>>2; //1
   \                     ??LPLD_CAN_RecvData_5:
   \   000000C2   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000000C4   0x1E41             SUBS     R1,R0,#+1
   \   000000C6   0x1089             ASRS     R1,R1,#+2
    489              k = length-1;      //7
   \   000000C8   0x0002             MOVS     R2,R0
   \   000000CA   0x1E52             SUBS     R2,R2,#+1
    490              if(j > 0)//如果接收的是8字节数据
   \   000000CC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000CE   0x2901             CMP      R1,#+1
   \   000000D0   0xD318             BCC.N    ??LPLD_CAN_RecvData_6
    491              {  
    492                //将word0中的数据提取出来
    493                (*(uint32*)pBytes) = canptr->MB[mbx].WORD0;
   \   000000D2   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000D4   0xEB17 0x1306      ADDS     R3,R7,R6, LSL #+4
   \   000000D8   0xF8D3 0x3088      LDR      R3,[R3, #+136]
   \   000000DC   0x602B             STR      R3,[R5, #+0]
    494                //调换顺序0 1 2 3-->3 2 1 0
    495                swap_bytes(pBytes);    
   \   000000DE   0x782B             LDRB     R3,[R5, #+0]
   \   000000E0   0xF895 0xC003      LDRB     R12,[R5, #+3]
   \   000000E4   0xF885 0xC000      STRB     R12,[R5, #+0]
   \   000000E8   0x70EB             STRB     R3,[R5, #+3]
   \   000000EA   0x786B             LDRB     R3,[R5, #+1]
   \   000000EC   0xF895 0xC002      LDRB     R12,[R5, #+2]
   \   000000F0   0xF885 0xC001      STRB     R12,[R5, #+1]
   \   000000F4   0x70AB             STRB     R3,[R5, #+2]
    496                k -= 4;
   \   000000F6   0x1F12             SUBS     R2,R2,#+4
    497                //将WORD1的最高字节地址付给pMBData
    498                pMBData = (uint8*)&canptr->MB[mbx].WORD1+3;
   \   000000F8   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000FA   0xEB17 0x1306      ADDS     R3,R7,R6, LSL #+4
   \   000000FE   0xF203 0x068F      ADDW     R6,R3,#+143
   \   00000102   0xE004             B.N      ??LPLD_CAN_RecvData_7
    499              }
    500              else
    501              {
    502                pMBData = (uint8*)&canptr->MB[mbx].WORD0+3;
   \                     ??LPLD_CAN_RecvData_6:
   \   00000104   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000106   0xEB17 0x1306      ADDS     R3,R7,R6, LSL #+4
   \   0000010A   0xF203 0x068B      ADDW     R6,R3,#+139
    503              }
    504           
    505              for(i = 0; i <= k; i++)
   \                     ??LPLD_CAN_RecvData_7:
   \   0000010E   0x2300             MOVS     R3,#+0
   \   00000110   0xE009             B.N      ??LPLD_CAN_RecvData_8
    506              {
    507                pBytes[i+(j<<2)] = *pMBData--;	
   \                     ??LPLD_CAN_RecvData_9:
   \   00000112   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000114   0x008F             LSLS     R7,R1,#+2
   \   00000116   0xFA57 0xF783      UXTAB    R7,R7,R3
   \   0000011A   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   0000011E   0xF807 0xC005      STRB     R12,[R7, R5]
   \   00000122   0x1E76             SUBS     R6,R6,#+1
    508              }
   \   00000124   0x1C5B             ADDS     R3,R3,#+1
   \                     ??LPLD_CAN_RecvData_8:
   \   00000126   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000128   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000012A   0x429A             CMP      R2,R3
   \   0000012C   0xD2F1             BCS.N    ??LPLD_CAN_RecvData_9
    509              *len = length;
   \   0000012E   0x7020             STRB     R0,[R4, #+0]
    510              return 1;
   \   00000130   0x2001             MOVS     R0,#+1
   \                     ??LPLD_CAN_RecvData_1:
   \   00000132   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    511          }
    512          
    513          /*
    514           * LPLD_CAN_Enable_Interrupt
    515           * 该函数用于按位使能Flex_CAN模块的邮箱中断
    516           * 
    517           * 参数:
    518           *    canx--设置CAN总线通道
    519           *      |__CAN0             --CAN0号模块
    520           *      |__CAN1             --CAN1号模块
    521           *    mbx--对应的邮箱号
    522           *      |__MB_NUM_0         --邮箱0
    523           *      |__...              --...
    524           *      |__MB_NUM_15        --邮箱15
    525           * 输出:
    526           *    无
    527           *
    528           */

   \                                 In section .text, align 2, keep-with-next
    529          void LPLD_CAN_Enable_Interrupt(CANx canx, uint16 mbx)
    530          {
    531              CAN_MemMapPtr canptr = CANx_Ptr[canx];
   \                     LPLD_CAN_Enable_Interrupt:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R2,??DataTable12
   \   00000004   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
    532          
    533              //使能相应通道的中断
    534              CAN_IMASK1_REG(canptr) |= (1<<mbx); 
   \   00000008   0x6A82             LDR      R2,[R0, #+40]
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0xFA13 0xF101      LSLS     R1,R3,R1
   \   00000010   0x4311             ORRS     R1,R1,R2
   \   00000012   0x6281             STR      R1,[R0, #+40]
    535          }
   \   00000014   0x4770             BX       LR               ;; return
    536          
    537          /*
    538           * LPLD_CAN_Disable_Interrupt
    539           * 该函数用于按位禁止Flex_CAN模块的邮箱中断
    540           * 
    541           * 参数:
    542           *    canx--设置CAN总线通道
    543           *      |__CAN0             --CAN0号模块
    544           *      |__CAN1             --CAN1号模块
    545           *    mbx--对应的邮箱号
    546           *      |__MB_NUM_0         --邮箱0
    547           *      |__...              --...
    548           *      |__MB_NUM_15        --邮箱15
    549           * 输出:
    550           *    无
    551           *
    552           */

   \                                 In section .text, align 2, keep-with-next
    553          void LPLD_CAN_Disable_Interrupt(CANx canx, uint16 mbx)
    554          {
    555              CAN_MemMapPtr canptr = CANx_Ptr[canx];
   \                     LPLD_CAN_Disable_Interrupt:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R2,??DataTable12
   \   00000004   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
    556              
    557              CAN_IMASK1_REG(canptr) &= ~CAN_IMASK1_BUFLM(mbx);
   \   00000008   0x6A82             LDR      R2,[R0, #+40]
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0xEA32 0x0101      BICS     R1,R2,R1
   \   00000010   0x6281             STR      R1,[R0, #+40]
    558          }
   \   00000012   0x4770             BX       LR               ;; return
    559          
    560          /*
    561           * LPLD_CAN_ClearFlag
    562           * 该函数用于按位清除Flex_CAN模块的邮箱中断标志位
    563           * 
    564           * 参数:
    565           *    canx--设置CAN总线通道
    566           *      |__CAN0             --CAN0号模块
    567           *      |__CAN1             --CAN1号模块
    568           *    mbx--对应的邮箱号
    569           *      |__MB_NUM_0         --邮箱0
    570           *      |__...              --...
    571           *      |__MB_NUM_15        --邮箱15
    572           * 输出:
    573           *    无
    574           *
    575           */

   \                                 In section .text, align 2, keep-with-next
    576          void LPLD_CAN_ClearFlag(CANx canx, uint16 mbx)
    577          {
    578              CAN_MemMapPtr canptr = CANx_Ptr[canx];
   \                     LPLD_CAN_ClearFlag:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R2,??DataTable12
   \   00000004   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
    579              
    580              canptr->IFLAG1= (1<<mbx);
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xFA12 0xF101      LSLS     R1,R2,R1
   \   0000000E   0x6301             STR      R1,[R0, #+48]
    581          }
   \   00000010   0x4770             BX       LR               ;; return
    582          
    583          
    584          /*
    585           * LPLD_CAN_ClearAllFlag
    586           * 该函数用于清除所有Flex_CAN模块的邮箱中断标志位
    587           * 
    588           * 参数:
    589           *    canx--设置CAN总线通道
    590           *      |__CAN0             --CAN0号模块
    591           *      |__CAN1             --CAN1号模块
    592           * 输出:
    593           *    无
    594           *
    595           */

   \                                 In section .text, align 2, keep-with-next
    596          void LPLD_CAN_ClearAllFlag(CANx canx)
    597          {
    598              CAN_MemMapPtr canptr = CANx_Ptr[canx];
   \                     LPLD_CAN_ClearAllFlag:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R1,??DataTable12
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
    599              
    600              canptr->IFLAG1= 0xFFFF;
   \   00000008   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000000C   0x6301             STR      R1,[R0, #+48]
    601              canptr->IFLAG2= 0xFFFF;
   \   0000000E   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000012   0x62C1             STR      R1,[R0, #+44]
    602          }
   \   00000014   0x4770             BX       LR               ;; return
    603          
    604          
    605          /*
    606           * LPLD_CAN_Unlock_MBx
    607           * 该函数用于解锁Flex_CAN模块中的接收邮箱，通过读取自由计数器的值
    608           * 
    609           * 参数:
    610           *    canx--设置CAN总线通道
    611           *      |__CAN0             --CAN0号模块
    612           *      |__CAN1             --CAN1号模块
    613           *
    614           * 输出:
    615           *    返自由计数器的值
    616           *
    617           */

   \                                 In section .text, align 2, keep-with-next
    618          uint16 LPLD_CAN_Unlock_MBx(CANx canx)
    619          {
    620            CAN_MemMapPtr canptr = CANx_Ptr[canx];
   \                     LPLD_CAN_Unlock_MBx:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R1,??DataTable12
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
    621            uint16 timer;
    622          
    623            timer = CAN_TIMER_REG(canptr);
   \   00000008   0x6880             LDR      R0,[R0, #+8]
    624            return timer;
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0x4770             BX       LR               ;; return
    625          }
    626          
    627          /*
    628           * LPLD_CAN_GetFlag
    629           * 该函数用于获得Flex_CAN模块的邮箱中断标志位
    630           * 
    631           * 参数:
    632           *    canx--设置CAN总线通道
    633           *      |__CAN0             --CAN0号模块
    634           *      |__CAN1             --CAN1号模块
    635           *    mbx--对应的邮箱号
    636           *      |__MB_NUM_0         --邮箱0
    637           *      |__...              --...
    638           *      |__MB_NUM_15        --邮箱15
    639           * 输出:
    640           *    邮箱所对应的中断标志位
    641           *
    642           */

   \                                 In section .text, align 2, keep-with-next
    643          uint32 LPLD_CAN_GetFlag(CANx canx, uint16 mbx)
    644          {
    645            CAN_MemMapPtr canptr = CANx_Ptr[canx];
   \                     LPLD_CAN_GetFlag:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R2,??DataTable12
   \   00000004   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
    646            
    647            return (canptr->IFLAG1 & (1<<mbx));
   \   00000008   0x6B00             LDR      R0,[R0, #+48]
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000010   0x4008             ANDS     R0,R1,R0
   \   00000012   0x4770             BX       LR               ;; return
    648          }
    649          
    650          /*
    651           * LPLD_CAN_SetBaud
    652           * 设置指定CAN模块波特率
    653           * 参数:
    654           *    canx--设置CAN总线通道
    655           *      |__CAN0             --CAN0号模块
    656           *      |__CAN1             --CAN1号模块
    657           *    baud_khz--设置CAN总线波特率
    658           *      |__设置波特率的值，单位Khz
    659           *
    660           * 输出:
    661           *    0--配置错误
    662           *    1--配置成功
    663           *
    664           */

   \                                 In section .text, align 2, keep-with-next
    665          static uint8 LPLD_CAN_SetBaud(CANx canx, uint32 baud_khz)
    666          {    
    667            CAN_MemMapPtr canptr = CANx_Ptr[canx];
   \                     LPLD_CAN_SetBaud:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R2,??DataTable12
   \   00000004   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
    668            
    669            switch (baud_khz)
   \   00000008   0x2921             CMP      R1,#+33
   \   0000000A   0xD010             BEQ.N    ??LPLD_CAN_SetBaud_0
   \   0000000C   0x2932             CMP      R1,#+50
   \   0000000E   0xD021             BEQ.N    ??LPLD_CAN_SetBaud_1
   \   00000010   0x2953             CMP      R1,#+83
   \   00000012   0xD016             BEQ.N    ??LPLD_CAN_SetBaud_2
   \   00000014   0x2964             CMP      R1,#+100
   \   00000016   0xD026             BEQ.N    ??LPLD_CAN_SetBaud_3
   \   00000018   0x297D             CMP      R1,#+125
   \   0000001A   0xD02D             BEQ.N    ??LPLD_CAN_SetBaud_4
   \   0000001C   0x29FA             CMP      R1,#+250
   \   0000001E   0xD034             BEQ.N    ??LPLD_CAN_SetBaud_5
   \   00000020   0xF5B1 0x7FFA      CMP      R1,#+500
   \   00000024   0xD03A             BEQ.N    ??LPLD_CAN_SetBaud_6
   \   00000026   0xF5B1 0x7F7A      CMP      R1,#+1000
   \   0000002A   0xD040             BEQ.N    ??LPLD_CAN_SetBaud_7
   \   0000002C   0xE048             B.N      ??LPLD_CAN_SetBaud_8
    670            {
    671              case (33):	// 33.33K
    672                if(CAN_CTRL1_REG(canptr) & CAN_CTRL1_CLKSRC_MASK)
   \                     ??LPLD_CAN_SetBaud_0:
   \   0000002E   0x6841             LDR      R1,[R0, #+4]
   \   00000030   0x0489             LSLS     R1,R1,#+18
   \   00000032   0xD502             BPL.N    ??LPLD_CAN_SetBaud_9
    673                { 
    674                   // 48M/120= 400k sclock, 12Tq
    675                   // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    676                   // RJW = 3, PSEG1 = 4, PSEG2 = 4,PRESDIV = 120
    677                  CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2) 
    678                                                    | CAN_CTRL1_RJW(2)
    679                                                    | CAN_CTRL1_PSEG1(3) 
    680                                                    | CAN_CTRL1_PSEG2(3)
    681                                                    | CAN_CTRL1_PRESDIV(119));
   \   00000034   0x....             LDR.N    R1,??DataTable12_10  ;; 0x779b0002
   \   00000036   0x6041             STR      R1,[R0, #+4]
   \   00000038   0xE001             B.N      ??LPLD_CAN_SetBaud_10
    682                }
    683                else
    684                { 
    685                   // 12M/20= 600k sclock, 18Tq
    686                   // PROPSEG = 1, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    687                   // RJW = 4, PSEG1 = 8, PSEG2 = 8,PRESDIV = 20
    688                  CAN_CTRL1_REG(canptr) = (0  | CAN_CTRL1_PROPSEG(0) 
    689                                                    | CAN_CTRL1_PROPSEG(3)
    690                                                    | CAN_CTRL1_PSEG1(7) 
    691                                                    | CAN_CTRL1_PSEG2(7)
    692                                                    | CAN_CTRL1_PRESDIV(19));
   \                     ??LPLD_CAN_SetBaud_9:
   \   0000003A   0x....             LDR.N    R1,??DataTable12_11  ;; 0x133f0003
   \   0000003C   0x6041             STR      R1,[R0, #+4]
    693                }
    694              break;
    695            case (83):	// 83.33K
    696              if(CAN_CTRL1_REG(canptr) & CAN_CTRL1_CLKSRC_MASK)
    697              {
    698               // 48M/48= 1M sclock, 12Tq
    699               // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    700               // RJW = 3, PSEG1 = 4, PSEG2 = 4,PRESDIV = 48
    701                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2) 
    702                                                | CAN_CTRL1_RJW(2)
    703                                                | CAN_CTRL1_PSEG1(3)
    704                                                | CAN_CTRL1_PSEG2(3)
    705                                                | CAN_CTRL1_PRESDIV(47));
    706              }
    707              else
    708              { 
    709               // 12M/12= 1M sclock, 12Tq
    710               // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    711               // RJW = 3, PSEG1 = 4, PSEG2 = 4,PRESDIV = 12
    712                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2) 
    713                                                | CAN_CTRL1_RJW(2)
    714                                                | CAN_CTRL1_PSEG1(3) 
    715                                                | CAN_CTRL1_PSEG2(3)
    716                                                | CAN_CTRL1_PRESDIV(11));
    717              }
    718              break;
    719            case (50):
    720              if(CAN_CTRL1_REG(canptr) & CAN_CTRL1_CLKSRC_MASK)
    721              {                
    722               // 48M/80= 0.6M sclock, 12Tq
    723               // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    724               // RJW = 3, PSEG1 = 4, PSEG2 = 4, PRESDIV = 40
    725                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2) 
    726                                                | CAN_CTRL1_RJW(1)
    727                                                | CAN_CTRL1_PSEG1(3) 
    728                                                | CAN_CTRL1_PSEG2(3)
    729                                                | CAN_CTRL1_PRESDIV(79));
    730              }
    731              else
    732              {
    733               // 12M/20= 0.6M sclock, 12Tq
    734               // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    735               // RJW = 3, PSEG1 = 4, PSEG2 = 4, PRESDIV = 20                 
    736                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2)
    737                                                | CAN_CTRL1_RJW(2)
    738                                                | CAN_CTRL1_PSEG1(3) 
    739                                                | CAN_CTRL1_PSEG2(3)
    740                                                | CAN_CTRL1_PRESDIV(19));                   
    741              }
    742              break;
    743            case (100):
    744              if(CAN_CTRL1_REG(canptr) & CAN_CTRL1_CLKSRC_MASK)
    745              { 
    746               // 48M/40= 1.2M sclock, 12Tq
    747               // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    748               // RJW = 3, PSEG1 = 4, PSEG2 = 4, PRESDIV = 40
    749                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2)
    750                                                | CAN_CTRL1_RJW(2)
    751                                                | CAN_CTRL1_PSEG1(3) 
    752                                                | CAN_CTRL1_PSEG2(3)
    753                                                | CAN_CTRL1_PRESDIV(39));
    754              }
    755              else
    756              {
    757               // 12M/10= 1.2M sclock, 12Tq
    758               // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    759               // RJW = 3, PSEG1 = 4, PSEG2 = 4, PRESDIV = 10
    760                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2) 
    761                                                | CAN_CTRL1_RJW(2)
    762                                                | CAN_CTRL1_PSEG1(3) 
    763                                                | CAN_CTRL1_PSEG2(3)
    764                                                | CAN_CTRL1_PRESDIV(9));                   
    765              }
    766              break;
    767            case (125):
    768              if(CAN_CTRL1_REG(canptr) & CAN_CTRL1_CLKSRC_MASK)
    769              {                 
    770               // 48M/32= 1.5M sclock, 12Tq
    771               // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    772               // RJW = 3, PSEG1 = 4, PSEG2 = 4, PRESDIV = 32
    773                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2) 
    774                                                | CAN_CTRL1_RJW(2)
    775                                                | CAN_CTRL1_PSEG1(3) 
    776                                                | CAN_CTRL1_PSEG2(3)
    777                                                | CAN_CTRL1_PRESDIV(31));
    778              }
    779              else
    780              {
    781               // 12M/8= 1.5M sclock, 12Tq
    782               // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    783               // RJW = 3, PSEG1 = 4, PSEG2 = 4, PRESDIV = 8
    784                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2) 
    785                                                | CAN_CTRL1_RJW(2)
    786                                                | CAN_CTRL1_PSEG1(3) 
    787                                                | CAN_CTRL1_PSEG2(3)
    788                                                | CAN_CTRL1_PRESDIV(7));                  
    789              }
    790              break;
    791            case (250):
    792              if(CAN_CTRL1_REG(canptr) & CAN_CTRL1_CLKSRC_MASK)
    793              {                
    794               // 48M/16= 3M sclock, 12Tq
    795               // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    796               // RJW = 2, PSEG1 = 4, PSEG2 = 4, PRESDIV = 16
    797                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2)
    798                                                | CAN_CTRL1_RJW(1)
    799                                                | CAN_CTRL1_PSEG1(3) 
    800                                                | CAN_CTRL1_PSEG2(3)
    801                                                | CAN_CTRL1_PRESDIV(15));
    802              }
    803              else
    804              {
    805               // 12M/4= 3M sclock, 12Tq
    806               // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    807               // RJW = 2, PSEG1 = 4, PSEG2 = 4, PRESDIV = 4
    808                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2) 
    809                                                | CAN_CTRL1_RJW(1)
    810                                                | CAN_CTRL1_PSEG1(3)
    811                                                | CAN_CTRL1_PSEG2(3)
    812                                                | CAN_CTRL1_PRESDIV(3));                   
    813              }
    814              break;
    815            case (500):
    816              if(CAN_CTRL1_REG(canptr) & CAN_CTRL1_CLKSRC_MASK)
    817              {                
    818               // 48M/8=6M sclock, 12Tq
    819               // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    820               // RJW = 2, PSEG1 = 4, PSEG2 = 4, PRESDIV = 6
    821                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2) 
    822                                                | CAN_CTRL1_RJW(1)
    823                                                | CAN_CTRL1_PSEG1(3) 
    824                                                | CAN_CTRL1_PSEG2(3)
    825                                                | CAN_CTRL1_PRESDIV(7));
    826              }
    827              else
    828              {
    829               // 12M/2=6M sclock, 12Tq
    830               // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    831               // RJW = 2, PSEG1 = 4, PSEG2 = 4, PRESDIV = 2
    832                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2) 
    833                                                | CAN_CTRL1_RJW(1)
    834                                                | CAN_CTRL1_PSEG1(3) 
    835                                                | CAN_CTRL1_PSEG2(3)
    836                                                | CAN_CTRL1_PRESDIV(1));                   
    837              }
    838              break;
    839            case (1000): 
    840              if(CAN_CTRL1_REG(canptr) & CAN_CTRL1_CLKSRC_MASK)
    841              {                  
    842               // 48M/6=8M sclock
    843               // PROPSEG = 4, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    844               // RJW = 1, PSEG1 = 1, PSEG2 = 2, PRESCALER = 6
    845                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(3) 
    846                                                | CAN_CTRL1_RJW(0)
    847                                                | CAN_CTRL1_PSEG1(0)
    848                                                | CAN_CTRL1_PSEG2(1)
    849                                                | CAN_CTRL1_PRESDIV(5));
    850              }
    851              else
    852              {  
    853               // 12M/1=12M sclock,12Tq
    854               // PROPSEG = 3, LOM = 0x0, LBUF = 0x0, TSYNC = 0x0, SAMP = 1
    855               // RJW = 4, PSEG1 = 4, PSEG2 = 4, PRESCALER = 1
    856                CAN_CTRL1_REG(canptr) = (0 | CAN_CTRL1_PROPSEG(2) 
    857                                                | CAN_CTRL1_RJW(3)
    858                                                | CAN_CTRL1_PSEG1(3) 
    859                                                | CAN_CTRL1_PSEG2(3)
    860                                                | CAN_CTRL1_PRESDIV(0));
    861              }
    862              break;
    863            default: 
    864              return 0;
    865            }
    866            return 1;
   \                     ??LPLD_CAN_SetBaud_10:
   \                     ??LPLD_CAN_SetBaud_11:
   \   0000003E   0x2001             MOVS     R0,#+1
   \                     ??LPLD_CAN_SetBaud_12:
   \   00000040   0x4770             BX       LR               ;; return
   \                     ??LPLD_CAN_SetBaud_2:
   \   00000042   0x6841             LDR      R1,[R0, #+4]
   \   00000044   0x0489             LSLS     R1,R1,#+18
   \   00000046   0xD502             BPL.N    ??LPLD_CAN_SetBaud_13
   \   00000048   0x....             LDR.N    R1,??DataTable12_12  ;; 0x2f9b0002
   \   0000004A   0x6041             STR      R1,[R0, #+4]
   \   0000004C   0xE001             B.N      ??LPLD_CAN_SetBaud_14
   \                     ??LPLD_CAN_SetBaud_13:
   \   0000004E   0x....             LDR.N    R1,??DataTable12_13  ;; 0xb9b0002
   \   00000050   0x6041             STR      R1,[R0, #+4]
   \                     ??LPLD_CAN_SetBaud_14:
   \   00000052   0xE7F4             B.N      ??LPLD_CAN_SetBaud_11
   \                     ??LPLD_CAN_SetBaud_1:
   \   00000054   0x6841             LDR      R1,[R0, #+4]
   \   00000056   0x0489             LSLS     R1,R1,#+18
   \   00000058   0xD502             BPL.N    ??LPLD_CAN_SetBaud_15
   \   0000005A   0x....             LDR.N    R1,??DataTable12_14  ;; 0x4f5b0002
   \   0000005C   0x6041             STR      R1,[R0, #+4]
   \   0000005E   0xE001             B.N      ??LPLD_CAN_SetBaud_16
   \                     ??LPLD_CAN_SetBaud_15:
   \   00000060   0x....             LDR.N    R1,??DataTable12_15  ;; 0x139b0002
   \   00000062   0x6041             STR      R1,[R0, #+4]
   \                     ??LPLD_CAN_SetBaud_16:
   \   00000064   0xE7EB             B.N      ??LPLD_CAN_SetBaud_11
   \                     ??LPLD_CAN_SetBaud_3:
   \   00000066   0x6841             LDR      R1,[R0, #+4]
   \   00000068   0x0489             LSLS     R1,R1,#+18
   \   0000006A   0xD502             BPL.N    ??LPLD_CAN_SetBaud_17
   \   0000006C   0x....             LDR.N    R1,??DataTable12_16  ;; 0x279b0002
   \   0000006E   0x6041             STR      R1,[R0, #+4]
   \   00000070   0xE001             B.N      ??LPLD_CAN_SetBaud_18
   \                     ??LPLD_CAN_SetBaud_17:
   \   00000072   0x....             LDR.N    R1,??DataTable12_17  ;; 0x99b0002
   \   00000074   0x6041             STR      R1,[R0, #+4]
   \                     ??LPLD_CAN_SetBaud_18:
   \   00000076   0xE7E2             B.N      ??LPLD_CAN_SetBaud_11
   \                     ??LPLD_CAN_SetBaud_4:
   \   00000078   0x6841             LDR      R1,[R0, #+4]
   \   0000007A   0x0489             LSLS     R1,R1,#+18
   \   0000007C   0xD502             BPL.N    ??LPLD_CAN_SetBaud_19
   \   0000007E   0x....             LDR.N    R1,??DataTable12_18  ;; 0x1f9b0002
   \   00000080   0x6041             STR      R1,[R0, #+4]
   \   00000082   0xE001             B.N      ??LPLD_CAN_SetBaud_20
   \                     ??LPLD_CAN_SetBaud_19:
   \   00000084   0x....             LDR.N    R1,??DataTable12_19  ;; 0x79b0002
   \   00000086   0x6041             STR      R1,[R0, #+4]
   \                     ??LPLD_CAN_SetBaud_20:
   \   00000088   0xE7D9             B.N      ??LPLD_CAN_SetBaud_11
   \                     ??LPLD_CAN_SetBaud_5:
   \   0000008A   0x6841             LDR      R1,[R0, #+4]
   \   0000008C   0x0489             LSLS     R1,R1,#+18
   \   0000008E   0xD502             BPL.N    ??LPLD_CAN_SetBaud_21
   \   00000090   0x....             LDR.N    R1,??DataTable12_20  ;; 0xf5b0002
   \   00000092   0x6041             STR      R1,[R0, #+4]
   \   00000094   0xE001             B.N      ??LPLD_CAN_SetBaud_22
   \                     ??LPLD_CAN_SetBaud_21:
   \   00000096   0x....             LDR.N    R1,??DataTable12_21  ;; 0x35b0002
   \   00000098   0x6041             STR      R1,[R0, #+4]
   \                     ??LPLD_CAN_SetBaud_22:
   \   0000009A   0xE7D0             B.N      ??LPLD_CAN_SetBaud_11
   \                     ??LPLD_CAN_SetBaud_6:
   \   0000009C   0x6841             LDR      R1,[R0, #+4]
   \   0000009E   0x0489             LSLS     R1,R1,#+18
   \   000000A0   0xD502             BPL.N    ??LPLD_CAN_SetBaud_23
   \   000000A2   0x....             LDR.N    R1,??DataTable12_22  ;; 0x75b0002
   \   000000A4   0x6041             STR      R1,[R0, #+4]
   \   000000A6   0xE001             B.N      ??LPLD_CAN_SetBaud_24
   \                     ??LPLD_CAN_SetBaud_23:
   \   000000A8   0x....             LDR.N    R1,??DataTable12_23  ;; 0x15b0002
   \   000000AA   0x6041             STR      R1,[R0, #+4]
   \                     ??LPLD_CAN_SetBaud_24:
   \   000000AC   0xE7C7             B.N      ??LPLD_CAN_SetBaud_11
   \                     ??LPLD_CAN_SetBaud_7:
   \   000000AE   0x6841             LDR      R1,[R0, #+4]
   \   000000B0   0x0489             LSLS     R1,R1,#+18
   \   000000B2   0xD502             BPL.N    ??LPLD_CAN_SetBaud_25
   \   000000B4   0x....             LDR.N    R1,??DataTable12_24  ;; 0x5010003
   \   000000B6   0x6041             STR      R1,[R0, #+4]
   \   000000B8   0xE001             B.N      ??LPLD_CAN_SetBaud_26
   \                     ??LPLD_CAN_SetBaud_25:
   \   000000BA   0x....             LDR.N    R1,??DataTable12_25  ;; 0xdb0002
   \   000000BC   0x6041             STR      R1,[R0, #+4]
   \                     ??LPLD_CAN_SetBaud_26:
   \   000000BE   0xE7BE             B.N      ??LPLD_CAN_SetBaud_11
   \                     ??LPLD_CAN_SetBaud_8:
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE7BD             B.N      ??LPLD_CAN_SetBaud_12
    867          }
    868          
    869          /*
    870           * LPLD_CAN_Isr
    871           * CAN通用中断底层入口函数
    872           * 
    873           * 用户无需修改，程序自动进入对应通道中断函数
    874           */
    875          

   \                                 In section .text, align 2, keep-with-next
    876          void LPLD_CAN_Isr(void)
    877          {
   \                     LPLD_CAN_Isr:
   \   00000000   0xB580             PUSH     {R7,LR}
    878            #define CAN_VECTORNUM   (*(volatile uint8*)(0xE000ED04))
    879            uint8 can_active_int = CAN_VECTORNUM - 45;
   \   00000002   0x....             LDR.N    R0,??DataTable12_26  ;; 0xe000ed04
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x382D             SUBS     R0,R0,#+45
    880            CAN_ISR[can_active_int]();
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x....             LDR.N    R1,??DataTable12_9
   \   0000000C   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000010   0x4780             BLX      R0
    881          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     CANx_Ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x40065000         DC32     0x40065000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x40049030         DC32     0x40049030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x40049034         DC32     0x40049034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x4004D060         DC32     0x4004d060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x4004D064         DC32     0x4004d064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\robot _init\\\\robot\\\\...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x........         DC32     CAN_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x779B0002         DC32     0x779b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   0x133F0003         DC32     0x133f0003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   0x2F9B0002         DC32     0x2f9b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \   00000000   0x0B9B0002         DC32     0xb9b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \   00000000   0x4F5B0002         DC32     0x4f5b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \   00000000   0x139B0002         DC32     0x139b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \   00000000   0x279B0002         DC32     0x279b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \   00000000   0x099B0002         DC32     0x99b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_18:
   \   00000000   0x1F9B0002         DC32     0x1f9b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_19:
   \   00000000   0x079B0002         DC32     0x79b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_20:
   \   00000000   0x0F5B0002         DC32     0xf5b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_21:
   \   00000000   0x035B0002         DC32     0x35b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_22:
   \   00000000   0x075B0002         DC32     0x75b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_23:
   \   00000000   0x015B0002         DC32     0x15b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_24:
   \   00000000   0x05010003         DC32     0x5010003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_25:
   \   00000000   0x00DB0002         DC32     0xdb0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_26:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\robot _init\\\\robot\\\\...">`:
   \   00000000   0x46 0x3A          DC8 "F:\\robot _init\\robot\\lib\\LPLD\\HAL_CAN.c"
   \              0x5C 0x72    
   \              0x6F 0x62    
   \              0x6F 0x74    
   \              0x20 0x5F    
   \              0x69 0x6E    
   \              0x69 0x74    
   \              0x5C 0x72    
   \              0x6F 0x62    
   \              0x6F 0x74    
   \              0x5C 0x6C    
   \              0x69 0x62    
   \              0x5C 0x4C    
   \              0x50 0x4C    
   \              0x44 0x5C    
   \              0x48 0x41    
   \              0x4C 0x5F    
   \              0x43 0x41    
   \              0x4E 0x2E    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  LPLD_CAN_ClearAllFlag
        0  LPLD_CAN_ClearFlag
        0  LPLD_CAN_Disable_Interrupt
        0  LPLD_CAN_Enable_Interrupt
        8  LPLD_CAN_Enable_RX_Buf
        0  LPLD_CAN_GetFlag
       16  LPLD_CAN_Init
             16 -> LPLD_CAN_ClearAllFlag
             16 -> LPLD_CAN_Enable_Interrupt
             16 -> LPLD_CAN_Enable_RX_Buf
             16 -> LPLD_CAN_SetBaud
        8  LPLD_CAN_Isr
              8 -- Indirect call
       24  LPLD_CAN_RecvData
             24 -> LPLD_CAN_Unlock_MBx
       32  LPLD_CAN_SendData
        0  LPLD_CAN_SetBaud
       16  LPLD_CAN_SetIsr
             16 -> assert_failed
             16 -> enable_irq
        0  LPLD_CAN_Unlock_MBx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      40  ?<Constant "F:\\robot _init\\robot\\...">
       8  ?<Constant {0L}>
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_21
       4  ??DataTable12_22
       4  ??DataTable12_23
       4  ??DataTable12_24
       4  ??DataTable12_25
       4  ??DataTable12_26
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      64  CAN_ISR
      20  CANx_Ptr
      22  LPLD_CAN_ClearAllFlag
      18  LPLD_CAN_ClearFlag
      20  LPLD_CAN_Disable_Interrupt
      22  LPLD_CAN_Enable_Interrupt
      76  LPLD_CAN_Enable_RX_Buf
      20  LPLD_CAN_GetFlag
     826  LPLD_CAN_Init
      20  LPLD_CAN_Isr
     310  LPLD_CAN_RecvData
     362  LPLD_CAN_SendData
     196  LPLD_CAN_SetBaud
      76  LPLD_CAN_SetIsr
      14  LPLD_CAN_Unlock_MBx

 
    64 bytes in section .bss
    20 bytes in section .data
    48 bytes in section .rodata
 2 090 bytes in section .text
 
 2 090 bytes of CODE  memory
    48 bytes of CONST memory
    84 bytes of DATA  memory

Errors: none
Warnings: none
