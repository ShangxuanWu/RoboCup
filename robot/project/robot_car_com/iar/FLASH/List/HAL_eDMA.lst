###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     06/Jul/2014  14:14:00 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\robot _init\robot\lib\LPLD\HAL_eDMA.c                 #
#    Command line =  "F:\robot _init\robot\lib\LPLD\HAL_eDMA.c" -D IAR -D     #
#                    LPLD_K60 -lCN "F:\robot _init\robot\project\robot_car_co #
#                    m\iar\FLASH\List\" -lB "F:\robot                         #
#                    _init\robot\project\robot_car_com\iar\FLASH\List\" -o    #
#                    "F:\robot _init\robot\project\robot_car_com\iar\FLASH\Ob #
#                    j\" --no_cse --no_unroll --no_inline --no_code_motion    #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M4 -e --fpu=None            #
#                    --dlib_config "D:\IAR Systems\Embedded Workbench         #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I "F:\robot         #
#                    _init\robot\project\robot_car_com\iar\..\app\" -I        #
#                    "F:\robot _init\robot\project\robot_car_com\iar\..\..\.. #
#                    \lib\common\" -I "F:\robot _init\robot\project\robot_car #
#                    _com\iar\..\..\..\lib\cpu\" -I "F:\robot                 #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\cpu\h #
#                    eaders\" -I "F:\robot _init\robot\project\robot_car_com\ #
#                    iar\..\..\..\lib\drivers\adc16\" -I "F:\robot            #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\enet\" -I "F:\robot _init\robot\project\robot_car_com #
#                    \iar\..\..\..\lib\drivers\lptmr\" -I "F:\robot           #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\mcg\" -I "F:\robot _init\robot\project\robot_car_com\ #
#                    iar\..\..\..\lib\drivers\pmc\" -I "F:\robot              #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\rtc\" -I "F:\robot _init\robot\project\robot_car_com\ #
#                    iar\..\..\..\lib\drivers\uart\" -I "F:\robot             #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\wdog\" -I "F:\robot _init\robot\project\robot_car_com #
#                    \iar\..\..\..\lib\platforms\" -I "F:\robot               #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\LPLD\ #
#                    " -I "F:\robot _init\robot\project\robot_car_com\iar\..\ #
#                    ..\..\lib\LPLD\FatFs\" -I "F:\robot                      #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\LPLD\ #
#                    USB\" -I "F:\robot _init\robot\project\robot_car_com\iar #
#                    \..\..\..\lib\iar_config_files\" -Ol                     #
#    List file    =  F:\robot _init\robot\project\robot_car_com\iar\FLASH\Lis #
#                    t\HAL_eDMA.lst                                           #
#    Object file  =  F:\robot _init\robot\project\robot_car_com\iar\FLASH\Obj #
#                    \HAL_eDMA.o                                              #
#                                                                             #
#                                                                             #
###############################################################################

F:\robot _init\robot\lib\LPLD\HAL_eDMA.c
      1          /*
      2           * --------------"拉普兰德K60底层库"-----------------
      3           *
      4           * 测试硬件平台:LPLD_K60 Card
      5           * 版权所有:北京拉普兰德电子技术有限公司
      6           * 网络销售:http://laplenden.taobao.com
      7           * 公司门户:http://www.lpld.cn
      8           *
      9           * 文件名: HAL_eDAM.c
     10           * 用途: eDMA底层模块相关函数
     11           * 最后修改日期: 20120321
     12           *
     13           * 开发者使用协议:
     14           *  本代码面向所有使用者开放源代码，开发者可以随意修改源代码。但本段及以上注释应
     15           *  予以保留，不得更改或删除原版权所有者姓名。二次开发者可以加注二次版权所有者，
     16           *  但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     17          */
     18          /*
     19           *******需用到DMA中断，请在isr.h中粘贴一下代码:*********
     20          
     21          //DMA模块中断服务定义
     22          #undef  VECTOR_016
     23          #define VECTOR_016 LPLD_DMA_Isr
     24          #undef  VECTOR_017
     25          #define VECTOR_017 LPLD_DMA_Isr
     26          #undef  VECTOR_018
     27          #define VECTOR_018 LPLD_DMA_Isr
     28          #undef  VECTOR_019
     29          #define VECTOR_019 LPLD_DMA_Isr
     30          #undef  VECTOR_020
     31          #define VECTOR_020 LPLD_DMA_Isr
     32          #undef  VECTOR_021
     33          #define VECTOR_021 LPLD_DMA_Isr
     34          #undef  VECTOR_022
     35          #define VECTOR_022 LPLD_DMA_Isr
     36          #undef  VECTOR_023
     37          #define VECTOR_023 LPLD_DMA_Isr
     38          #undef  VECTOR_024
     39          #define VECTOR_024 LPLD_DMA_Isr
     40          #undef  VECTOR_025
     41          #define VECTOR_025 LPLD_DMA_Isr
     42          #undef  VECTOR_026
     43          #define VECTOR_026 LPLD_DMA_Isr
     44          #undef  VECTOR_027
     45          #define VECTOR_027 LPLD_DMA_Isr
     46          #undef  VECTOR_028
     47          #define VECTOR_028 LPLD_DMA_Isr
     48          #undef  VECTOR_029
     49          #define VECTOR_029 LPLD_DMA_Isr
     50          #undef  VECTOR_030
     51          #define VECTOR_030 LPLD_DMA_Isr
     52          #undef  VECTOR_031
     53          #define VECTOR_031 LPLD_DMA_Isr
     54          #undef  VECTOR_032
     55          #define VECTOR_032 LPLD_DMA_Isr
     56          //以下函数在LPLD_Kinetis底层包，不必修改
     57          extern void LPLD_DMA_Isr(void);
     58          
     59           ***********************代码结束*************************
     60          */
     61          
     62          #include "common.h"
     63          #include "HAL_eDMA.h"
     64          
     65          //内部函数
     66          static uint8 LPLD_eDMA_Config(LPLD_eDMA_Cfg_t*);
     67          

   \                                 In section .bss, align 4
     68          DMA_ISR_CALLBACK DMA_ISR[16];
   \                     DMA_ISR:
   \   00000000                      DS8 64
     69          
     70          /*
     71           * LPLD_DMA_Init
     72           * DMA模块通用初始化函数--用于源地址到目的地址之间的数据直接传输（不用通过CPU）
     73           * 详细参数在LPLD_eDMA_Cfg_t 结构体中定义（在HAL_eDMA.h）头文件中定义
     74           */

   \                                 In section .text, align 2, keep-with-next
     75          uint8 LPLD_DMA_Init(LPLD_eDMA_Cfg_t *DMA_Config)
     76          { 
   \                     LPLD_DMA_Init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     77              //如果用户没有设置 每一次传输字节的个数 默认为每次传输一个字节
     78              if(DMA_Config->Trans_bytesNum  == NULL)
   \   00000004   0x6860             LDR      R0,[R4, #+4]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE.N    ??LPLD_DMA_Init_0
     79              {
     80                 DMA_Config->Trans_bytesNum =1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x6060             STR      R0,[R4, #+4]
     81              }
     82              
     83              //如果用户没有设置 源地址增加 默认为执行一次DMA请求后源地址不增加
     84              if(DMA_Config->Source_Addr_inc == NULL)
   \                     ??LPLD_DMA_Init_0:
   \   0000000E   0x7B60             LDRB     R0,[R4, #+13]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE.N    ??LPLD_DMA_Init_1
     85              {
     86                 DMA_Config->Source_Addr_inc  =ADDR_HOLD;       //源地址不增加
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x7360             STRB     R0,[R4, #+13]
     87              }
     88              //如果用户没有设置 源数据长度 默认为8位数据长度
     89              if(DMA_Config->Source_Size ==NULL)
   \                     ??LPLD_DMA_Init_1:
   \   00000018   0x7B20             LDRB     R0,[R4, #+12]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD101             BNE.N    ??LPLD_DMA_Init_2
     90              {
     91                 DMA_Config->Source_Size       =DMA_SRC_8BIT;    //源数据宽度8bit 一个字节
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x7320             STRB     R0,[R4, #+12]
     92              } 
     93              //如果用户没有设置 主循环计数器完成以后 源地址是否调整 默认为设置为源地址不调整
     94              if(DMA_Config->Source_Adj_Addr ==NULL)
   \                     ??LPLD_DMA_Init_2:
   \   00000022   0x6920             LDR      R0,[R4, #+16]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD101             BNE.N    ??LPLD_DMA_Init_3
     95              {
     96                  DMA_Config->Source_Adj_Addr  =0;    
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6120             STR      R0,[R4, #+16]
     97              }
     98              
     99              //如果用户没有设置 目的地址增加 默认为执行一次DMA请求后目的地址加一
    100              if(DMA_Config->Dest_Addr_inc ==NULL)
   \                     ??LPLD_DMA_Init_3:
   \   0000002C   0x7E60             LDRB     R0,[R4, #+25]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD101             BNE.N    ??LPLD_DMA_Init_4
    101              {
    102                  DMA_Config->Dest_Addr_inc     =ADDR_INCREASE;    //针对目的地址的操作执行完毕后加1
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7660             STRB     R0,[R4, #+25]
    103              } 
    104              //如果用户没有设置 源数据长度 默认为8位数据长度
    105              if(DMA_Config->Dest_Size ==NULL)
   \                     ??LPLD_DMA_Init_4:
   \   00000036   0x7E20             LDRB     R0,[R4, #+24]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD101             BNE.N    ??LPLD_DMA_Init_5
    106              {
    107                  DMA_Config->Dest_Size         =DMA_DST_8BIT;     //目的数据宽度8bit 一个字节
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x7620             STRB     R0,[R4, #+24]
    108              } 
    109              //如果用户没有设置 主循环计数器完成以后 目的地址是否调整 默认为设置为目的地址不调整
    110              if(DMA_Config->Dest_Adj_Addr ==NULL)
   \                     ??LPLD_DMA_Init_5:
   \   00000040   0x69E0             LDR      R0,[R4, #+28]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD101             BNE.N    ??LPLD_DMA_Init_6
    111              {
    112                  DMA_Config->Dest_Adj_Addr     =0;    
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x61E0             STR      R0,[R4, #+28]
    113              }
    114              //如果用户没有设置 中断模式 默认关闭中断
    115              if(DMA_Config->Dma_irqc ==NULL)
   \                     ??LPLD_DMA_Init_6:
   \   0000004A   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD102             BNE.N    ??LPLD_DMA_Init_7
    116              {
    117                 DMA_Config->Dma_irqc          =0;                //关闭中断
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF884 0x0020      STRB     R0,[R4, #+32]
    118              }
    119              //如果用户没有设置 DMA自动关闭方式 默认开启主循环计数器减为0自动关闭DMA功能
    120              if(DMA_Config->Dma_AutoClose ==NULL)
   \                     ??LPLD_DMA_Init_7:
   \   00000058   0xF894 0x0021      LDRB     R0,[R4, #+33]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD102             BNE.N    ??LPLD_DMA_Init_8
    121              {
    122                 DMA_Config->Dma_AutoClose     =0;                //开启主循环计数器减为0自动关闭DMA功能
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF884 0x0021      STRB     R0,[R4, #+33]
    123              } 
    124              
    125              if(DMA_Config->isr_func!=NULL)
   \                     ??LPLD_DMA_Init_8:
   \   00000066   0x6A60             LDR      R0,[R4, #+36]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD007             BEQ.N    ??LPLD_DMA_Init_9
    126              {
    127                  DMA_ISR[DMA_Config->Channelx] = DMA_Config->isr_func;
   \   0000006C   0x7820             LDRB     R0,[R4, #+0]
   \   0000006E   0x....             LDR.N    R1,??DataTable3
   \   00000070   0x6A62             LDR      R2,[R4, #+36]
   \   00000072   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    128                  //在NVIC中使能DMA中断
    129                  enable_irq(DMA_Config->Channelx); 
   \   00000076   0x7820             LDRB     R0,[R4, #+0]
   \   00000078   0x.... 0x....      BL       enable_irq
    130              }
    131              //配置DMA寄存器
    132              return LPLD_eDMA_Config(DMA_Config);
   \                     ??LPLD_DMA_Init_9:
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       LPLD_eDMA_Config
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
    133          }
    134          
    135          
    136          /*
    137           * 内部函数，用户无需调用
    138           * LPLD_eDMA_Config
    139           * 配置eDMA寄存器函数
    140           *
    141           * 参数 LPLD_eDMA_Cfg_t *eDMA_Config
    142           * 详细参数在LPLD_eDMA_Cfg 结构体中定义
    143           * LPLD_eDMA_Cfg_t 结构体在（在HAL_eDMA.h）头文件中定义
    144           *
    145           * 输出：
    146           *   0 配置失败
    147           *   1 配置成功
    148          */

   \                                 In section .text, align 2, keep-with-next
    149          static uint8 LPLD_eDMA_Config(LPLD_eDMA_Cfg_t *DMA_Config)
    150          {
    151              //=====配置eDMA模块时钟===========
    152              SIM_SCGC6|=SIM_SCGC6_DMAMUX_MASK; //打开DMA通道多路复用器时钟
   \                     LPLD_eDMA_Config:
   \   00000000   0x....             LDR.N    R1,??DataTable3_1  ;; 0x4004803c
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000008   0x....             LDR.N    R2,??DataTable3_1  ;; 0x4004803c
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    153                  
    154              SIM_SCGC7|=SIM_SCGC7_DMA_MASK;    //打开DMA模块时钟
   \   0000000C   0x....             LDR.N    R1,??DataTable3_2  ;; 0x40048040
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000014   0x....             LDR.N    R2,??DataTable3_2  ;; 0x40048040
   \   00000016   0x6011             STR      R1,[R2, #+0]
    155              //================================
    156              if(DMA_Config->Channelx>15) 
   \   00000018   0x7801             LDRB     R1,[R0, #+0]
   \   0000001A   0x2910             CMP      R1,#+16
   \   0000001C   0xD301             BCC.N    ??LPLD_eDMA_Config_0
    157              {
    158                  return 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE105             B.N      ??LPLD_eDMA_Config_1
    159              }
    160              else
    161              {
    162                  //选择 通道x 配置外设的DMA source requestNumber
    163                  DMAMUX_BASE_PTR->CHCFG[DMA_Config->Channelx]=DMAMUX_CHCFG_SOURCE(DMA_Config->Peri_DmaReq);
   \                     ??LPLD_eDMA_Config_0:
   \   00000022   0x7801             LDRB     R1,[R0, #+0]
   \   00000024   0x....             LDR.N    R2,??DataTable3_3  ;; 0x40021000
   \   00000026   0x7843             LDRB     R3,[R0, #+1]
   \   00000028   0xF013 0x033F      ANDS     R3,R3,#0x3F
   \   0000002C   0x548B             STRB     R3,[R1, R2]
    164              }
    165              /*设置源地址信息*/
    166              //设置源地址   
    167              DMA_BASE_PTR->TCD[DMA_Config->Channelx].SADDR=DMA_Config->Source_Addr;
   \   0000002E   0x7801             LDRB     R1,[R0, #+0]
   \   00000030   0x0149             LSLS     R1,R1,#+5
   \   00000032   0x....             LDR.N    R2,??DataTable3_4  ;; 0x40009000
   \   00000034   0x6883             LDR      R3,[R0, #+8]
   \   00000036   0x508B             STR      R3,[R1, R2]
    168              //在执行完针对源地址的操作之后，是否在原地址的基础上累加
    169              DMA_BASE_PTR->TCD[DMA_Config->Channelx].SOFF =DMA_Config->Source_Addr_inc;
   \   00000038   0x7801             LDRB     R1,[R0, #+0]
   \   0000003A   0x0149             LSLS     R1,R1,#+5
   \   0000003C   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000040   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000044   0x7B42             LDRB     R2,[R0, #+13]
   \   00000046   0x808A             STRH     R2,[R1, #+4]
    170              //先清零数据长度寄存器
    171              DMA_BASE_PTR->TCD[DMA_Config->Channelx].ATTR=0;
   \   00000048   0x7801             LDRB     R1,[R0, #+0]
   \   0000004A   0x0149             LSLS     R1,R1,#+5
   \   0000004C   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000050   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x80CA             STRH     R2,[R1, #+6]
    172              //设置源地址的传输宽度
    173              DMA_BASE_PTR->TCD[DMA_Config->Channelx].ATTR |=DMA_Config->Source_Size;
   \   00000058   0x7801             LDRB     R1,[R0, #+0]
   \   0000005A   0x0149             LSLS     R1,R1,#+5
   \   0000005C   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000060   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000064   0x88C9             LDRH     R1,[R1, #+6]
   \   00000066   0x7B02             LDRB     R2,[R0, #+12]
   \   00000068   0x4311             ORRS     R1,R2,R1
   \   0000006A   0x7802             LDRB     R2,[R0, #+0]
   \   0000006C   0x0152             LSLS     R2,R2,#+5
   \   0000006E   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   00000072   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   00000076   0x80D1             STRH     R1,[R2, #+6]
    174              //主的计数次数（major iteration count）达到后，是否重新更改源地址
    175              DMA_BASE_PTR->TCD[DMA_Config->Channelx].SLAST =DMA_Config->Source_Adj_Addr;
   \   00000078   0x7801             LDRB     R1,[R0, #+0]
   \   0000007A   0x0149             LSLS     R1,R1,#+5
   \   0000007C   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000080   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000084   0x6902             LDR      R2,[R0, #+16]
   \   00000086   0x60CA             STR      R2,[R1, #+12]
    176              
    177              /*设置目的地址信息*/ 
    178              //设置目的地址 
    179              DMA_BASE_PTR->TCD[DMA_Config->Channelx].DADDR=DMA_Config->Dest_Addr;
   \   00000088   0x7801             LDRB     R1,[R0, #+0]
   \   0000008A   0x0149             LSLS     R1,R1,#+5
   \   0000008C   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000090   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000094   0x6942             LDR      R2,[R0, #+20]
   \   00000096   0x610A             STR      R2,[R1, #+16]
    180              //在执行完针对目的地址的操作之后，是否在原地址的基础上累加
    181              DMA_BASE_PTR->TCD[DMA_Config->Channelx].DOFF =DMA_Config->Dest_Addr_inc;
   \   00000098   0x7801             LDRB     R1,[R0, #+0]
   \   0000009A   0x0149             LSLS     R1,R1,#+5
   \   0000009C   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000000A0   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   000000A4   0x7E42             LDRB     R2,[R0, #+25]
   \   000000A6   0x828A             STRH     R2,[R1, #+20]
    182              //设置源地址的传输宽度
    183              DMA_BASE_PTR->TCD[DMA_Config->Channelx].ATTR |=DMA_Config->Dest_Size;
   \   000000A8   0x7801             LDRB     R1,[R0, #+0]
   \   000000AA   0x0149             LSLS     R1,R1,#+5
   \   000000AC   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000000B0   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   000000B4   0x88C9             LDRH     R1,[R1, #+6]
   \   000000B6   0x7E02             LDRB     R2,[R0, #+24]
   \   000000B8   0x4311             ORRS     R1,R2,R1
   \   000000BA   0x7802             LDRB     R2,[R0, #+0]
   \   000000BC   0x0152             LSLS     R2,R2,#+5
   \   000000BE   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   000000C2   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   000000C6   0x80D1             STRH     R1,[R2, #+6]
    184              //主的计数次数（major iteration count）达到后，是否重新更改目的地址
    185              DMA_BASE_PTR->TCD[DMA_Config->Channelx].DLAST_SGA =DMA_Config->Dest_Adj_Addr;
   \   000000C8   0x7801             LDRB     R1,[R0, #+0]
   \   000000CA   0x0149             LSLS     R1,R1,#+5
   \   000000CC   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000000D0   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   000000D4   0x69C2             LDR      R2,[R0, #+28]
   \   000000D6   0x618A             STR      R2,[R1, #+24]
    186              
    187              if(DMA_Config->Minor_loop_Length>32767) //主循环计数器的次数在0---32767之间
   \   000000D8   0x8841             LDRH     R1,[R0, #+2]
   \   000000DA   0xF5B1 0x4F00      CMP      R1,#+32768
   \   000000DE   0xD301             BCC.N    ??LPLD_eDMA_Config_2
    188              {
    189                  return 0;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0xE0A4             B.N      ??LPLD_eDMA_Config_1
    190              }
    191              else
    192              {
    193                  //===============设置主计数器长度，循环次数====================================
    194                  //设置数据长度，长度每次递减。也可以称为 当前主循环计数器 current major loop count
    195                  DMA_BASE_PTR->TCD[DMA_Config->Channelx].CITER_ELINKNO=DMA_CITER_ELINKNO_CITER(DMA_Config->Minor_loop_Length);
   \                     ??LPLD_eDMA_Config_2:
   \   000000E4   0x7801             LDRB     R1,[R0, #+0]
   \   000000E6   0x0149             LSLS     R1,R1,#+5
   \   000000E8   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000000EC   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   000000F0   0x8842             LDRH     R2,[R0, #+2]
   \   000000F2   0x0452             LSLS     R2,R2,#+17       ;; ZeroExtS R2,R2,#+17,#+17
   \   000000F4   0x0C52             LSRS     R2,R2,#+17
   \   000000F6   0x82CA             STRH     R2,[R1, #+22]
    196                  //起始循环计数器，当主循环计数器为零的时候，将装载起始循环计数器的值
    197                  DMA_BASE_PTR->TCD[DMA_Config->Channelx].BITER_ELINKNO=DMA_CITER_ELINKNO_CITER(DMA_Config->Minor_loop_Length);
   \   000000F8   0x7801             LDRB     R1,[R0, #+0]
   \   000000FA   0x0149             LSLS     R1,R1,#+5
   \   000000FC   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000100   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000104   0x8842             LDRH     R2,[R0, #+2]
   \   00000106   0x0452             LSLS     R2,R2,#+17       ;; ZeroExtS R2,R2,#+17,#+17
   \   00000108   0x0C52             LSRS     R2,R2,#+17
   \   0000010A   0x83CA             STRH     R2,[R1, #+30]
    198                  //设置每一次传输字节的个数，个数达到上限时，DMA便将数据存入memory
    199                  DMA_BASE_PTR->TCD[DMA_Config->Channelx].NBYTES_MLNO=DMA_NBYTES_MLNO_NBYTES(DMA_Config->Trans_bytesNum);
   \   0000010C   0x7801             LDRB     R1,[R0, #+0]
   \   0000010E   0x0149             LSLS     R1,R1,#+5
   \   00000110   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000114   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000118   0x6842             LDR      R2,[R0, #+4]
   \   0000011A   0x608A             STR      R2,[R1, #+8]
    200              }
    201              
    202              //============设置DMA TCD控制寄存器==========================//  
    203              DMA_BASE_PTR->TCD[DMA_Config->Channelx].CSR =0;     //清空CSR的设置                   
   \   0000011C   0x7801             LDRB     R1,[R0, #+0]
   \   0000011E   0x0149             LSLS     R1,R1,#+5
   \   00000120   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000124   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000128   0x2200             MOVS     R2,#+0
   \   0000012A   0x838A             STRH     R2,[R1, #+28]
    204              //===========设置DMA中断===================================//
    205              if(!DMA_Config->Dma_irqc)
   \   0000012C   0xF890 0x1020      LDRB     R1,[R0, #+32]
   \   00000130   0x2900             CMP      R1,#+0
   \   00000132   0xD109             BNE.N    ??LPLD_eDMA_Config_3
    206              {
    207                 DMA_INT &=~(1<<DMA_Config->Channelx); //关闭相应通道的中断请求  
   \   00000134   0x....             LDR.N    R1,??DataTable3_5  ;; 0x40008024
   \   00000136   0x6809             LDR      R1,[R1, #+0]
   \   00000138   0x2201             MOVS     R2,#+1
   \   0000013A   0xF990 0x3000      LDRSB    R3,[R0, #+0]
   \   0000013E   0x409A             LSLS     R2,R2,R3
   \   00000140   0x4391             BICS     R1,R1,R2
   \   00000142   0x....             LDR.N    R2,??DataTable3_5  ;; 0x40008024
   \   00000144   0x6011             STR      R1,[R2, #+0]
   \   00000146   0xE03A             B.N      ??LPLD_eDMA_Config_4
    208              }
    209              else if(DMA_Config->Dma_irqc==1)
   \                     ??LPLD_eDMA_Config_3:
   \   00000148   0xF890 0x1020      LDRB     R1,[R0, #+32]
   \   0000014C   0x2901             CMP      R1,#+1
   \   0000014E   0xD119             BNE.N    ??LPLD_eDMA_Config_5
    210              {
    211                 DMA_INT |=(1<<DMA_Config->Channelx); //开启相应通道的中断请求
   \   00000150   0x....             LDR.N    R1,??DataTable3_5  ;; 0x40008024
   \   00000152   0x6809             LDR      R1,[R1, #+0]
   \   00000154   0x2201             MOVS     R2,#+1
   \   00000156   0xF990 0x3000      LDRSB    R3,[R0, #+0]
   \   0000015A   0x409A             LSLS     R2,R2,R3
   \   0000015C   0x4311             ORRS     R1,R2,R1
   \   0000015E   0x....             LDR.N    R2,??DataTable3_5  ;; 0x40008024
   \   00000160   0x6011             STR      R1,[R2, #+0]
    212                 DMA_BASE_PTR->TCD[DMA_Config->Channelx].CSR  |=DMA_CSR_INTHALF_MASK;//使能DMA 主循环计数器减到一半 中断
   \   00000162   0x7801             LDRB     R1,[R0, #+0]
   \   00000164   0x0149             LSLS     R1,R1,#+5
   \   00000166   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   0000016A   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   0000016E   0x8B89             LDRH     R1,[R1, #+28]
   \   00000170   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   00000174   0x7802             LDRB     R2,[R0, #+0]
   \   00000176   0x0152             LSLS     R2,R2,#+5
   \   00000178   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   0000017C   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   00000180   0x8391             STRH     R1,[R2, #+28]
   \   00000182   0xE01C             B.N      ??LPLD_eDMA_Config_4
    213              }
    214              else if(DMA_Config->Dma_irqc==2)
   \                     ??LPLD_eDMA_Config_5:
   \   00000184   0xF890 0x1020      LDRB     R1,[R0, #+32]
   \   00000188   0x2902             CMP      R1,#+2
   \   0000018A   0xD118             BNE.N    ??LPLD_eDMA_Config_4
    215              {
    216                 DMA_INT |=(1<<DMA_Config->Channelx); //开启相应通道的中断请求
   \   0000018C   0x....             LDR.N    R1,??DataTable3_5  ;; 0x40008024
   \   0000018E   0x6809             LDR      R1,[R1, #+0]
   \   00000190   0x2201             MOVS     R2,#+1
   \   00000192   0xF990 0x3000      LDRSB    R3,[R0, #+0]
   \   00000196   0x409A             LSLS     R2,R2,R3
   \   00000198   0x4311             ORRS     R1,R2,R1
   \   0000019A   0x....             LDR.N    R2,??DataTable3_5  ;; 0x40008024
   \   0000019C   0x6011             STR      R1,[R2, #+0]
    217                 DMA_BASE_PTR->TCD[DMA_Config->Channelx].CSR  |=DMA_CSR_INTMAJOR_MASK;//使能DMA 主循环计数器减到零 中断
   \   0000019E   0x7801             LDRB     R1,[R0, #+0]
   \   000001A0   0x0149             LSLS     R1,R1,#+5
   \   000001A2   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000001A6   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   000001AA   0x8B89             LDRH     R1,[R1, #+28]
   \   000001AC   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   000001B0   0x7802             LDRB     R2,[R0, #+0]
   \   000001B2   0x0152             LSLS     R2,R2,#+5
   \   000001B4   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   000001B8   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   000001BC   0x8391             STRH     R1,[R2, #+28]
    218              }
    219              
    220              if(!DMA_Config->Dma_AutoClose)
   \                     ??LPLD_eDMA_Config_4:
   \   000001BE   0xF890 0x1021      LDRB     R1,[R0, #+33]
   \   000001C2   0x2900             CMP      R1,#+0
   \   000001C4   0xD110             BNE.N    ??LPLD_eDMA_Config_6
    221              {
    222                 DMA_BASE_PTR->TCD[DMA_Config->Channelx].CSR  |=DMA_CSR_DREQ_MASK; //主循环计数器等于零后，自动关闭DMA 
   \   000001C6   0x7801             LDRB     R1,[R0, #+0]
   \   000001C8   0x0149             LSLS     R1,R1,#+5
   \   000001CA   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000001CE   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   000001D2   0x8B89             LDRH     R1,[R1, #+28]
   \   000001D4   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   000001D8   0x7802             LDRB     R2,[R0, #+0]
   \   000001DA   0x0152             LSLS     R2,R2,#+5
   \   000001DC   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   000001E0   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   000001E4   0x8391             STRH     R1,[R2, #+28]
   \   000001E6   0xE010             B.N      ??LPLD_eDMA_Config_7
    223              }
    224              else
    225              {
    226                 DMA_BASE_PTR->TCD[DMA_Config->Channelx].CSR  &=(~DMA_CSR_DREQ_MASK); //主循环计数器等于零后，不关闭DMA
   \                     ??LPLD_eDMA_Config_6:
   \   000001E8   0x7801             LDRB     R1,[R0, #+0]
   \   000001EA   0x0149             LSLS     R1,R1,#+5
   \   000001EC   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000001F0   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   000001F4   0x8B89             LDRH     R1,[R1, #+28]
   \   000001F6   0xF64F 0x72F7      MOVW     R2,#+65527
   \   000001FA   0x4011             ANDS     R1,R2,R1
   \   000001FC   0x7802             LDRB     R2,[R0, #+0]
   \   000001FE   0x0152             LSLS     R2,R2,#+5
   \   00000200   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   00000204   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   00000208   0x8391             STRH     R1,[R2, #+28]
    227              }
    228              //注：使能此寄存器DMA开始工作
    229              //关闭通道x硬件DMA请求 
    230              DMA_ERQ&=~(1<<DMA_Config->Channelx);
   \                     ??LPLD_eDMA_Config_7:
   \   0000020A   0x....             LDR.N    R1,??DataTable3_6  ;; 0x4000800c
   \   0000020C   0x6809             LDR      R1,[R1, #+0]
   \   0000020E   0x2201             MOVS     R2,#+1
   \   00000210   0xF990 0x3000      LDRSB    R3,[R0, #+0]
   \   00000214   0x409A             LSLS     R2,R2,R3
   \   00000216   0x4391             BICS     R1,R1,R2
   \   00000218   0x....             LDR.N    R2,??DataTable3_6  ;; 0x4000800c
   \   0000021A   0x6011             STR      R1,[R2, #+0]
    231              //DMA通道使能
    232              DMAMUX_BASE_PTR->CHCFG[DMA_Config->Channelx]|=DMAMUX_CHCFG_ENBL_MASK;
   \   0000021C   0x7801             LDRB     R1,[R0, #+0]
   \   0000021E   0x....             LDR.N    R2,??DataTable3_3  ;; 0x40021000
   \   00000220   0x5C89             LDRB     R1,[R1, R2]
   \   00000222   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   00000226   0x7800             LDRB     R0,[R0, #+0]
   \   00000228   0x....             LDR.N    R2,??DataTable3_3  ;; 0x40021000
   \   0000022A   0x5481             STRB     R1,[R0, R2]
    233              
    234              return 1;
   \   0000022C   0x2001             MOVS     R0,#+1
   \                     ??LPLD_eDMA_Config_1:
   \   0000022E   0x4770             BX       LR               ;; return
    235          }
    236          
    237          
    238          /*
    239           * LPLD_DMA_EnableReq
    240           * 此函数根据enable的值，开启或关闭通道x的DMA请求，
    241           * 一旦开启通道x的DMA请求，DMA模块就开始工作
    242           * 
    243           * 参数:
    244           *    chx--DMA通道值  一共16个DMA通道
    245           *      |__0  DMA_Channel_0
    246           *      |__1  DMA_Channel_1
    247           *      .....
    248           *      |__15 DMA_Channel_15
    249           *
    250           *    enable--开启或关闭DMA请求
    251           *      |__0  关闭通道x的外设DMA请求
    252           *      |__1  开启通道x的外设DMA请求     
    253           */

   \                                 In section .text, align 2, keep-with-next
    254          void LPLD_DMA_EnableReq(uint8 chx,uint8 enable)
    255          {
    256              if(enable)
   \                     LPLD_DMA_EnableReq:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD008             BEQ.N    ??LPLD_DMA_EnableReq_0
    257              {
    258                  //开启通道x的外设DMA请求 
    259                  DMA_ERQ|=(1<<chx);
   \   00000006   0x....             LDR.N    R1,??DataTable3_6  ;; 0x4000800c
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xFA12 0xF000      LSLS     R0,R2,R0
   \   00000010   0x4308             ORRS     R0,R0,R1
   \   00000012   0x....             LDR.N    R1,??DataTable3_6  ;; 0x4000800c
   \   00000014   0x6008             STR      R0,[R1, #+0]
   \   00000016   0xE008             B.N      ??LPLD_DMA_EnableReq_1
    260              }
    261              else
    262              {
    263                  //关闭通道x的外设DMA请求 
    264                  DMA_ERQ&=~(1<<chx);
   \                     ??LPLD_DMA_EnableReq_0:
   \   00000018   0x....             LDR.N    R1,??DataTable3_6  ;; 0x4000800c
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0xFA12 0xF000      LSLS     R0,R2,R0
   \   00000022   0xEA31 0x0000      BICS     R0,R1,R0
   \   00000026   0x....             LDR.N    R1,??DataTable3_6  ;; 0x4000800c
   \   00000028   0x6008             STR      R0,[R1, #+0]
    265              }
    266          }
   \                     ??LPLD_DMA_EnableReq_1:
   \   0000002A   0x4770             BX       LR               ;; return
    267          
    268          /*
    269           * LPLD_DMA_Reload
    270           * 当完成一次DMA主循环之后，调用此函数可以调整目的地址，并重新设置主循环计数器的次数
    271           * 调整之后 新的目的地址=原来目的地址+下一次主循环的次数
    272           * 
    273           * 参数:
    274           *    chx--DMA通道值  一共16个DMA通道 
    275           *      |__0  DMA_Channel_0
    276           *      |__1  DMA_Channel_1
    277           *      .....
    278           *      |__15 DMA_Channel_15
    279           *
    280           *    dest_base_addr--  目的存储区的首地址，可以是数组的首地址，也可以是数据寄存器的地址
    281           *      
    282           *    dest_offset_addr--目的地址的偏移量，一般情况下目的地址的偏移量等于主循环计数器的次数
    283           *    
    284           *    loop_length--主循环计数器的次数
    285           *     
    286           */

   \                                 In section .text, align 2, keep-with-next
    287          void LPLD_DMA_Reload(uint8 chx, uint32 dest_base_addr, uint32 dest_offset_addr, uint16 loop_length)
    288          {
   \                     LPLD_DMA_Reload:
   \   00000000   0xB410             PUSH     {R4}
    289              //重新设置目的地址
    290              DMA_BASE_PTR->TCD[chx].DADDR =(uint32)(dest_base_addr+dest_offset_addr);
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x0144             LSLS     R4,R0,#+5
   \   00000006   0xF104 0x4480      ADD      R4,R4,#+1073741824
   \   0000000A   0xF514 0x4410      ADDS     R4,R4,#+36864
   \   0000000E   0x1851             ADDS     R1,R2,R1
   \   00000010   0x6121             STR      R1,[R4, #+16]
    291              //设置数据长度，长度每次递减。也可以称为 当前主循环计数器 current major loop count
    292              DMA_BASE_PTR->TCD[chx].CITER_ELINKNO=DMA_CITER_ELINKNO_CITER(loop_length);
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x0141             LSLS     R1,R0,#+5
   \   00000016   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   0000001A   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   0000001E   0x045A             LSLS     R2,R3,#+17       ;; ZeroExtS R2,R3,#+17,#+17
   \   00000020   0x0C52             LSRS     R2,R2,#+17
   \   00000022   0x82CA             STRH     R2,[R1, #+22]
    293              //起始循环计数器，当主循环计数器为零的时候，将装载起始循环计数器的值
    294              DMA_BASE_PTR->TCD[chx].BITER_ELINKNO=DMA_CITER_ELINKNO_CITER(loop_length);
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x0140             LSLS     R0,R0,#+5
   \   00000028   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   0000002C   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   00000030   0x0459             LSLS     R1,R3,#+17       ;; ZeroExtS R1,R3,#+17,#+17
   \   00000032   0x0C49             LSRS     R1,R1,#+17
   \   00000034   0x83C1             STRH     R1,[R0, #+30]
    295          }
   \   00000036   0xBC10             POP      {R4}
   \   00000038   0x4770             BX       LR               ;; return
    296          
    297          
    298          /*
    299           * LPLD_DMA_Isr
    300           * DMA中断底层入口函数
    301           * 
    302           * 用户无需修改，程序自动进入对应通道中断函数
    303           */

   \                                 In section .text, align 2, keep-with-next
    304          void LPLD_DMA_Isr(void)
    305          {
   \                     LPLD_DMA_Isr:
   \   00000000   0xB510             PUSH     {R4,LR}
    306            #define DMA_VECTORNUM   (*(volatile uint8*)(0xE000ED04))
    307            uint8 dma_ch = DMA_VECTORNUM - 16;
   \   00000002   0x....             LDR.N    R0,??DataTable3_7  ;; 0xe000ed04
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF1B0 0x0410      SUBS     R4,R0,#+16
    308            
    309            //调用用户自定义中断服务
    310            DMA_ISR[dma_ch]();
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x....             LDR.N    R0,??DataTable3
   \   0000000E   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000012   0x4780             BLX      R0
    311            //清除中断标志位
    312            DMA_INT |= 0x1u<<dma_ch; 
   \   00000014   0x....             LDR.N    R0,??DataTable3_5  ;; 0x40008024
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x40A1             LSLS     R1,R1,R4
   \   0000001C   0x4308             ORRS     R0,R1,R0
   \   0000001E   0x....             LDR.N    R1,??DataTable3_5  ;; 0x40008024
   \   00000020   0x6008             STR      R0,[R1, #+0]
    313          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     DMA_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x40048040         DC32     0x40048040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x40009000         DC32     0x40009000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x40008024         DC32     0x40008024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x4000800C         DC32     0x4000800c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  LPLD_DMA_EnableReq
        8  LPLD_DMA_Init
             8 -> LPLD_eDMA_Config
             8 -> enable_irq
        8  LPLD_DMA_Isr
             8 -- Indirect call
        4  LPLD_DMA_Reload
        0  LPLD_eDMA_Config


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
      64  DMA_ISR
      44  LPLD_DMA_EnableReq
     132  LPLD_DMA_Init
      36  LPLD_DMA_Isr
      58  LPLD_DMA_Reload
     560  LPLD_eDMA_Config

 
  64 bytes in section .bss
 862 bytes in section .text
 
 862 bytes of CODE memory
  64 bytes of DATA memory

Errors: none
Warnings: none
