###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     06/Jul/2014  14:13:55 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\robot _init\robot\lib\LPLD\HAL_DAC.c                  #
#    Command line =  "F:\robot _init\robot\lib\LPLD\HAL_DAC.c" -D IAR -D      #
#                    LPLD_K60 -lCN "F:\robot _init\robot\project\robot_car_co #
#                    m\iar\FLASH\List\" -lB "F:\robot                         #
#                    _init\robot\project\robot_car_com\iar\FLASH\List\" -o    #
#                    "F:\robot _init\robot\project\robot_car_com\iar\FLASH\Ob #
#                    j\" --no_cse --no_unroll --no_inline --no_code_motion    #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M4 -e --fpu=None            #
#                    --dlib_config "D:\IAR Systems\Embedded Workbench         #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I "F:\robot         #
#                    _init\robot\project\robot_car_com\iar\..\app\" -I        #
#                    "F:\robot _init\robot\project\robot_car_com\iar\..\..\.. #
#                    \lib\common\" -I "F:\robot _init\robot\project\robot_car #
#                    _com\iar\..\..\..\lib\cpu\" -I "F:\robot                 #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\cpu\h #
#                    eaders\" -I "F:\robot _init\robot\project\robot_car_com\ #
#                    iar\..\..\..\lib\drivers\adc16\" -I "F:\robot            #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\enet\" -I "F:\robot _init\robot\project\robot_car_com #
#                    \iar\..\..\..\lib\drivers\lptmr\" -I "F:\robot           #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\mcg\" -I "F:\robot _init\robot\project\robot_car_com\ #
#                    iar\..\..\..\lib\drivers\pmc\" -I "F:\robot              #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\rtc\" -I "F:\robot _init\robot\project\robot_car_com\ #
#                    iar\..\..\..\lib\drivers\uart\" -I "F:\robot             #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\wdog\" -I "F:\robot _init\robot\project\robot_car_com #
#                    \iar\..\..\..\lib\platforms\" -I "F:\robot               #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\LPLD\ #
#                    " -I "F:\robot _init\robot\project\robot_car_com\iar\..\ #
#                    ..\..\lib\LPLD\FatFs\" -I "F:\robot                      #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\LPLD\ #
#                    USB\" -I "F:\robot _init\robot\project\robot_car_com\iar #
#                    \..\..\..\lib\iar_config_files\" -Ol                     #
#    List file    =  F:\robot _init\robot\project\robot_car_com\iar\FLASH\Lis #
#                    t\HAL_DAC.lst                                            #
#    Object file  =  F:\robot _init\robot\project\robot_car_com\iar\FLASH\Obj #
#                    \HAL_DAC.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\robot _init\robot\lib\LPLD\HAL_DAC.c
      1          /*
      2           * --------------"拉普兰德K60底层库"-----------------
      3           *
      4           * 测试硬件平台:LPLD_K60 Card
      5           * 版权所有:北京拉普兰德电子技术有限公司
      6           * 网络销售:http://laplenden.taobao.com
      7           * 公司门户:http://www.lpld.cn
      8           *
      9           * 文件名: HAL_DAC.c
     10           * 用途: DAC底层模块相关函数
     11           * 最后修改日期: 20120618
     12           *
     13           * 开发者使用协议:
     14           *  本代码面向所有使用者开放源代码，开发者可以随意修改源代码。但本段及以上注释应
     15           *  予以保留，不得更改或删除原版权所有者姓名。二次开发者可以加注二次版权所有者，
     16           *  但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     17          */
     18          
     19          #include "HAL_DAC.h"
     20          #include "common.h"
     21          
     22          
     23          //内部函数
     24          uint8 LPLD_DAC_Config(LPLD_DAC_Cfg_t *);
     25          
     26          //用户自定义中断服务函数数组

   \                                 In section .bss, align 4
     27          DAC_ISR_CALLBACK DAC_ISR[2];
   \                     DAC_ISR:
   \   00000000                      DS8 8
     28          
     29          /*******需用到DAC中断，请在isr.h中粘贴一下代码:*********
     30          
     31          //DAC模块中断服务定义
     32          #undef  VECTOR_097
     33          #define VECTOR_097 LPLD_DAC_Isr
     34          #undef  VECTOR_098
     35          #define VECTOR_098 LPLD_DAC_Isr
     36          
     37          //以下函数在LPLD_Kinetis底层包，不必修改
     38          extern void LPLD_DAC_Isr(void);
     39          */
     40          
     41          
     42          
     43          //DAC映射地址数组

   \                                 In section .data, align 4
     44          volatile DAC_MemMapPtr DACx_Ptr[2] = {DAC0_BASE_PTR, 
   \                     DACx_Ptr:
   \   00000000   0x400CC000         DC32 400CC000H, 400CD000H
   \              0x400CD000   
     45                                                DAC1_BASE_PTR};
     46          /*
     47          
     48           * LPLD_DAC_Set_Buffer
     49           * 设置DAC通道的缓冲区
     50           * 
     51           * 参数:
     52           *    dacx--DAC模块号
     53           *      |__DAC0           --DAC0模块
     54           *      |__DAC1           --DAC1模块
     55           *    DACx_DATn--DAC缓冲区号
     56           *      |__0~15           --缓冲区0~15号
     57           *    data16--DAC缓冲区数据
     58           *
     59           * 输出
     60           *    无
     61           */

   \                                 In section .text, align 2, keep-with-next
     62          void LPLD_DAC_Set_Buffer(DACx dacx, uint8 DACx_DATn, uint16 data16)
     63          {
     64            DAC_MemMapPtr dacptr = DACx_Ptr[dacx];
   \                     LPLD_DAC_Set_Buffer:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R3,??DataTable4
   \   00000004   0xF853 0x0020      LDR      R0,[R3, R0, LSL #+2]
     65            DAC_DATL_REG(dacptr, DACx_DATn) = (data16&0x0ff); 
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF800 0x2011      STRB     R2,[R0, R1, LSL #+1]
     66            DAC_DATH_REG(dacptr, DACx_DATn) = (data16&0xf00)>>8;                                
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0xEB10 0x0041      ADDS     R0,R0,R1, LSL #+1
   \   00000014   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000016   0x1211             ASRS     R1,R2,#+8
   \   00000018   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   0000001C   0x7041             STRB     R1,[R0, #+1]
     67          }
   \   0000001E   0x4770             BX       LR               ;; return
     68          
     69          
     70          
     71          /*
     72           * LPLD_DAC_Reset_Reg
     73           * 复位DAC通道以及各个寄存器
     74           * 
     75           * 参数:
     76           *    dacx--DAC模块号
     77           *      |__DAC0           --DAC0模块
     78           *      |__DAC1           --DAC1模块
     79           * 输出
     80           *    无
     81           */

   \                                 In section .text, align 2, keep-with-next
     82          void LPLD_DAC_Reset_Reg(DACx dacx)
     83          {
   \                     LPLD_DAC_Reset_Reg:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     84            DAC_MemMapPtr dacptr = DACx_Ptr[dacx];
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x....             LDR.N    R0,??DataTable4
   \   00000008   0xF850 0x5024      LDR      R5,[R0, R4, LSL #+2]
     85            uint8 i;   
     86            
     87            //复位16个通道缓存
     88            for (i=0; i<16;i++)
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0xE007             B.N      ??LPLD_DAC_Reset_Reg_0
     89            {
     90              LPLD_DAC_Set_Buffer(dacx, i, 0x00); 
   \                     ??LPLD_DAC_Reset_Reg_1:
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x0031             MOVS     R1,R6
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       LPLD_DAC_Set_Buffer
     91            }
   \   0000001E   0x1C76             ADDS     R6,R6,#+1
   \                     ??LPLD_DAC_Reset_Reg_0:
   \   00000020   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000022   0x2E10             CMP      R6,#+16
   \   00000024   0xD3F4             BCC.N    ??LPLD_DAC_Reset_Reg_1
     92            //DAC 缓存读指针清零
     93            DAC_SR_REG(dacptr) = DAC_SR_DACBFRPTF_MASK ;
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF885 0x0020      STRB     R0,[R5, #+32]
     94            //清空 C0 寄存器 
     95            DAC_C0_REG(dacptr) = 0x00 ;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF885 0x0021      STRB     R0,[R5, #+33]
     96            //清空 C1 寄存器 
     97            DAC_C1_REG(dacptr) = 0x00 ;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF885 0x0022      STRB     R0,[R5, #+34]
     98            //将缓冲区的上限设置为最大
     99            DAC_C2_REG(dacptr) = 0x0F;
   \   00000038   0x200F             MOVS     R0,#+15
   \   0000003A   0xF885 0x0023      STRB     R0,[R5, #+35]
    100          }
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    101          
    102          /*
    103           * LPLD_DAC_Init
    104           * DAC模块初始化函数，在此函数中设置默认参数以及调用LPLD_DAC_Config配置寄存器
    105           *
    106           * 参数 LPLD_DAC_Cfg_t *DAC_Config
    107           * 详细参数在LPLD_DAC_Cfg_t 结构体中定义
    108           * LPLD_DAC_Cfg_t 结构体在（在HAL_DAC.h）头文件中定义
    109           *
    110           * 输出：
    111           *   0 初始化失败
    112           *   1 初始化成功
    113          */

   \                                 In section .text, align 2, keep-with-next
    114          uint8 LPLD_DAC_Init(LPLD_DAC_Cfg_t *DAC_Config)
    115          { 
   \                     LPLD_DAC_Init:
   \   00000000   0xB580             PUSH     {R7,LR}
    116            
    117            if(DAC_Config -> dacx > DAC1)
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x2902             CMP      R1,#+2
   \   00000006   0xD301             BCC.N    ??LPLD_DAC_Init_0
    118            {
    119              return 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE024             B.N      ??LPLD_DAC_Init_1
    120            }
    121            
    122            //如果用户没有设置 水印模式的字数 默认为1个字
    123            if(DAC_Config -> Water_Mark_Mode  == NULL)
   \                     ??LPLD_DAC_Init_0:
   \   0000000C   0x7841             LDRB     R1,[R0, #+1]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD101             BNE.N    ??LPLD_DAC_Init_2
    124            {
    125              DAC_Config -> Water_Mark_Mode = WATER_MODE_1WORD;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x7041             STRB     R1,[R0, #+1]
    126            }
    127            
    128            //如果用户没有设置 缓冲区使能 默认为禁用缓冲区
    129            if(DAC_Config -> Buffer_Enable == NULL)
   \                     ??LPLD_DAC_Init_2:
   \   00000016   0x7881             LDRB     R1,[R0, #+2]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD101             BNE.N    ??LPLD_DAC_Init_3
    130            {
    131              DAC_Config -> Buffer_Enable = BUFFER_DISABLE;       
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x7081             STRB     R1,[R0, #+2]
    132            }
    133            
    134            //如果用户没有设置 缓冲区的模式 默认为正常模式
    135            if(DAC_Config -> Buffer_Mode == NULL)
   \                     ??LPLD_DAC_Init_3:
   \   00000020   0x78C1             LDRB     R1,[R0, #+3]
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD101             BNE.N    ??LPLD_DAC_Init_4
    136            {
    137              DAC_Config -> Buffer_Mode = BUFFER_MODE_NORMAL;       
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x70C1             STRB     R1,[R0, #+3]
    138            }
    139            
    140            //如果用户没有设置 触发模式 默认为无触发模式
    141            if(DAC_Config -> Triger_Mode == NULL)
   \                     ??LPLD_DAC_Init_4:
   \   0000002A   0x7901             LDRB     R1,[R0, #+4]
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD101             BNE.N    ??LPLD_DAC_Init_5
    142            {
    143              DAC_Config -> Triger_Mode = TRIGER_MODE_NONE;   
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x7101             STRB     R1,[R0, #+4]
    144            } 
    145            
    146            //如果用户没有设置 缓冲区的起始位置 默认为0
    147            if(DAC_Config -> Buffer_Init_Pos ==NULL)
   \                     ??LPLD_DAC_Init_5:
   \   00000034   0x7941             LDRB     R1,[R0, #+5]
   \   00000036   0x2900             CMP      R1,#+0
   \   00000038   0xD101             BNE.N    ??LPLD_DAC_Init_6
    148            {
    149              DAC_Config -> Buffer_Init_Pos = 0;    
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x7141             STRB     R1,[R0, #+5]
    150            }
    151            
    152            //如果用户没有设置 缓冲区的最大值 默认为16
    153            if(DAC_Config -> Buffer_Up_Limit == NULL)
   \                     ??LPLD_DAC_Init_6:
   \   0000003E   0x7981             LDRB     R1,[R0, #+6]
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD101             BNE.N    ??LPLD_DAC_Init_7
    154            {
    155              DAC_Config -> Buffer_Up_Limit = 15;   
   \   00000044   0x210F             MOVS     R1,#+15
   \   00000046   0x7181             STRB     R1,[R0, #+6]
    156            }
    157              
    158            //如果用户没有设置 中断方式 默认为不开中断
    159            if(DAC_Config -> DAC_irqc == NULL)
   \                     ??LPLD_DAC_Init_7:
   \   00000048   0x79C1             LDRB     R1,[R0, #+7]
   \   0000004A   0x2900             CMP      R1,#+0
   \   0000004C   0xD101             BNE.N    ??LPLD_DAC_Init_8
    160            {
    161              DAC_Config -> DAC_irqc = 0;     
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x71C1             STRB     R1,[R0, #+7]
    162            } 
    163          
    164            //配置DAC寄存器
    165            return LPLD_DAC_Config(DAC_Config);
   \                     ??LPLD_DAC_Init_8:
   \   00000052   0x.... 0x....      BL       LPLD_DAC_Config
   \                     ??LPLD_DAC_Init_1:
   \   00000056   0xBD02             POP      {R1,PC}          ;; return
    166          
    167          }
    168          
    169          /*
    170           * 内部函数，用户无需调用
    171           * LPLD_DAC_Config
    172           * 配置DAC寄存器函数
    173           *
    174           * 参数 LPLD_DAC_Cfg_t *DAC_Config
    175           * 详细参数在LPLD_DAC_Cfg_t 结构体中定义
    176           * LPLD_DAC_Cfg_t 结构体在（在HAL_DAC.h）头文件中定义
    177           *
    178           * 输出：
    179           *   0 配置失败
    180           *   1 配置成功
    181          */

   \                                 In section .text, align 2, keep-with-next
    182          static uint8 LPLD_DAC_Config(LPLD_DAC_Cfg_t *DAC_Config)
    183          {
   \                     LPLD_DAC_Config:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    184            DAC_MemMapPtr dacptr = DACx_Ptr[DAC_Config->dacx];
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x....             LDR.N    R1,??DataTable4
   \   00000008   0xF851 0x5020      LDR      R5,[R1, R0, LSL #+2]
    185            
    186            //===========配置DAC_C0寄存器=================//
    187            if( dacptr == DAC0_BASE_PTR )
   \   0000000C   0x....             LDR.N    R0,??DataTable4_1  ;; 0x400cc000
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD16A             BNE.N    ??LPLD_DAC_Config_0
    188            {
    189              //开启DAC0时钟
    190              SIM_SCGC2 |= SIM_SCGC2_DAC0_MASK ; 
   \   00000012   0x....             LDR.N    R0,??DataTable4_2  ;; 0x4004802c
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   0000001A   0x....             LDR.N    R1,??DataTable4_2  ;; 0x4004802c
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    191              
    192              if(DAC_Config -> DAC_irqc)
   \   0000001E   0x79E0             LDRB     R0,[R4, #+7]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD005             BEQ.N    ??LPLD_DAC_Config_1
    193              {
    194                enable_irq(81);//开启DAC0 CPU级中断
   \   00000024   0x2051             MOVS     R0,#+81
   \   00000026   0x.... 0x....      BL       enable_irq
    195                DAC_ISR[0]=DAC_Config -> isr_func;
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x....             LDR.N    R1,??DataTable4_3
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    196              }
    197              
    198            }
    199            else if( dacptr == DAC1_BASE_PTR )
    200            {
    201              //开启DAC1时钟
    202              SIM_SCGC2 |= SIM_SCGC2_DAC1_MASK ; 
    203              
    204              if(DAC_Config->DAC_irqc)
    205              {
    206                enable_irq(82);//开启DAC1 CPU级中断
    207                DAC_ISR[1]=DAC_Config->isr_func;
    208              }
    209            }
    210            else
    211              return 0;
    212            
    213            //===========配置DAC_C0寄存器=================//
    214            DAC_C0_REG(dacptr)  =0;
   \                     ??LPLD_DAC_Config_1:
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF885 0x0021      STRB     R0,[R5, #+33]
    215            //禁止DAC模块所有中断
    216            if(DAC_Config->DAC_irqc == DAC_IRQ_DISABLE)
   \   00000036   0x79E0             LDRB     R0,[R4, #+7]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD16A             BNE.N    ??LPLD_DAC_Config_2
    217            {
    218              //The DAC buffer read pointer bottom flag interrupt is disabled.
    219              DAC_C0_REG(dacptr) &= (~DAC_C0_DACBBIEN_MASK);
   \   0000003C   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   00000040   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000044   0xF885 0x0021      STRB     R0,[R5, #+33]
    220              //The DAC buffer read pointer top flag interrupt is disabled.
    221              DAC_C0_REG(dacptr) &= (~DAC_C0_DACBTIEN_MASK);
   \   00000048   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   0000004C   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   00000050   0xF885 0x0021      STRB     R0,[R5, #+33]
    222              //The DAC buffer watermark interrupt is disabled.
    223              DAC_C0_REG(dacptr) &= (~DAC_C0_DACBWIEN_MASK); 
   \   00000054   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   00000058   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \   0000005C   0xF885 0x0021      STRB     R0,[R5, #+33]
    224            }
    225            //开启DAC模块计数指针指底中断
    226            else if(DAC_Config->DAC_irqc == DAC_IRQ_POINTER_BOTTOM)
    227            {
    228              //The DAC buffer read pointer bottom flag interrupt is disabled.
    229              DAC_C0_REG(dacptr) |= DAC_C0_DACBBIEN_MASK; 
    230            }
    231            //开启DAC模块计数指针指顶中断
    232            else if(DAC_Config->DAC_irqc == DAC_IRQ_POINTER_TOP)
    233            {
    234              //The DAC buffer read pointer top flag interrupt is disabled.
    235              DAC_C0_REG(dacptr) |=  DAC_C0_DACBTIEN_MASK; 
    236            }
    237            //开启DAC模块计数水印中断
    238            else if(DAC_Config->DAC_irqc == DAC_IRQ_WATER_MARK)
    239            {
    240              //The DAC buffer watermark interrupt is disabled.
    241              DAC_C0_REG(dacptr) |=  DAC_C0_DACBWIEN_MASK;   
    242            }
    243            else 
    244              return 0;
    245          
    246            //设置DAC能耗模式：设置成为高功耗模式
    247            DAC_C0_REG(dacptr) &= (~DAC_C0_LPEN_MASK);
   \                     ??LPLD_DAC_Config_3:
   \   00000060   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   00000064   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   00000068   0xF885 0x0021      STRB     R0,[R5, #+33]
    248            
    249            //配置触发方式
    250            //无触发方式，DAC根据BUFFER0的数值从DAC0通道输出
    251            if(DAC_Config->Triger_Mode == TRIGER_MODE_NONE)
   \   0000006C   0x7920             LDRB     R0,[R4, #+4]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD16F             BNE.N    ??LPLD_DAC_Config_4
    252            {
    253              //设置DAC触发方式：软件触发禁止
    254              DAC_C0_REG(dacptr) &= (~DAC_C0_DACTRGSEL_MASK);
   \   00000072   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   00000076   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   0000007A   0xF885 0x0021      STRB     R0,[R5, #+33]
    255              //设置DAC软件触发方式是否有效：=1 有效 =0 无效
    256              DAC_C0_REG(dacptr) |=  DAC_C0_DACSWTRG_MASK;
   \   0000007E   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   00000082   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000086   0xF885 0x0021      STRB     R0,[R5, #+33]
    257            }
    258            //软件触发方式，DAC根据DAC_C0_DACSWTRG_MASK 产生软件触发信号
    259            else if(DAC_Config->Triger_Mode == TRIGER_MODE_SOFTWARE)
    260            {
    261              //设置DAC触发方式：软件触发开启
    262              DAC_C0_REG(dacptr) |=  DAC_C0_DACTRGSEL_MASK;
    263              //设置DAC软件触发方式是否有效：=1 有效 =0 无效
    264              DAC_C0_REG(dacptr) |=  DAC_C0_DACSWTRG_MASK;
    265            }
    266            //软件触发方式，DAC根据硬件产生的信号 产生触发
    267            else if(DAC_Config->Triger_Mode == TRIGER_MODE_HARDWARE)
    268            {
    269              //设置DAC触发方式：硬件出发开启
    270              DAC_C0_REG(dacptr) &= (~DAC_C0_DACTRGSEL_MASK);
    271              //设置DAC软件触发方式是否有效：=1 有效 =0 无效
    272              DAC_C0_REG(dacptr) &= (~DAC_C0_DACSWTRG_MASK );
    273            }
    274            else 
    275              return 0;
    276            //选择DAC电压参考源
    277            //0 The DAC selets DACREF_1 as the reference voltage.
    278            //  VREF_OUT = DACREF_1
    279            //1 The DAC selets DACREF_2 as the reference voltage.
    280            //  VDDA = DACREF_2
    281            //选择VDDA作为参考电压
    282            DAC_C0_REG(dacptr) |=  DAC_C0_DACRFS_MASK;
   \                     ??LPLD_DAC_Config_5:
   \   0000008A   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   0000008E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000092   0xF885 0x0021      STRB     R0,[R5, #+33]
    283            //使能DAC模块
    284            DAC_C0_REG(dacptr) |=  DAC_C0_DACEN_MASK;
   \   00000096   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   0000009A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000009E   0xF885 0x0021      STRB     R0,[R5, #+33]
    285            //===========DAC_C0配置完毕====================//
    286            
    287            //===========配置DAC_C1寄存器=================//
    288            DAC_C1_REG(dacptr)  = 0;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF885 0x0022      STRB     R0,[R5, #+34]
    289            //禁止DAC的DMA模式 
    290            DAC_C1_REG(dacptr) &= (~DAC_C1_DMAEN_MASK);
   \   000000A8   0xF895 0x0022      LDRB     R0,[R5, #+34]
   \   000000AC   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000000B0   0xF885 0x0022      STRB     R0,[R5, #+34]
    291            //DAC buffer watermark select
    292            
    293            //DAC 水印缓冲设置为 1个word 
    294            if(DAC_Config->Water_Mark_Mode == WATER_MODE_1WORD)
   \   000000B4   0x7860             LDRB     R0,[R4, #+1]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD16D             BNE.N    ??LPLD_DAC_Config_6
    295            {
    296              DAC_C1_REG(dacptr) |= DAC_C1_DACBFWM(WATER_MODE_1WORD);
   \   000000BA   0xF895 0x0022      LDRB     R0,[R5, #+34]
   \   000000BE   0xF885 0x0022      STRB     R0,[R5, #+34]
    297            }
    298             //DAC 水印缓冲设置为 2个word 
    299            else if(DAC_Config->Water_Mark_Mode == WATER_MODE_2WORD)
    300            {
    301              DAC_C1_REG(dacptr) |= DAC_C1_DACBFWM(WATER_MODE_2WORD);  
    302            }
    303             //DAC 水印缓冲设置为 3word 
    304            else if(DAC_Config->Water_Mark_Mode == WATER_MODE_3WORD)
    305            {
    306              DAC_C1_REG(dacptr) |= DAC_C1_DACBFWM(WATER_MODE_3WORD);   
    307            }
    308            //DAC 水印缓冲设置为 4个word 
    309            else if(DAC_Config->Water_Mark_Mode == WATER_MODE_4WORD)
    310            {
    311              DAC_C1_REG(dacptr) |= DAC_C1_DACBFWM(WATER_MODE_4WORD);   
    312            }
    313            else
    314              return 0;
    315            
    316            //DAC 选择为正常模式
    317            //DAC Buffer 指针从零开始++ 直到等于 DAC Buffer Limit
    318            //然后DAC Buffer 指针清零
    319            //设置成为正常模式
    320            if(DAC_Config->Buffer_Mode == BUFFER_MODE_NORMAL)
   \                     ??LPLD_DAC_Config_7:
   \   000000C2   0x78E0             LDRB     R0,[R4, #+3]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xF040 0x8086      BNE.W    ??LPLD_DAC_Config_8
    321            {
    322              DAC_C1_REG(dacptr) |= DAC_C1_DACBFMD(BUFFER_MODE_NORMAL);
   \   000000CA   0xF895 0x0022      LDRB     R0,[R5, #+34]
   \   000000CE   0xF885 0x0022      STRB     R0,[R5, #+34]
    323            }
    324            //设置成为反转模式
    325            else if(DAC_Config->Buffer_Mode == BUFFER_MODE_SWING)
    326            {
    327              DAC_C1_REG(dacptr) |= DAC_C1_DACBFMD(BUFFER_MODE_SWING);  
    328            }
    329            //设置成为一次扫描模式
    330            else if(DAC_Config->Buffer_Mode == BUFFER_MODE_ONETIMESCAN)
    331            {
    332              DAC_C1_REG(dacptr) |= DAC_C1_DACBFMD(BUFFER_MODE_ONETIMESCAN);   
    333            }
    334            else
    335              return 0;
    336            
    337            //是否使能DAC Buffer  
    338            if(DAC_Config->Buffer_Enable == BUFFER_ENABLE)
   \                     ??LPLD_DAC_Config_9:
   \   000000D2   0x78A0             LDRB     R0,[R4, #+2]
   \   000000D4   0x2801             CMP      R0,#+1
   \   000000D6   0xF040 0x8094      BNE.W    ??LPLD_DAC_Config_10
    339            {
    340              DAC_C1_REG(dacptr) |= DAC_C1_DACBFEN_MASK;
   \   000000DA   0xF895 0x0022      LDRB     R0,[R5, #+34]
   \   000000DE   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000E2   0xF885 0x0022      STRB     R0,[R5, #+34]
   \   000000E6   0xE092             B.N      ??LPLD_DAC_Config_11
    341            }
   \                     ??LPLD_DAC_Config_0:
   \   000000E8   0x....             LDR.N    R0,??DataTable4_4  ;; 0x400cd000
   \   000000EA   0x4285             CMP      R5,R0
   \   000000EC   0xD10F             BNE.N    ??LPLD_DAC_Config_12
   \   000000EE   0x....             LDR.N    R0,??DataTable4_2  ;; 0x4004802c
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   000000F6   0x....             LDR.N    R1,??DataTable4_2  ;; 0x4004802c
   \   000000F8   0x6008             STR      R0,[R1, #+0]
   \   000000FA   0x79E0             LDRB     R0,[R4, #+7]
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD097             BEQ.N    ??LPLD_DAC_Config_1
   \   00000100   0x2052             MOVS     R0,#+82
   \   00000102   0x.... 0x....      BL       enable_irq
   \   00000106   0x....             LDR.N    R0,??DataTable4_3
   \   00000108   0x68A1             LDR      R1,[R4, #+8]
   \   0000010A   0x6041             STR      R1,[R0, #+4]
   \   0000010C   0xE790             B.N      ??LPLD_DAC_Config_1
   \                     ??LPLD_DAC_Config_12:
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0xE087             B.N      ??LPLD_DAC_Config_13
   \                     ??LPLD_DAC_Config_2:
   \   00000112   0x79E0             LDRB     R0,[R4, #+7]
   \   00000114   0x2801             CMP      R0,#+1
   \   00000116   0xD106             BNE.N    ??LPLD_DAC_Config_14
   \   00000118   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   0000011C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000120   0xF885 0x0021      STRB     R0,[R5, #+33]
   \   00000124   0xE79C             B.N      ??LPLD_DAC_Config_3
   \                     ??LPLD_DAC_Config_14:
   \   00000126   0x79E0             LDRB     R0,[R4, #+7]
   \   00000128   0x2802             CMP      R0,#+2
   \   0000012A   0xD106             BNE.N    ??LPLD_DAC_Config_15
   \   0000012C   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   00000130   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000134   0xF885 0x0021      STRB     R0,[R5, #+33]
   \   00000138   0xE792             B.N      ??LPLD_DAC_Config_3
   \                     ??LPLD_DAC_Config_15:
   \   0000013A   0x79E0             LDRB     R0,[R4, #+7]
   \   0000013C   0x2803             CMP      R0,#+3
   \   0000013E   0xD106             BNE.N    ??LPLD_DAC_Config_16
   \   00000140   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   00000144   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000148   0xF885 0x0021      STRB     R0,[R5, #+33]
   \   0000014C   0xE788             B.N      ??LPLD_DAC_Config_3
   \                     ??LPLD_DAC_Config_16:
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xE067             B.N      ??LPLD_DAC_Config_13
   \                     ??LPLD_DAC_Config_4:
   \   00000152   0x7920             LDRB     R0,[R4, #+4]
   \   00000154   0x2801             CMP      R0,#+1
   \   00000156   0xD10C             BNE.N    ??LPLD_DAC_Config_17
   \   00000158   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   0000015C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000160   0xF885 0x0021      STRB     R0,[R5, #+33]
   \   00000164   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   00000168   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000016C   0xF885 0x0021      STRB     R0,[R5, #+33]
   \   00000170   0xE78B             B.N      ??LPLD_DAC_Config_5
   \                     ??LPLD_DAC_Config_17:
   \   00000172   0x7920             LDRB     R0,[R4, #+4]
   \   00000174   0x2802             CMP      R0,#+2
   \   00000176   0xD10C             BNE.N    ??LPLD_DAC_Config_18
   \   00000178   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   0000017C   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000180   0xF885 0x0021      STRB     R0,[R5, #+33]
   \   00000184   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   00000188   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   0000018C   0xF885 0x0021      STRB     R0,[R5, #+33]
   \   00000190   0xE77B             B.N      ??LPLD_DAC_Config_5
   \                     ??LPLD_DAC_Config_18:
   \   00000192   0x2000             MOVS     R0,#+0
   \   00000194   0xE045             B.N      ??LPLD_DAC_Config_13
   \                     ??LPLD_DAC_Config_6:
   \   00000196   0x7860             LDRB     R0,[R4, #+1]
   \   00000198   0x2801             CMP      R0,#+1
   \   0000019A   0xD106             BNE.N    ??LPLD_DAC_Config_19
   \   0000019C   0xF895 0x0022      LDRB     R0,[R5, #+34]
   \   000001A0   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000001A4   0xF885 0x0022      STRB     R0,[R5, #+34]
   \   000001A8   0xE78B             B.N      ??LPLD_DAC_Config_7
   \                     ??LPLD_DAC_Config_19:
   \   000001AA   0x7860             LDRB     R0,[R4, #+1]
   \   000001AC   0x2802             CMP      R0,#+2
   \   000001AE   0xD106             BNE.N    ??LPLD_DAC_Config_20
   \   000001B0   0xF895 0x0022      LDRB     R0,[R5, #+34]
   \   000001B4   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000001B8   0xF885 0x0022      STRB     R0,[R5, #+34]
   \   000001BC   0xE781             B.N      ??LPLD_DAC_Config_7
   \                     ??LPLD_DAC_Config_20:
   \   000001BE   0x7860             LDRB     R0,[R4, #+1]
   \   000001C0   0x2803             CMP      R0,#+3
   \   000001C2   0xD106             BNE.N    ??LPLD_DAC_Config_21
   \   000001C4   0xF895 0x0022      LDRB     R0,[R5, #+34]
   \   000001C8   0xF050 0x0018      ORRS     R0,R0,#0x18
   \   000001CC   0xF885 0x0022      STRB     R0,[R5, #+34]
   \   000001D0   0xE777             B.N      ??LPLD_DAC_Config_7
   \                     ??LPLD_DAC_Config_21:
   \   000001D2   0x2000             MOVS     R0,#+0
   \   000001D4   0xE025             B.N      ??LPLD_DAC_Config_13
   \                     ??LPLD_DAC_Config_8:
   \   000001D6   0x78E0             LDRB     R0,[R4, #+3]
   \   000001D8   0x2801             CMP      R0,#+1
   \   000001DA   0xD106             BNE.N    ??LPLD_DAC_Config_22
   \   000001DC   0xF895 0x0022      LDRB     R0,[R5, #+34]
   \   000001E0   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000001E4   0xF885 0x0022      STRB     R0,[R5, #+34]
   \   000001E8   0xE773             B.N      ??LPLD_DAC_Config_9
   \                     ??LPLD_DAC_Config_22:
   \   000001EA   0x78E0             LDRB     R0,[R4, #+3]
   \   000001EC   0x2802             CMP      R0,#+2
   \   000001EE   0xD106             BNE.N    ??LPLD_DAC_Config_23
   \   000001F0   0xF895 0x0022      LDRB     R0,[R5, #+34]
   \   000001F4   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000001F8   0xF885 0x0022      STRB     R0,[R5, #+34]
   \   000001FC   0xE769             B.N      ??LPLD_DAC_Config_9
   \                     ??LPLD_DAC_Config_23:
   \   000001FE   0x2000             MOVS     R0,#+0
   \   00000200   0xE00F             B.N      ??LPLD_DAC_Config_13
    342            else
    343            {
    344              DAC_C1_REG(dacptr) &= (~DAC_C1_DACBFEN_MASK);
   \                     ??LPLD_DAC_Config_10:
   \   00000202   0xF895 0x0022      LDRB     R0,[R5, #+34]
   \   00000206   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000020A   0xF885 0x0022      STRB     R0,[R5, #+34]
    345            }
    346            //===========DAC_C1配置完毕====================//  
    347              
    348            //===========配置DAC_C2寄存器=================//
    349            //设置Buffer上限 
    350            DAC_C2_REG(dacptr) = DAC_C2_DACBFUP((DAC_Config->Buffer_Up_Limit & 0x0f)); 
   \                     ??LPLD_DAC_Config_11:
   \   0000020E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000210   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000214   0xF885 0x0023      STRB     R0,[R5, #+35]
    351            //设置Buffer指针位置
    352            DAC_C2_REG(dacptr) |=DAC_C2_DACBFRP((DAC_Config->Buffer_Init_Pos & 0xf0));
   \   00000218   0xF895 0x0023      LDRB     R0,[R5, #+35]
   \   0000021C   0xF885 0x0023      STRB     R0,[R5, #+35]
    353            //===========DAC_C2配置完毕====================//  
    354            
    355            return 1;
   \   00000220   0x2001             MOVS     R0,#+1
   \                     ??LPLD_DAC_Config_13:
   \   00000222   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    356          }
    357          
    358          
    359          /*
    360           * LPLD_DAC_Soft_Trig
    361           * 设置软件触发信号
    362           * 
    363           * 参数:
    364           *    dacx--DAC模块号
    365           *      |__DAC0           --DAC0模块
    366           *      |__DAC1           --DAC1模块
    367           * 输出：
    368           *    无
    369           */

   \                                 In section .text, align 2, keep-with-next
    370          void LPLD_DAC_Soft_Trig(DACx dacx)
    371          {
    372            DAC_MemMapPtr dacptr = DACx_Ptr[dacx];
   \                     LPLD_DAC_Soft_Trig:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R1,??DataTable4
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
    373            DAC_C0_REG(dacptr) |= DAC_C0_DACSWTRG_MASK;
   \   00000008   0xF890 0x1021      LDRB     R1,[R0, #+33]
   \   0000000C   0xF051 0x0110      ORRS     R1,R1,#0x10
   \   00000010   0xF880 0x1021      STRB     R1,[R0, #+33]
    374          }
   \   00000014   0x4770             BX       LR               ;; return
    375          
    376          /*
    377           * LPLD_DAC_Isr
    378           * DAC通用中断底层入口函数
    379           * 
    380           * 用户无需修改，程序自动进入对应通道中断函数
    381           */

   \                                 In section .text, align 2, keep-with-next
    382          void LPLD_DAC_Isr(void)
    383          {
   \                     LPLD_DAC_Isr:
   \   00000000   0xB510             PUSH     {R4,LR}
    384            #define DAC_VECTORNUM   (*(volatile uint8*)(0xE000ED04))
    385            uint8 dac_ch = DAC_VECTORNUM - 97;
   \   00000002   0x....             LDR.N    R0,??DataTable4_5  ;; 0xe000ed04
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x3861             SUBS     R0,R0,#+97
    386            DAC_MemMapPtr DACx_Base_Ptr = (DAC_MemMapPtr)((0x400CC+dac_ch)<<12);
   \   00000008   0x....             LDR.N    R1,??DataTable4_6  ;; 0x400cc
   \   0000000A   0xFA51 0xF180      UXTAB    R1,R1,R0
   \   0000000E   0x030C             LSLS     R4,R1,#+12
    387            
    388            if ((DAC_SR_REG(DACx_Base_Ptr)&DAC_SR_DACBFRPBF_MASK) ) 
   \   00000010   0xF894 0x1020      LDRB     R1,[R4, #+32]
   \   00000014   0x07C9             LSLS     R1,R1,#+31
   \   00000016   0xD508             BPL.N    ??LPLD_DAC_Isr_0
    389            {
    390              DAC_ISR[dac_ch]();
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x....             LDR.N    R1,??DataTable4_3
   \   0000001C   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000020   0x4780             BLX      R0
    391              DAC_SR_REG(DACx_Base_Ptr)=0x06; //清除中断标志位
   \   00000022   0x2006             MOVS     R0,#+6
   \   00000024   0xF884 0x0020      STRB     R0,[R4, #+32]
   \   00000028   0xE018             B.N      ??LPLD_DAC_Isr_1
    392            }
    393            else if ((DAC_SR_REG(DACx_Base_Ptr)&DAC_SR_DACBFRPTF_MASK))
   \                     ??LPLD_DAC_Isr_0:
   \   0000002A   0xF894 0x1020      LDRB     R1,[R4, #+32]
   \   0000002E   0x0789             LSLS     R1,R1,#+30
   \   00000030   0xD508             BPL.N    ??LPLD_DAC_Isr_2
    394            {
    395              DAC_ISR[dac_ch]();
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x....             LDR.N    R1,??DataTable4_3
   \   00000036   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000003A   0x4780             BLX      R0
    396              DAC_SR_REG(DACx_Base_Ptr)=0x05 ;//清除中断标志位
   \   0000003C   0x2005             MOVS     R0,#+5
   \   0000003E   0xF884 0x0020      STRB     R0,[R4, #+32]
   \   00000042   0xE00B             B.N      ??LPLD_DAC_Isr_1
    397            }
    398            else if ((DAC_SR_REG(DACx_Base_Ptr)&DAC_SR_DACBFWMF_MASK))
   \                     ??LPLD_DAC_Isr_2:
   \   00000044   0xF894 0x1020      LDRB     R1,[R4, #+32]
   \   00000048   0x0749             LSLS     R1,R1,#+29
   \   0000004A   0xD507             BPL.N    ??LPLD_DAC_Isr_1
    399            {
    400              DAC_ISR[dac_ch]();
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x....             LDR.N    R1,??DataTable4_3
   \   00000050   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000054   0x4780             BLX      R0
    401              DAC_SR_REG(DACx_Base_Ptr)=0x03 ;//清除中断标志位
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0xF884 0x0020      STRB     R0,[R4, #+32]
    402            }
    403          }
   \                     ??LPLD_DAC_Isr_1:
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     DACx_Ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x400CC000         DC32     0x400cc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x4004802C         DC32     0x4004802c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     DAC_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x400CD000         DC32     0x400cd000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x000400CC         DC32     0x400cc

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  LPLD_DAC_Config
             16 -> enable_irq
        8  LPLD_DAC_Init
              8 -> LPLD_DAC_Config
        8  LPLD_DAC_Isr
              8 -- Indirect call
       16  LPLD_DAC_Reset_Reg
             16 -> LPLD_DAC_Set_Buffer
        0  LPLD_DAC_Set_Buffer
        0  LPLD_DAC_Soft_Trig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       8  DAC_ISR
       8  DACx_Ptr
     548  LPLD_DAC_Config
      88  LPLD_DAC_Init
      94  LPLD_DAC_Isr
      64  LPLD_DAC_Reset_Reg
      32  LPLD_DAC_Set_Buffer
      22  LPLD_DAC_Soft_Trig

 
   8 bytes in section .bss
   8 bytes in section .data
 876 bytes in section .text
 
 876 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
