###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     06/Jul/2014  14:13:47 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\robot _init\robot\lib\LPLD\FatFs\ff.c                 #
#    Command line =  "F:\robot _init\robot\lib\LPLD\FatFs\ff.c" -D IAR -D     #
#                    LPLD_K60 -lCN "F:\robot _init\robot\project\robot_car_co #
#                    m\iar\FLASH\List\" -lB "F:\robot                         #
#                    _init\robot\project\robot_car_com\iar\FLASH\List\" -o    #
#                    "F:\robot _init\robot\project\robot_car_com\iar\FLASH\Ob #
#                    j\" --no_cse --no_unroll --no_inline --no_code_motion    #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M4 -e --fpu=None            #
#                    --dlib_config "D:\IAR Systems\Embedded Workbench         #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I "F:\robot         #
#                    _init\robot\project\robot_car_com\iar\..\app\" -I        #
#                    "F:\robot _init\robot\project\robot_car_com\iar\..\..\.. #
#                    \lib\common\" -I "F:\robot _init\robot\project\robot_car #
#                    _com\iar\..\..\..\lib\cpu\" -I "F:\robot                 #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\cpu\h #
#                    eaders\" -I "F:\robot _init\robot\project\robot_car_com\ #
#                    iar\..\..\..\lib\drivers\adc16\" -I "F:\robot            #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\enet\" -I "F:\robot _init\robot\project\robot_car_com #
#                    \iar\..\..\..\lib\drivers\lptmr\" -I "F:\robot           #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\mcg\" -I "F:\robot _init\robot\project\robot_car_com\ #
#                    iar\..\..\..\lib\drivers\pmc\" -I "F:\robot              #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\rtc\" -I "F:\robot _init\robot\project\robot_car_com\ #
#                    iar\..\..\..\lib\drivers\uart\" -I "F:\robot             #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\drive #
#                    rs\wdog\" -I "F:\robot _init\robot\project\robot_car_com #
#                    \iar\..\..\..\lib\platforms\" -I "F:\robot               #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\LPLD\ #
#                    " -I "F:\robot _init\robot\project\robot_car_com\iar\..\ #
#                    ..\..\lib\LPLD\FatFs\" -I "F:\robot                      #
#                    _init\robot\project\robot_car_com\iar\..\..\..\lib\LPLD\ #
#                    USB\" -I "F:\robot _init\robot\project\robot_car_com\iar #
#                    \..\..\..\lib\iar_config_files\" -Ol                     #
#    List file    =  F:\robot _init\robot\project\robot_car_com\iar\FLASH\Lis #
#                    t\ff.lst                                                 #
#    Object file  =  F:\robot _init\robot\project\robot_car_com\iar\FLASH\Obj #
#                    \ff.o                                                    #
#                                                                             #
#                                                                             #
###############################################################################

F:\robot _init\robot\lib\LPLD\FatFs\ff.c
      1          /*
      2          
      3            LPLD K60底层驱动文件系统采用FatFs开源工程，仅对磁盘系统底层函数调用进行了修改。
      4          
      5          */
      6          /*----------------------------------------------------------------------------/
      7          /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
      8          /-----------------------------------------------------------------------------/
      9          / FatFs module is a generic FAT file system module for small embedded systems.
     10          / This is a free software that opened for education, research and commercial
     11          / developments under license policy of following terms.
     12          /
     13          /  Copyright (C) 2011, ChaN, all right reserved.
     14          /
     15          / * The FatFs module is a free software and there is NO WARRANTY.
     16          / * No restriction on use. You can use, modify and redistribute it for
     17          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     18          / * Redistributions of source code must retain the above copyright notice.
     19          /
     20          /-----------------------------------------------------------------------------/
     21          / Feb 26,'06 R0.00  Prototype.
     22          /
     23          / Apr 29,'06 R0.01  First stable version.
     24          /
     25          / Jun 01,'06 R0.02  Added FAT12 support.
     26          /                   Removed unbuffered mode.
     27          /                   Fixed a problem on small (<32M) partition.
     28          / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
     29          /
     30          / Sep 22,'06 R0.03  Added f_rename().
     31          /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
     32          / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
     33          /                   Fixed f_mkdir() creates incorrect directory on FAT32.
     34          /
     35          / Feb 04,'07 R0.04  Supported multiple drive system.
     36          /                   Changed some interfaces for multiple drive system.
     37          /                   Changed f_mountdrv() to f_mount().
     38          /                   Added f_mkfs().
     39          / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
     40          /                   Added a capability of extending file size to f_lseek().
     41          /                   Added minimization level 3.
     42          /                   Fixed an endian sensitive code in f_mkfs().
     43          / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
     44          /                   Added FSInfo support.
     45          /                   Fixed DBCS name can result FR_INVALID_NAME.
     46          /                   Fixed short seek (<= csize) collapses the file object.
     47          /
     48          / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
     49          /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
     50          /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
     51          / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
     52          /                   Fixed off by one error at FAT sub-type determination.
     53          /                   Fixed btr in f_read() can be mistruncated.
     54          /                   Fixed cached sector is not flushed when create and close without write.
     55          /
     56          / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
     57          /                   Improved performance of f_lseek() on moving to the same or following cluster.
     58          /
     59          / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
     60          /                   Added long file name feature.
     61          /                   Added multiple code page feature.
     62          /                   Added re-entrancy for multitask operation.
     63          /                   Added auto cluster size selection to f_mkfs().
     64          /                   Added rewind option to f_readdir().
     65          /                   Changed result code of critical errors.
     66          /                   Renamed string functions to avoid name collision.
     67          / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
     68          /                   Added multiple sector size feature.
     69          / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
     70          /                   Fixed wrong cache control in f_lseek().
     71          /                   Added relative path feature.
     72          /                   Added f_chdir() and f_chdrive().
     73          /                   Added proper case conversion to extended char.
     74          / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
     75          /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
     76          /                   Fixed name matching error on the 13 char boundary.
     77          /                   Added a configuration option, _LFN_UNICODE.
     78          /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
     79          /
     80          / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
     81          /                   Added file lock feature. (_FS_SHARE)
     82          /                   Added fast seek feature. (_USE_FASTSEEK)
     83          /                   Changed some types on the API, XCHAR->TCHAR.
     84          /                   Changed fname member in the FILINFO structure on Unicode cfg.
     85          /                   String functions support UTF-8 encoding files on Unicode cfg.
     86          / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
     87          /                   Added sector erase feature. (_USE_ERASE)
     88          /                   Moved file lock semaphore table from fs object to the bss.
     89          /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
     90          /                   Fixed f_mkfs() creates wrong FAT32 volume.
     91          / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
     92          /                   f_lseek() reports required table size on creating CLMP.
     93          /                   Extended format syntax of f_printf function.
     94          /                   Ignores duplicated directory separators in given path names.
     95          /
     96          / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
     97          /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
     98          /---------------------------------------------------------------------------*/
     99          
    100          #include "ff.h"			/* FatFs configurations and declarations */
    101          #include "../FML_DiskIO.h"		/* Declarations of low level disk I/O functions */
    102          
    103          
    104          /*--------------------------------------------------------------------------
    105          
    106             Module Private Definitions
    107          
    108          ---------------------------------------------------------------------------*/
    109          
    110          #if _FATFS != 6502	/* Revision ID */
    111          #error Wrong include file (ff.h).
    112          #endif
    113          
    114          
    115          /* Definitions on sector size */
    116          #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
    117          #error Wrong sector size.
    118          #endif
    119          #if _MAX_SS != 512
    120          #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
    121          #else
    122          #define	SS(fs)	512U			/* Fixed sector size */
    123          #endif
    124          
    125          
    126          /* Reentrancy related */
    127          #if _FS_REENTRANT
    128          #if _USE_LFN == 1
    129          #error Static LFN work area must not be used in re-entrant configuration.
    130          #endif
    131          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
    132          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
    133          #else
    134          #define	ENTER_FF(fs)
    135          #define LEAVE_FF(fs, res)	return res
    136          #endif
    137          
    138          #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
    139          
    140          
    141          /* File shareing feature */
    142          #if _FS_SHARE
    143          #if _FS_READONLY
    144          #error _FS_SHARE must be 0 on read-only cfg.
    145          #endif
    146          typedef struct {
    147          	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
    148          	DWORD clu;				/* File ID 2, directory */
    149          	WORD idx;				/* File ID 3, directory index */
    150          	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
    151          } FILESEM;
    152          #endif
    153          
    154          
    155          /* Misc definitions */
    156          #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
    157          #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
    158          
    159          
    160          /* DBCS code ranges and SBCS extend char conversion table */
    161          
    162          #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
    163          #define _DF1S	0x81	/* DBC 1st byte range 1 start */
    164          #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
    165          #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
    166          #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
    167          #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
    168          #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
    169          #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
    170          #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
    171          
    172          #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
    173          #define _DF1S	0x81
    174          #define _DF1E	0xFE
    175          #define _DS1S	0x40
    176          #define _DS1E	0x7E
    177          #define _DS2S	0x80
    178          #define _DS2E	0xFE
    179          
    180          #elif _CODE_PAGE == 949	/* Korean */
    181          #define _DF1S	0x81
    182          #define _DF1E	0xFE
    183          #define _DS1S	0x41
    184          #define _DS1E	0x5A
    185          #define _DS2S	0x61
    186          #define _DS2E	0x7A
    187          #define _DS3S	0x81
    188          #define _DS3E	0xFE
    189          
    190          #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
    191          #define _DF1S	0x81
    192          #define _DF1E	0xFE
    193          #define _DS1S	0x40
    194          #define _DS1E	0x7E
    195          #define _DS2S	0xA1
    196          #define _DS2E	0xFE
    197          
    198          #elif _CODE_PAGE == 437	/* U.S. (OEM) */
    199          #define _DF1S	0
    200          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    201          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    202          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    203          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    204          
    205          #elif _CODE_PAGE == 720	/* Arabic (OEM) */
    206          #define _DF1S	0
    207          #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    208          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    209          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    210          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    211          
    212          #elif _CODE_PAGE == 737	/* Greek (OEM) */
    213          #define _DF1S	0
    214          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
    215          				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    216          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    217          				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    218          
    219          #elif _CODE_PAGE == 775	/* Baltic (OEM) */
    220          #define _DF1S	0
    221          #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    222          				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    223          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    224          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    225          
    226          #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
    227          #define _DF1S	0
    228          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    229          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    230          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    231          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    232          
    233          #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
    234          #define _DF1S	0
    235          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
    236          				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
    237          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    238          				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
    239          
    240          #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
    241          #define _DF1S	0
    242          #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
    243          				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
    244          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
    245          				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
    246          
    247          #elif _CODE_PAGE == 857	/* Turkish (OEM) */
    248          #define _DF1S	0
    249          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
    250          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    251          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    252          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    253          
    254          #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
    255          #define _DF1S	0
    256          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    257          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    258          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    259          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    260          
    261          #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
    262          #define _DF1S	0
    263          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    264          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    265          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    266          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    267          
    268          #elif _CODE_PAGE == 866	/* Russian (OEM) */
    269          #define _DF1S	0
    270          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    271          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    272          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    273          				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    274          
    275          #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
    276          #define _DF1S	0
    277          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    278          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    279          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    280          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    281          
    282          #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
    283          #define _DF1S	0
    284          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    285          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
    286          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    287          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    288          
    289          #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
    290          #define _DF1S	0
    291          #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    292          				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
    293          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    294          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
    295          
    296          #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
    297          #define _DF1S	0
    298          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
    299          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    300          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    301          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    302          
    303          #elif _CODE_PAGE == 1253 /* Greek (Windows) */
    304          #define _DF1S	0
    305          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    306          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    307          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
    308          				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
    309          
    310          #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
    311          #define _DF1S	0
    312          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    313          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    314          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    315          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    316          
    317          #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
    318          #define _DF1S	0
    319          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    320          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    321          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    322          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    323          
    324          #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
    325          #define _DF1S	0
    326          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    327          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    328          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    329          				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
    330          
    331          #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
    332          #define _DF1S	0
    333          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    334          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
    335          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    336          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    337          
    338          #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
    339          #define _DF1S	0
    340          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
    341          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    342          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    343          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
    344          
    345          #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
    346          #if _USE_LFN
    347          #error Cannot use LFN feature without valid code page.
    348          #endif
    349          #define _DF1S	0
    350          
    351          #else
    352          #error Unknown code page
    353          
    354          #endif
    355          
    356          
    357          /* Character code support macros */
    358          #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
    359          #define IsLower(c)	(((c)>='a')&&((c)<='z'))
    360          #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
    361          
    362          #if _DF1S		/* Code page is DBCS */
    363          
    364          #ifdef _DF2S	/* Two 1st byte areas */
    365          #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
    366          #else			/* One 1st byte area */
    367          #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
    368          #endif
    369          
    370          #ifdef _DS3S	/* Three 2nd byte areas */
    371          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
    372          #else			/* Two 2nd byte areas */
    373          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
    374          #endif
    375          
    376          #else			/* Code page is SBCS */
    377          
    378          #define IsDBCS1(c)	0
    379          #define IsDBCS2(c)	0
    380          
    381          #endif /* _DF1S */
    382          
    383          
    384          /* Name status flags */
    385          #define NS			11		/* Index of name status byte in fn[] */
    386          #define NS_LOSS		0x01	/* Out of 8.3 format */
    387          #define NS_LFN		0x02	/* Force to create LFN entry */
    388          #define NS_LAST		0x04	/* Last segment */
    389          #define NS_BODY		0x08	/* Lower case flag (body) */
    390          #define NS_EXT		0x10	/* Lower case flag (ext) */
    391          #define NS_DOT		0x20	/* Dot entry */
    392          
    393          
    394          /* FAT sub-type boundaries */
    395          /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
    396          #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
    397          #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
    398          
    399          
    400          /* FatFs refers the members in the FAT structures as byte array instead of
    401          / structure member because the structure is not binary compatible between
    402          / different platforms */
    403          
    404          #define BS_jmpBoot			0	/* Jump instruction (3) */
    405          #define BS_OEMName			3	/* OEM name (8) */
    406          #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
    407          #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
    408          #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
    409          #define BPB_NumFATs			16	/* Number of FAT copies (1) */
    410          #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
    411          #define BPB_TotSec16		19	/* Volume size [sector] (2) */
    412          #define BPB_Media			21	/* Media descriptor (1) */
    413          #define BPB_FATSz16			22	/* FAT size [sector] (2) */
    414          #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
    415          #define BPB_NumHeads		26	/* Number of heads (2) */
    416          #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
    417          #define BPB_TotSec32		32	/* Volume size [sector] (4) */
    418          #define BS_DrvNum			36	/* Physical drive number (2) */
    419          #define BS_BootSig			38	/* Extended boot signature (1) */
    420          #define BS_VolID			39	/* Volume serial number (4) */
    421          #define BS_VolLab			43	/* Volume label (8) */
    422          #define BS_FilSysType		54	/* File system type (1) */
    423          #define BPB_FATSz32			36	/* FAT size [sector] (4) */
    424          #define BPB_ExtFlags		40	/* Extended flags (2) */
    425          #define BPB_FSVer			42	/* File system version (2) */
    426          #define BPB_RootClus		44	/* Root dir first cluster (4) */
    427          #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
    428          #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
    429          #define BS_DrvNum32			64	/* Physical drive number (2) */
    430          #define BS_BootSig32		66	/* Extended boot signature (1) */
    431          #define BS_VolID32			67	/* Volume serial number (4) */
    432          #define BS_VolLab32			71	/* Volume label (8) */
    433          #define BS_FilSysType32		82	/* File system type (1) */
    434          #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
    435          #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
    436          #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
    437          #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
    438          #define MBR_Table			446	/* MBR: Partition table offset (2) */
    439          #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
    440          #define BS_55AA				510	/* Boot sector signature (2) */
    441          
    442          #define	DIR_Name			0	/* Short file name (11) */
    443          #define	DIR_Attr			11	/* Attribute (1) */
    444          #define	DIR_NTres			12	/* NT flag (1) */
    445          #define	DIR_CrtTime			14	/* Created time (2) */
    446          #define	DIR_CrtDate			16	/* Created date (2) */
    447          #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
    448          #define	DIR_WrtTime			22	/* Modified time (2) */
    449          #define	DIR_WrtDate			24	/* Modified date (2) */
    450          #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
    451          #define	DIR_FileSize		28	/* File size (4) */
    452          #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
    453          #define	LDIR_Attr			11	/* LFN attribute (1) */
    454          #define	LDIR_Type			12	/* LFN type (1) */
    455          #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
    456          #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
    457          #define	SZ_DIR				32		/* Size of a directory entry */
    458          #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
    459          #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
    460          #define	NDDE				0x05	/* Replacement of a character collides with DDE */
    461          
    462          
    463          /*------------------------------------------------------------*/
    464          /* Module private work area                                   */
    465          /*------------------------------------------------------------*/
    466          /* Note that uninitialized variables with static duration are
    467          /  zeroed/nulled at start-up. If not, the compiler or start-up
    468          /  routine is out of ANSI-C standard.
    469          */
    470          
    471          #if _VOLUMES
    472          static

   \                                 In section .bss, align 4
    473          FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
   \                     FatFs:
   \   00000000                      DS8 4
    474          #else
    475          #error Number of volumes must not be 0.
    476          #endif
    477          
    478          static

   \                                 In section .bss, align 2
    479          WORD Fsid;				/* File system mount ID */
   \                     Fsid:
   \   00000000                      DS8 2
    480          
    481          #if _FS_RPATH
    482          static

   \                                 In section .bss, align 1
    483          BYTE CurrVol;			/* Current drive */
   \                     CurrVol:
   \   00000000                      DS8 1
    484          #endif
    485          
    486          #if _FS_SHARE
    487          static

   \                                 In section .bss, align 4
    488          FILESEM	Files[_FS_SHARE];	/* File lock semaphores */
   \                     Files:
   \   00000000                      DS8 96
    489          #endif
    490          
    491          #if _USE_LFN == 0			/* No LFN feature */
    492          #define	DEF_NAMEBUF			BYTE sfn[12]
    493          #define INIT_BUF(dobj)		(dobj).fn = sfn
    494          #define	FREE_BUF()
    495          
    496          #elif _USE_LFN == 1			/* LFN feature with static working buffer */
    497          static WCHAR LfnBuf[_MAX_LFN+1];
    498          #define	DEF_NAMEBUF			BYTE sfn[12]
    499          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
    500          #define	FREE_BUF()
    501          
    502          #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
    503          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
    504          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
    505          #define	FREE_BUF()
    506          
    507          #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
    508          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
    509          #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
    510          							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
    511          							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
    512          #define	FREE_BUF()			ff_memfree(lfn)
    513          
    514          #else
    515          #error Wrong LFN configuration.
    516          #endif
    517          
    518          
    519          
    520          
    521          /*--------------------------------------------------------------------------
    522          
    523             Module Private Functions
    524          
    525          ---------------------------------------------------------------------------*/
    526          
    527          
    528          /*-----------------------------------------------------------------------*/
    529          /* String functions                                                      */
    530          /*-----------------------------------------------------------------------*/
    531          
    532          /* Copy memory to memory */

   \                                 In section .text, align 2, keep-with-next
    533          static
    534          void mem_cpy (void* dst, const void* src, UINT cnt) {
    535          	BYTE *d = (BYTE*)dst;
    536          	const BYTE *s = (const BYTE*)src;
   \                     mem_cpy:
   \   00000000   0xE003             B.N      ??mem_cpy_0
    537          
    538          #if _WORD_ACCESS == 1
    539          	while (cnt >= sizeof(int)) {
    540          		*(int*)d = *(int*)s;
    541          		d += sizeof(int); s += sizeof(int);
    542          		cnt -= sizeof(int);
    543          	}
    544          #endif
    545          	while (cnt--)
    546          		*d++ = *s++;
   \                     ??mem_cpy_1:
   \   00000002   0x780B             LDRB     R3,[R1, #+0]
   \   00000004   0x7003             STRB     R3,[R0, #+0]
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \                     ??mem_cpy_0:
   \   0000000A   0x0013             MOVS     R3,R2
   \   0000000C   0x1E5A             SUBS     R2,R3,#+1
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD1F7             BNE.N    ??mem_cpy_1
    547          }
   \   00000012   0x4770             BX       LR               ;; return
    548          
    549          /* Fill memory */

   \                                 In section .text, align 2, keep-with-next
    550          static
    551          void mem_set (void* dst, int val, UINT cnt) {
    552          	BYTE *d = (BYTE*)dst;
   \                     mem_set:
   \   00000000   0xE001             B.N      ??mem_set_0
    553          
    554          	while (cnt--)
    555          		*d++ = (BYTE)val;
   \                     ??mem_set_1:
   \   00000002   0x7001             STRB     R1,[R0, #+0]
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \                     ??mem_set_0:
   \   00000006   0x0013             MOVS     R3,R2
   \   00000008   0x1E5A             SUBS     R2,R3,#+1
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD1F9             BNE.N    ??mem_set_1
    556          }
   \   0000000E   0x4770             BX       LR               ;; return
    557          
    558          /* Compare memory to memory */

   \                                 In section .text, align 2, keep-with-next
    559          static
    560          int mem_cmp (const void* dst, const void* src, UINT cnt) {
   \                     mem_cmp:
   \   00000000   0xB410             PUSH     {R4}
    561          	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    562          	int r = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    563          
    564          	while (cnt-- && (r = *d++ - *s++) == 0) ;
   \                     ??mem_cmp_0:
   \   00000004   0x0014             MOVS     R4,R2
   \   00000006   0x1E62             SUBS     R2,R4,#+1
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD006             BEQ.N    ??mem_cmp_1
   \   0000000C   0x7803             LDRB     R3,[R0, #+0]
   \   0000000E   0x780C             LDRB     R4,[R1, #+0]
   \   00000010   0x1B1B             SUBS     R3,R3,R4
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x2B00             CMP      R3,#+0
   \   00000018   0xD0F4             BEQ.N    ??mem_cmp_0
    565          	return r;
   \                     ??mem_cmp_1:
   \   0000001A   0x0018             MOVS     R0,R3
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
    566          }
    567          
    568          /* Check if chr is contained in the string */

   \                                 In section .text, align 2, keep-with-next
    569          static
    570          int chk_chr (const char* str, int chr) {
   \                     chk_chr:
   \   00000000   0xE000             B.N      ??chk_chr_0
    571          	while (*str && *str != chr) str++;
   \                     ??chk_chr_1:
   \   00000002   0x1C40             ADDS     R0,R0,#+1
   \                     ??chk_chr_0:
   \   00000004   0x7802             LDRB     R2,[R0, #+0]
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD002             BEQ.N    ??chk_chr_2
   \   0000000A   0x7802             LDRB     R2,[R0, #+0]
   \   0000000C   0x428A             CMP      R2,R1
   \   0000000E   0xD1F8             BNE.N    ??chk_chr_1
    572          	return *str;
   \                     ??chk_chr_2:
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x4770             BX       LR               ;; return
    573          }
    574          
    575          
    576          
    577          /*-----------------------------------------------------------------------*/
    578          /* Request/Release grant to access the volume                            */
    579          /*-----------------------------------------------------------------------*/
    580          #if _FS_REENTRANT
    581          
    582          static
    583          int lock_fs (
    584          	FATFS *fs		/* File system object */
    585          )
    586          {
    587          	return ff_req_grant(fs->sobj);
    588          }
    589          
    590          
    591          static
    592          void unlock_fs (
    593          	FATFS *fs,		/* File system object */
    594          	FRESULT res		/* Result code to be returned */
    595          )
    596          {
    597          	if (res != FR_NOT_ENABLED &&
    598          		res != FR_INVALID_DRIVE &&
    599          		res != FR_INVALID_OBJECT &&
    600          		res != FR_TIMEOUT) {
    601          		ff_rel_grant(fs->sobj);
    602          	}
    603          }
    604          #endif
    605          
    606          
    607          
    608          /*-----------------------------------------------------------------------*/
    609          /* File shareing control functions                                       */
    610          /*-----------------------------------------------------------------------*/
    611          #if _FS_SHARE
    612          

   \                                 In section .text, align 2, keep-with-next
    613          static
    614          FRESULT chk_lock (	/* Check if the file can be accessed */
    615          	DIR* dj,		/* Directory object pointing the file to be checked */
    616          	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
    617          )
    618          {
   \                     chk_lock:
   \   00000000   0xB430             PUSH     {R4,R5}
    619          	UINT i, be;
    620          
    621          	/* Search file semaphore table */
    622          	for (i = be = 0; i < _FS_SHARE; i++) {
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x001A             MOVS     R2,R3
   \   00000006   0xE001             B.N      ??chk_lock_0
    623          		if (Files[i].fs) {	/* Existing entry */
    624          			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
    625          				Files[i].clu == dj->sclust &&
    626          				Files[i].idx == dj->index) break;
    627          		} else {			/* Blank entry */
    628          			be++;
   \                     ??chk_lock_1:
   \   00000008   0x1C52             ADDS     R2,R2,#+1
    629          		}
   \                     ??chk_lock_2:
   \   0000000A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??chk_lock_0:
   \   0000000C   0x2B08             CMP      R3,#+8
   \   0000000E   0xD222             BCS.N    ??chk_lock_3
   \   00000010   0x240C             MOVS     R4,#+12
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable7
   \   00000016   0xFB04 0x5403      MLA      R4,R4,R3,R5
   \   0000001A   0x6824             LDR      R4,[R4, #+0]
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD0F3             BEQ.N    ??chk_lock_1
   \   00000020   0x240C             MOVS     R4,#+12
   \   00000022   0x.... 0x....      LDR.W    R5,??DataTable7
   \   00000026   0xFB04 0x5403      MLA      R4,R4,R3,R5
   \   0000002A   0x6824             LDR      R4,[R4, #+0]
   \   0000002C   0x6805             LDR      R5,[R0, #+0]
   \   0000002E   0x42AC             CMP      R4,R5
   \   00000030   0xD1EB             BNE.N    ??chk_lock_2
   \   00000032   0x240C             MOVS     R4,#+12
   \   00000034   0x.... 0x....      LDR.W    R5,??DataTable7
   \   00000038   0xFB04 0x5403      MLA      R4,R4,R3,R5
   \   0000003C   0x6864             LDR      R4,[R4, #+4]
   \   0000003E   0x6885             LDR      R5,[R0, #+8]
   \   00000040   0x42AC             CMP      R4,R5
   \   00000042   0xD1E2             BNE.N    ??chk_lock_2
   \   00000044   0x240C             MOVS     R4,#+12
   \   00000046   0x.... 0x....      LDR.W    R5,??DataTable7
   \   0000004A   0xFB04 0x5403      MLA      R4,R4,R3,R5
   \   0000004E   0x8924             LDRH     R4,[R4, #+8]
   \   00000050   0x88C5             LDRH     R5,[R0, #+6]
   \   00000052   0x42AC             CMP      R4,R5
   \   00000054   0xD1D9             BNE.N    ??chk_lock_2
    630          	}
    631          	if (i == _FS_SHARE)	/* The file is not opened */
   \                     ??chk_lock_3:
   \   00000056   0x2B08             CMP      R3,#+8
   \   00000058   0xD108             BNE.N    ??chk_lock_4
    632          		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
   \   0000005A   0x2A00             CMP      R2,#+0
   \   0000005C   0xD101             BNE.N    ??chk_lock_5
   \   0000005E   0x2902             CMP      R1,#+2
   \   00000060   0xD101             BNE.N    ??chk_lock_6
   \                     ??chk_lock_5:
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE000             B.N      ??chk_lock_7
   \                     ??chk_lock_6:
   \   00000066   0x2012             MOVS     R0,#+18
   \                     ??chk_lock_7:
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xE00E             B.N      ??chk_lock_8
    633          
    634          	/* The file has been opened. Reject any open against writing file and all write mode open */
    635          	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
   \                     ??chk_lock_4:
   \   0000006C   0x2900             CMP      R1,#+0
   \   0000006E   0xD108             BNE.N    ??chk_lock_9
   \   00000070   0x200C             MOVS     R0,#+12
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000076   0xFB00 0x1003      MLA      R0,R0,R3,R1
   \   0000007A   0x8940             LDRH     R0,[R0, #+10]
   \   0000007C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000080   0xD101             BNE.N    ??chk_lock_10
   \                     ??chk_lock_9:
   \   00000082   0x2010             MOVS     R0,#+16
   \   00000084   0xE000             B.N      ??chk_lock_11
   \                     ??chk_lock_10:
   \   00000086   0x2000             MOVS     R0,#+0
   \                     ??chk_lock_11:
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??chk_lock_8:
   \   0000008A   0xBC30             POP      {R4,R5}
   \   0000008C   0x4770             BX       LR               ;; return
    636          }
    637          
    638          

   \                                 In section .text, align 2, keep-with-next
    639          static
    640          int enq_lock (void)	/* Check if an entry is available for a new file */
    641          {
    642          	UINT i;
    643          
    644          	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
   \                     enq_lock:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE000             B.N      ??enq_lock_0
   \                     ??enq_lock_1:
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \                     ??enq_lock_0:
   \   00000006   0x2808             CMP      R0,#+8
   \   00000008   0xD207             BCS.N    ??enq_lock_2
   \   0000000A   0x210C             MOVS     R1,#+12
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable7
   \   00000010   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD1F4             BNE.N    ??enq_lock_1
    645          	return (i == _FS_SHARE) ? 0 : 1;
   \                     ??enq_lock_2:
   \   0000001A   0x2808             CMP      R0,#+8
   \   0000001C   0xD101             BNE.N    ??enq_lock_3
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE000             B.N      ??enq_lock_4
   \                     ??enq_lock_3:
   \   00000022   0x2001             MOVS     R0,#+1
   \                     ??enq_lock_4:
   \   00000024   0x4770             BX       LR               ;; return
    646          }
    647          
    648          

   \                                 In section .text, align 2, keep-with-next
    649          static
    650          UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
    651          	DIR* dj,	/* Directory object pointing the file to register or increment */
    652          	int acc		/* Desired access mode (0:Read, !0:Write) */
    653          )
    654          {
   \                     inc_lock:
   \   00000000   0xB410             PUSH     {R4}
    655          	UINT i;
    656          
    657          
    658          	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xE000             B.N      ??inc_lock_0
   \                     ??inc_lock_1:
   \   00000006   0x1C52             ADDS     R2,R2,#+1
   \                     ??inc_lock_0:
   \   00000008   0x2A08             CMP      R2,#+8
   \   0000000A   0xD21A             BCS.N    ??inc_lock_2
    659          		if (Files[i].fs == dj->fs &&
    660          			Files[i].clu == dj->sclust &&
    661          			Files[i].idx == dj->index) break;
   \   0000000C   0x230C             MOVS     R3,#+12
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable7
   \   00000012   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   00000016   0x681B             LDR      R3,[R3, #+0]
   \   00000018   0x6804             LDR      R4,[R0, #+0]
   \   0000001A   0x42A3             CMP      R3,R4
   \   0000001C   0xD1F3             BNE.N    ??inc_lock_1
   \   0000001E   0x230C             MOVS     R3,#+12
   \   00000020   0x.... 0x....      LDR.W    R4,??DataTable7
   \   00000024   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   00000028   0x685B             LDR      R3,[R3, #+4]
   \   0000002A   0x6884             LDR      R4,[R0, #+8]
   \   0000002C   0x42A3             CMP      R3,R4
   \   0000002E   0xD1EA             BNE.N    ??inc_lock_1
   \   00000030   0x230C             MOVS     R3,#+12
   \   00000032   0x.... 0x....      LDR.W    R4,??DataTable7
   \   00000036   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   0000003A   0x891B             LDRH     R3,[R3, #+8]
   \   0000003C   0x88C4             LDRH     R4,[R0, #+6]
   \   0000003E   0x42A3             CMP      R3,R4
   \   00000040   0xD1E1             BNE.N    ??inc_lock_1
    662          	}
    663          
    664          	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
   \                     ??inc_lock_2:
   \   00000042   0x2A08             CMP      R2,#+8
   \   00000044   0xD12C             BNE.N    ??inc_lock_3
    665          		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0xE000             B.N      ??inc_lock_4
   \                     ??inc_lock_5:
   \   0000004A   0x1C52             ADDS     R2,R2,#+1
   \                     ??inc_lock_4:
   \   0000004C   0x2A08             CMP      R2,#+8
   \   0000004E   0xD207             BCS.N    ??inc_lock_6
   \   00000050   0x230C             MOVS     R3,#+12
   \   00000052   0x.... 0x....      LDR.W    R4,??DataTable7
   \   00000056   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   0000005A   0x681B             LDR      R3,[R3, #+0]
   \   0000005C   0x2B00             CMP      R3,#+0
   \   0000005E   0xD1F4             BNE.N    ??inc_lock_5
    666          		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
   \                     ??inc_lock_6:
   \   00000060   0x2A08             CMP      R2,#+8
   \   00000062   0xD101             BNE.N    ??inc_lock_7
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE03A             B.N      ??inc_lock_8
    667          		Files[i].fs = dj->fs;
   \                     ??inc_lock_7:
   \   00000068   0x230C             MOVS     R3,#+12
   \   0000006A   0x.... 0x....      LDR.W    R4,??DataTable7
   \   0000006E   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   00000072   0x6804             LDR      R4,[R0, #+0]
   \   00000074   0x601C             STR      R4,[R3, #+0]
    668          		Files[i].clu = dj->sclust;
   \   00000076   0x230C             MOVS     R3,#+12
   \   00000078   0x.... 0x....      LDR.W    R4,??DataTable7
   \   0000007C   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   00000080   0x6884             LDR      R4,[R0, #+8]
   \   00000082   0x605C             STR      R4,[R3, #+4]
    669          		Files[i].idx = dj->index;
   \   00000084   0x230C             MOVS     R3,#+12
   \   00000086   0x.... 0x....      LDR.W    R4,??DataTable7
   \   0000008A   0xFB03 0x4302      MLA      R3,R3,R2,R4
   \   0000008E   0x88C0             LDRH     R0,[R0, #+6]
   \   00000090   0x8118             STRH     R0,[R3, #+8]
    670          		Files[i].ctr = 0;
   \   00000092   0x200C             MOVS     R0,#+12
   \   00000094   0x.... 0x....      LDR.W    R3,??DataTable7
   \   00000098   0xFB00 0x3002      MLA      R0,R0,R2,R3
   \   0000009C   0x2300             MOVS     R3,#+0
   \   0000009E   0x8143             STRH     R3,[R0, #+10]
    671          	}
    672          
    673          	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
   \                     ??inc_lock_3:
   \   000000A0   0x2900             CMP      R1,#+0
   \   000000A2   0xD009             BEQ.N    ??inc_lock_9
   \   000000A4   0x200C             MOVS     R0,#+12
   \   000000A6   0x.... 0x....      LDR.W    R3,??DataTable7
   \   000000AA   0xFB00 0x3002      MLA      R0,R0,R2,R3
   \   000000AE   0x8940             LDRH     R0,[R0, #+10]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD001             BEQ.N    ??inc_lock_9
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xE012             B.N      ??inc_lock_8
    674          
    675          	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
   \                     ??inc_lock_9:
   \   000000B8   0x2900             CMP      R1,#+0
   \   000000BA   0xD002             BEQ.N    ??inc_lock_10
   \   000000BC   0xF44F 0x7080      MOV      R0,#+256
   \   000000C0   0xE006             B.N      ??inc_lock_11
   \                     ??inc_lock_10:
   \   000000C2   0x200C             MOVS     R0,#+12
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable7
   \   000000C8   0xFB00 0x1002      MLA      R0,R0,R2,R1
   \   000000CC   0x8940             LDRH     R0,[R0, #+10]
   \   000000CE   0x1C40             ADDS     R0,R0,#+1
   \                     ??inc_lock_11:
   \   000000D0   0x210C             MOVS     R1,#+12
   \   000000D2   0x.... 0x....      LDR.W    R3,??DataTable7
   \   000000D6   0xFB01 0x3102      MLA      R1,R1,R2,R3
   \   000000DA   0x8148             STRH     R0,[R1, #+10]
    676          
    677          	return i + 1;
   \   000000DC   0x1C50             ADDS     R0,R2,#+1
   \                     ??inc_lock_8:
   \   000000DE   0xBC10             POP      {R4}
   \   000000E0   0x4770             BX       LR               ;; return
    678          }
    679          
    680          

   \                                 In section .text, align 2, keep-with-next
    681          static
    682          FRESULT dec_lock (	/* Decrement file open counter */
    683          	UINT i			/* Semaphore index */
    684          )
    685          {
    686          	WORD n;
    687          	FRESULT res;
    688          
    689          
    690          	if (--i < _FS_SHARE) {
   \                     dec_lock:
   \   00000000   0x1E40             SUBS     R0,R0,#+1
   \   00000002   0x2808             CMP      R0,#+8
   \   00000004   0xD220             BCS.N    ??dec_lock_0
    691          		n = Files[i].ctr;
   \   00000006   0x210C             MOVS     R1,#+12
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable7
   \   0000000C   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   00000010   0x8949             LDRH     R1,[R1, #+10]
    692          		if (n == 0x100) n = 0;
   \   00000012   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000014   0xF5B1 0x7F80      CMP      R1,#+256
   \   00000018   0xD100             BNE.N    ??dec_lock_1
   \   0000001A   0x2100             MOVS     R1,#+0
    693          		if (n) n--;
   \                     ??dec_lock_1:
   \   0000001C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD000             BEQ.N    ??dec_lock_2
   \   00000022   0x1E49             SUBS     R1,R1,#+1
    694          		Files[i].ctr = n;
   \                     ??dec_lock_2:
   \   00000024   0x220C             MOVS     R2,#+12
   \   00000026   0x.... 0x....      LDR.W    R3,??DataTable7
   \   0000002A   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   0000002E   0x8151             STRH     R1,[R2, #+10]
    695          		if (!n) Files[i].fs = 0;
   \   00000030   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD106             BNE.N    ??dec_lock_3
   \   00000036   0x210C             MOVS     R1,#+12
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable7
   \   0000003C   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6001             STR      R1,[R0, #+0]
    696          		res = FR_OK;
   \                     ??dec_lock_3:
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE000             B.N      ??dec_lock_4
    697          	} else {
    698          		res = FR_INT_ERR;
   \                     ??dec_lock_0:
   \   00000048   0x2002             MOVS     R0,#+2
    699          	}
    700          	return res;
   \                     ??dec_lock_4:
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x4770             BX       LR               ;; return
    701          }
    702          
    703          

   \                                 In section .text, align 2, keep-with-next
    704          static
    705          void clear_lock (	/* Clear lock entries of the volume */
    706          	FATFS *fs
    707          )
    708          {
    709          	UINT i;
    710          
    711          	for (i = 0; i < _FS_SHARE; i++) {
   \                     clear_lock:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE00F             B.N      ??clear_lock_0
    712          		if (Files[i].fs == fs) Files[i].fs = 0;
   \                     ??clear_lock_1:
   \   00000004   0x220C             MOVS     R2,#+12
   \   00000006   0x.... 0x....      LDR.W    R3,??DataTable7
   \   0000000A   0xFB02 0x3201      MLA      R2,R2,R1,R3
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0x4282             CMP      R2,R0
   \   00000012   0xD106             BNE.N    ??clear_lock_2
   \   00000014   0x220C             MOVS     R2,#+12
   \   00000016   0x.... 0x....      LDR.W    R3,??DataTable7
   \   0000001A   0xFB02 0x3201      MLA      R2,R2,R1,R3
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x6013             STR      R3,[R2, #+0]
    713          	}
   \                     ??clear_lock_2:
   \   00000022   0x1C49             ADDS     R1,R1,#+1
   \                     ??clear_lock_0:
   \   00000024   0x2908             CMP      R1,#+8
   \   00000026   0xD3ED             BCC.N    ??clear_lock_1
    714          }
   \   00000028   0x4770             BX       LR               ;; return
    715          #endif
    716          
    717          
    718          
    719          /*-----------------------------------------------------------------------*/
    720          /* Change window offset                                                  */
    721          /*-----------------------------------------------------------------------*/
    722          

   \                                 In section .text, align 2, keep-with-next
    723          static
    724          FRESULT move_window (
    725          	FATFS *fs,		/* File system object */
    726          	DWORD sector	/* Sector number to make appearance in the fs->win[] */
    727          )					/* Move to zero only writes back dirty window */
    728          {
   \                     move_window:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    729          	DWORD wsect;
    730          
    731          
    732          	wsect = fs->winsect;
   \   00000006   0x6B26             LDR      R6,[R4, #+48]
    733          	if (wsect != sector) {	/* Changed current window */
   \   00000008   0x42AE             CMP      R6,R5
   \   0000000A   0xD031             BEQ.N    ??move_window_0
    734          #if !_FS_READONLY
    735          		if (fs->wflag) {	/* Write back dirty window if needed */
   \   0000000C   0x7920             LDRB     R0,[R4, #+4]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD020             BEQ.N    ??move_window_1
    736          			if (LPLD_Disk_Write(fs->drv, fs->win, wsect, 1) != RES_OK)
   \   00000012   0x2301             MOVS     R3,#+1
   \   00000014   0x0032             MOVS     R2,R6
   \   00000016   0xF114 0x0134      ADDS     R1,R4,#+52
   \   0000001A   0x7860             LDRB     R0,[R4, #+1]
   \   0000001C   0x.... 0x....      BL       LPLD_Disk_Write
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ.N    ??move_window_2
    737          				return FR_DISK_ERR;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE024             B.N      ??move_window_3
    738          			fs->wflag = 0;
   \                     ??move_window_2:
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x7120             STRB     R0,[R4, #+4]
    739          			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
   \   0000002C   0x6A60             LDR      R0,[R4, #+36]
   \   0000002E   0x6A21             LDR      R1,[R4, #+32]
   \   00000030   0x1808             ADDS     R0,R1,R0
   \   00000032   0x4286             CMP      R6,R0
   \   00000034   0xD20E             BCS.N    ??move_window_1
    740          				BYTE nf;
    741          				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
   \   00000036   0x78E7             LDRB     R7,[R4, #+3]
   \   00000038   0xE009             B.N      ??move_window_4
    742          					wsect += fs->fsize;
   \                     ??move_window_5:
   \   0000003A   0x6A20             LDR      R0,[R4, #+32]
   \   0000003C   0x1986             ADDS     R6,R0,R6
    743          					LPLD_Disk_Write(fs->drv, fs->win, wsect, 1);
   \   0000003E   0x2301             MOVS     R3,#+1
   \   00000040   0x0032             MOVS     R2,R6
   \   00000042   0xF114 0x0134      ADDS     R1,R4,#+52
   \   00000046   0x7860             LDRB     R0,[R4, #+1]
   \   00000048   0x.... 0x....      BL       LPLD_Disk_Write
    744          				}
   \   0000004C   0x1E7F             SUBS     R7,R7,#+1
   \                     ??move_window_4:
   \   0000004E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000050   0x2F02             CMP      R7,#+2
   \   00000052   0xD2F2             BCS.N    ??move_window_5
    745          			}
    746          		}
    747          #endif
    748          		if (sector) {
   \                     ??move_window_1:
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD00B             BEQ.N    ??move_window_0
    749          			if (LPLD_Disk_Read(fs->drv, fs->win, sector, 1) != RES_OK)
   \   00000058   0x2301             MOVS     R3,#+1
   \   0000005A   0x002A             MOVS     R2,R5
   \   0000005C   0xF114 0x0134      ADDS     R1,R4,#+52
   \   00000060   0x7860             LDRB     R0,[R4, #+1]
   \   00000062   0x.... 0x....      BL       LPLD_Disk_Read
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD001             BEQ.N    ??move_window_6
    750          				return FR_DISK_ERR;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xE001             B.N      ??move_window_3
    751          			fs->winsect = sector;
   \                     ??move_window_6:
   \   0000006E   0x6325             STR      R5,[R4, #+48]
    752          		}
    753          	}
    754          
    755          	return FR_OK;
   \                     ??move_window_0:
   \   00000070   0x2000             MOVS     R0,#+0
   \                     ??move_window_3:
   \   00000072   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    756          }
    757          
    758          
    759          
    760          
    761          /*-----------------------------------------------------------------------*/
    762          /* Clean-up cached data                                                  */
    763          /*-----------------------------------------------------------------------*/
    764          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    765          static
    766          FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
    767          	FATFS *fs	/* File system object */
    768          )
    769          {
   \                     sync:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    770          	FRESULT res;
    771          
    772          
    773          	res = move_window(fs, 0);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       move_window
   \   0000000C   0x0005             MOVS     R5,R0
    774          	if (res == FR_OK) {
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD15D             BNE.N    ??sync_0
    775          		/* Update FSInfo sector if needed */
    776          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2803             CMP      R0,#+3
   \   00000018   0xD152             BNE.N    ??sync_1
   \   0000001A   0x7960             LDRB     R0,[R4, #+5]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD04F             BEQ.N    ??sync_1
    777          			fs->winsect = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6320             STR      R0,[R4, #+48]
    778          			/* Create FSInfo structure */
    779          			mem_set(fs->win, 0, 512);
   \   00000024   0xF44F 0x7200      MOV      R2,#+512
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xF114 0x0034      ADDS     R0,R4,#+52
   \   0000002E   0x.... 0x....      BL       mem_set
    780          			ST_WORD(fs->win+BS_55AA, 0xAA55);
   \   00000032   0x2055             MOVS     R0,#+85
   \   00000034   0xF884 0x0232      STRB     R0,[R4, #+562]
   \   00000038   0x20AA             MOVS     R0,#+170
   \   0000003A   0xF884 0x0233      STRB     R0,[R4, #+563]
    781          			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   \   0000003E   0x2052             MOVS     R0,#+82
   \   00000040   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000044   0x2052             MOVS     R0,#+82
   \   00000046   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000004A   0x2061             MOVS     R0,#+97
   \   0000004C   0xF884 0x0036      STRB     R0,[R4, #+54]
   \   00000050   0x2041             MOVS     R0,#+65
   \   00000052   0xF884 0x0037      STRB     R0,[R4, #+55]
    782          			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
   \   00000056   0x2072             MOVS     R0,#+114
   \   00000058   0xF884 0x0218      STRB     R0,[R4, #+536]
   \   0000005C   0x2072             MOVS     R0,#+114
   \   0000005E   0xF884 0x0219      STRB     R0,[R4, #+537]
   \   00000062   0x2041             MOVS     R0,#+65
   \   00000064   0xF884 0x021A      STRB     R0,[R4, #+538]
   \   00000068   0x2061             MOVS     R0,#+97
   \   0000006A   0xF884 0x021B      STRB     R0,[R4, #+539]
    783          			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
   \   0000006E   0x6920             LDR      R0,[R4, #+16]
   \   00000070   0xF884 0x021C      STRB     R0,[R4, #+540]
   \   00000074   0x6920             LDR      R0,[R4, #+16]
   \   00000076   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000078   0x0A00             LSRS     R0,R0,#+8
   \   0000007A   0xF884 0x021D      STRB     R0,[R4, #+541]
   \   0000007E   0x6920             LDR      R0,[R4, #+16]
   \   00000080   0x0C00             LSRS     R0,R0,#+16
   \   00000082   0xF884 0x021E      STRB     R0,[R4, #+542]
   \   00000086   0x6920             LDR      R0,[R4, #+16]
   \   00000088   0x0E00             LSRS     R0,R0,#+24
   \   0000008A   0xF884 0x021F      STRB     R0,[R4, #+543]
    784          			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
   \   0000008E   0x68E0             LDR      R0,[R4, #+12]
   \   00000090   0xF884 0x0220      STRB     R0,[R4, #+544]
   \   00000094   0x68E0             LDR      R0,[R4, #+12]
   \   00000096   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000098   0x0A00             LSRS     R0,R0,#+8
   \   0000009A   0xF884 0x0221      STRB     R0,[R4, #+545]
   \   0000009E   0x68E0             LDR      R0,[R4, #+12]
   \   000000A0   0x0C00             LSRS     R0,R0,#+16
   \   000000A2   0xF884 0x0222      STRB     R0,[R4, #+546]
   \   000000A6   0x68E0             LDR      R0,[R4, #+12]
   \   000000A8   0x0E00             LSRS     R0,R0,#+24
   \   000000AA   0xF884 0x0223      STRB     R0,[R4, #+547]
    785          			/* Write it into the FSInfo sector */
    786          			LPLD_Disk_Write(fs->drv, fs->win, fs->fsi_sector, 1);
   \   000000AE   0x2301             MOVS     R3,#+1
   \   000000B0   0x6962             LDR      R2,[R4, #+20]
   \   000000B2   0xF114 0x0134      ADDS     R1,R4,#+52
   \   000000B6   0x7860             LDRB     R0,[R4, #+1]
   \   000000B8   0x.... 0x....      BL       LPLD_Disk_Write
    787          			fs->fsi_flag = 0;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x7160             STRB     R0,[R4, #+5]
    788          		}
    789          		/* Make sure that no pending write process in the physical drive */
    790          		if (LPLD_Disk_IOC(fs->drv, CTRL_SYNC, 0) != RES_OK)
   \                     ??sync_1:
   \   000000C0   0x2200             MOVS     R2,#+0
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0x7860             LDRB     R0,[R4, #+1]
   \   000000C6   0x.... 0x....      BL       LPLD_Disk_IOC
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD000             BEQ.N    ??sync_0
    791          			res = FR_DISK_ERR;
   \   000000CE   0x2501             MOVS     R5,#+1
    792          	}
    793          
    794          	return res;
   \                     ??sync_0:
   \   000000D0   0x0028             MOVS     R0,R5
   \   000000D2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    795          }
    796          #endif
    797          
    798          
    799          
    800          
    801          /*-----------------------------------------------------------------------*/
    802          /* Get sector# from cluster#                                             */
    803          /*-----------------------------------------------------------------------*/
    804          
    805          

   \                                 In section .text, align 2, keep-with-next
    806          DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
    807          	FATFS *fs,		/* File system object */
    808          	DWORD clst		/* Cluster# to be converted */
    809          )
    810          {
    811          	clst -= 2;
   \                     clust2sect:
   \   00000000   0x1E89             SUBS     R1,R1,#+2
    812          	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   \   00000002   0x69C2             LDR      R2,[R0, #+28]
   \   00000004   0x1E92             SUBS     R2,R2,#+2
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD301             BCC.N    ??clust2sect_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE003             B.N      ??clust2sect_1
    813          	return clst * fs->csize + fs->database;
   \                     ??clust2sect_0:
   \   0000000E   0x7882             LDRB     R2,[R0, #+2]
   \   00000010   0x6AC0             LDR      R0,[R0, #+44]
   \   00000012   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \                     ??clust2sect_1:
   \   00000016   0x4770             BX       LR               ;; return
    814          }
    815          
    816          
    817          
    818          
    819          /*-----------------------------------------------------------------------*/
    820          /* FAT access - Read value of a FAT entry                                */
    821          /*-----------------------------------------------------------------------*/
    822          
    823          

   \                                 In section .text, align 2, keep-with-next
    824          DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
    825          	FATFS *fs,	/* File system object */
    826          	DWORD clst	/* Cluster# to get the link information */
    827          )
    828          {
   \                     get_fat:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    829          	UINT wc, bc;
    830          	BYTE *p;
    831          
    832          
    833          	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
   \   00000006   0x2D02             CMP      R5,#+2
   \   00000008   0xD302             BCC.N    ??get_fat_0
   \   0000000A   0x69E0             LDR      R0,[R4, #+28]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xD301             BCC.N    ??get_fat_1
    834          		return 1;
   \                     ??get_fat_0:
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE014             B.N      ??get_fat_2
    835          
    836          	switch (fs->fs_type) {
   \                     ??get_fat_1:
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD004             BEQ.N    ??get_fat_3
   \   0000001A   0xD30E             BCC.N    ??get_fat_4
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD04A             BEQ.N    ??get_fat_5
   \   00000020   0xD332             BCC.N    ??get_fat_6
   \   00000022   0xE00A             B.N      ??get_fat_4
    837          	case FS_FAT12 :
    838          		bc = (UINT)clst; bc += bc / 2;
   \                     ??get_fat_3:
   \   00000024   0x002E             MOVS     R6,R5
   \   00000026   0xEB16 0x0656      ADDS     R6,R6,R6, LSR #+1
    839          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   \   0000002A   0x6A60             LDR      R0,[R4, #+36]
   \   0000002C   0xEB10 0x2156      ADDS     R1,R0,R6, LSR #+9
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       move_window
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??get_fat_7
    840          		wc = fs->win[bc % SS(fs)]; bc++;
    841          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    842          		wc |= fs->win[bc % SS(fs)] << 8;
    843          		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    844          
    845          	case FS_FAT16 :
    846          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    847          		p = &fs->win[clst * 2 % SS(fs)];
    848          		return LD_WORD(p);
    849          
    850          	case FS_FAT32 :
    851          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    852          		p = &fs->win[clst * 4 % SS(fs)];
    853          		return LD_DWORD(p) & 0x0FFFFFFF;
    854          	}
    855          
    856          	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
   \                     ??get_fat_4:
   \   0000003A   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??get_fat_2:
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??get_fat_7:
   \   00000040   0xF44F 0x7000      MOV      R0,#+512
   \   00000044   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   00000048   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   0000004C   0x1908             ADDS     R0,R1,R4
   \   0000004E   0xF890 0x7034      LDRB     R7,[R0, #+52]
   \   00000052   0x1C76             ADDS     R6,R6,#+1
   \   00000054   0x6A60             LDR      R0,[R4, #+36]
   \   00000056   0xEB10 0x2156      ADDS     R1,R0,R6, LSR #+9
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       move_window
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD1EA             BNE.N    ??get_fat_4
   \                     ??get_fat_8:
   \   00000064   0xF44F 0x7000      MOV      R0,#+512
   \   00000068   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   0000006C   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000070   0x1908             ADDS     R0,R1,R4
   \   00000072   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000076   0xEA57 0x2700      ORRS     R7,R7,R0, LSL #+8
   \   0000007A   0x07E8             LSLS     R0,R5,#+31
   \   0000007C   0xD501             BPL.N    ??get_fat_9
   \   0000007E   0x0938             LSRS     R0,R7,#+4
   \   00000080   0xE001             B.N      ??get_fat_10
   \                     ??get_fat_9:
   \   00000082   0x0538             LSLS     R0,R7,#+20       ;; ZeroExtS R0,R7,#+20,#+20
   \   00000084   0x0D00             LSRS     R0,R0,#+20
   \                     ??get_fat_10:
   \   00000086   0xE7DA             B.N      ??get_fat_2
   \                     ??get_fat_6:
   \   00000088   0x6A60             LDR      R0,[R4, #+36]
   \   0000008A   0xEB10 0x2115      ADDS     R1,R0,R5, LSR #+8
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       move_window
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD1D0             BNE.N    ??get_fat_4
   \                     ??get_fat_11:
   \   00000098   0x0068             LSLS     R0,R5,#+1
   \   0000009A   0xF44F 0x7100      MOV      R1,#+512
   \   0000009E   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000A2   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000A6   0x1910             ADDS     R0,R2,R4
   \   000000A8   0x3034             ADDS     R0,R0,#+52
   \   000000AA   0x7841             LDRB     R1,[R0, #+1]
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000000B2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B4   0xE7C3             B.N      ??get_fat_2
   \                     ??get_fat_5:
   \   000000B6   0x6A60             LDR      R0,[R4, #+36]
   \   000000B8   0xEB10 0x11D5      ADDS     R1,R0,R5, LSR #+7
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0x.... 0x....      BL       move_window
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD1B9             BNE.N    ??get_fat_4
   \                     ??get_fat_12:
   \   000000C6   0x00A8             LSLS     R0,R5,#+2
   \   000000C8   0xF44F 0x7100      MOV      R1,#+512
   \   000000CC   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000D0   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000D4   0x1910             ADDS     R0,R2,R4
   \   000000D6   0x3034             ADDS     R0,R0,#+52
   \   000000D8   0x78C1             LDRB     R1,[R0, #+3]
   \   000000DA   0x7882             LDRB     R2,[R0, #+2]
   \   000000DC   0x0412             LSLS     R2,R2,#+16
   \   000000DE   0xEA52 0x6101      ORRS     R1,R2,R1, LSL #+24
   \   000000E2   0x7842             LDRB     R2,[R0, #+1]
   \   000000E4   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   000000E8   0x7800             LDRB     R0,[R0, #+0]
   \   000000EA   0x4308             ORRS     R0,R0,R1
   \   000000EC   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   000000EE   0x0900             LSRS     R0,R0,#+4
   \   000000F0   0xE7A5             B.N      ??get_fat_2
    857          }
    858          
    859          
    860          
    861          
    862          /*-----------------------------------------------------------------------*/
    863          /* FAT access - Change value of a FAT entry                              */
    864          /*-----------------------------------------------------------------------*/
    865          #if !_FS_READONLY
    866          

   \                                 In section .text, align 2, keep-with-next
    867          FRESULT put_fat (
    868          	FATFS *fs,	/* File system object */
    869          	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
    870          	DWORD val	/* New value to mark the cluster */
    871          )
    872          {
   \                     put_fat:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    873          	UINT bc;
    874          	BYTE *p;
    875          	FRESULT res;
    876          
    877          
    878          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000008   0x2D02             CMP      R5,#+2
   \   0000000A   0xD302             BCC.N    ??put_fat_0
   \   0000000C   0x69E0             LDR      R0,[R4, #+28]
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD301             BCC.N    ??put_fat_1
    879          		res = FR_INT_ERR;
   \                     ??put_fat_0:
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE082             B.N      ??put_fat_2
    880          
    881          	} else {
    882          		switch (fs->fs_type) {
   \                     ??put_fat_1:
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD004             BEQ.N    ??put_fat_3
   \   0000001C   0xD37B             BCC.N    ??put_fat_4
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD058             BEQ.N    ??put_fat_5
   \   00000022   0xD340             BCC.N    ??put_fat_6
   \   00000024   0xE077             B.N      ??put_fat_4
    883          		case FS_FAT12 :
    884          			bc = clst; bc += bc / 2;
   \                     ??put_fat_3:
   \   00000026   0x002F             MOVS     R7,R5
   \   00000028   0xEB17 0x0757      ADDS     R7,R7,R7, LSR #+1
    885          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   0000002C   0x6A60             LDR      R0,[R4, #+36]
   \   0000002E   0xEB10 0x2157      ADDS     R1,R0,R7, LSR #+9
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       move_window
    886          			if (res != FR_OK) break;
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD16C             BNE.N    ??put_fat_7
    887          			p = &fs->win[bc % SS(fs)];
   \                     ??put_fat_8:
   \   0000003E   0xF44F 0x7000      MOV      R0,#+512
   \   00000042   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   00000046   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   0000004A   0x1908             ADDS     R0,R1,R4
   \   0000004C   0xF110 0x0134      ADDS     R1,R0,#+52
    888          			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   \   00000050   0x07E8             LSLS     R0,R5,#+31
   \   00000052   0xD505             BPL.N    ??put_fat_9
   \   00000054   0x7808             LDRB     R0,[R1, #+0]
   \   00000056   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000005A   0xEA50 0x1006      ORRS     R0,R0,R6, LSL #+4
   \   0000005E   0xE000             B.N      ??put_fat_10
   \                     ??put_fat_9:
   \   00000060   0x0030             MOVS     R0,R6
   \                     ??put_fat_10:
   \   00000062   0x7008             STRB     R0,[R1, #+0]
    889          			bc++;
   \   00000064   0x1C7F             ADDS     R7,R7,#+1
    890          			fs->wflag = 1;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x7120             STRB     R0,[R4, #+4]
    891          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   0000006A   0x6A60             LDR      R0,[R4, #+36]
   \   0000006C   0xEB10 0x2157      ADDS     R1,R0,R7, LSR #+9
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       move_window
    892          			if (res != FR_OK) break;
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD14D             BNE.N    ??put_fat_7
    893          			p = &fs->win[bc % SS(fs)];
   \                     ??put_fat_11:
   \   0000007C   0xF44F 0x7100      MOV      R1,#+512
   \   00000080   0xFBB7 0xF2F1      UDIV     R2,R7,R1
   \   00000084   0xFB02 0x7211      MLS      R2,R2,R1,R7
   \   00000088   0x1911             ADDS     R1,R2,R4
   \   0000008A   0x3134             ADDS     R1,R1,#+52
    894          			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   \   0000008C   0x07EA             LSLS     R2,R5,#+31
   \   0000008E   0xD501             BPL.N    ??put_fat_12
   \   00000090   0x0932             LSRS     R2,R6,#+4
   \   00000092   0xE006             B.N      ??put_fat_13
   \                     ??put_fat_12:
   \   00000094   0x780A             LDRB     R2,[R1, #+0]
   \   00000096   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   0000009A   0x0A33             LSRS     R3,R6,#+8
   \   0000009C   0xF013 0x030F      ANDS     R3,R3,#0xF
   \   000000A0   0x431A             ORRS     R2,R3,R2
   \                     ??put_fat_13:
   \   000000A2   0x700A             STRB     R2,[R1, #+0]
    895          			break;
   \   000000A4   0xE038             B.N      ??put_fat_7
    896          
    897          		case FS_FAT16 :
    898          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   \                     ??put_fat_6:
   \   000000A6   0x6A60             LDR      R0,[R4, #+36]
   \   000000A8   0xEB10 0x2115      ADDS     R1,R0,R5, LSR #+8
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       move_window
    899          			if (res != FR_OK) break;
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD12F             BNE.N    ??put_fat_7
    900          			p = &fs->win[clst * 2 % SS(fs)];
   \                     ??put_fat_14:
   \   000000B8   0x0069             LSLS     R1,R5,#+1
   \   000000BA   0xF44F 0x7200      MOV      R2,#+512
   \   000000BE   0xFBB1 0xF3F2      UDIV     R3,R1,R2
   \   000000C2   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   000000C6   0x1919             ADDS     R1,R3,R4
   \   000000C8   0x3134             ADDS     R1,R1,#+52
    901          			ST_WORD(p, (WORD)val);
   \   000000CA   0x700E             STRB     R6,[R1, #+0]
   \   000000CC   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000CE   0x0A32             LSRS     R2,R6,#+8
   \   000000D0   0x704A             STRB     R2,[R1, #+1]
    902          			break;
   \   000000D2   0xE021             B.N      ??put_fat_7
    903          
    904          		case FS_FAT32 :
    905          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   \                     ??put_fat_5:
   \   000000D4   0x6A60             LDR      R0,[R4, #+36]
   \   000000D6   0xEB10 0x11D5      ADDS     R1,R0,R5, LSR #+7
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x.... 0x....      BL       move_window
    906          			if (res != FR_OK) break;
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD118             BNE.N    ??put_fat_7
    907          			p = &fs->win[clst * 4 % SS(fs)];
   \                     ??put_fat_15:
   \   000000E6   0x00A9             LSLS     R1,R5,#+2
   \   000000E8   0xF44F 0x7200      MOV      R2,#+512
   \   000000EC   0xFBB1 0xF3F2      UDIV     R3,R1,R2
   \   000000F0   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   000000F4   0x1919             ADDS     R1,R3,R4
   \   000000F6   0x3134             ADDS     R1,R1,#+52
    908          			val |= LD_DWORD(p) & 0xF0000000;
   \   000000F8   0x78CA             LDRB     R2,[R1, #+3]
   \   000000FA   0x0612             LSLS     R2,R2,#+24
   \   000000FC   0xF012 0x4270      ANDS     R2,R2,#0xF0000000
   \   00000100   0x4316             ORRS     R6,R2,R6
    909          			ST_DWORD(p, val);
   \   00000102   0x700E             STRB     R6,[R1, #+0]
   \   00000104   0x0032             MOVS     R2,R6
   \   00000106   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000108   0x0A12             LSRS     R2,R2,#+8
   \   0000010A   0x704A             STRB     R2,[R1, #+1]
   \   0000010C   0x0C32             LSRS     R2,R6,#+16
   \   0000010E   0x708A             STRB     R2,[R1, #+2]
   \   00000110   0x0E32             LSRS     R2,R6,#+24
   \   00000112   0x70CA             STRB     R2,[R1, #+3]
    910          			break;
   \   00000114   0xE000             B.N      ??put_fat_7
    911          
    912          		default :
    913          			res = FR_INT_ERR;
   \                     ??put_fat_4:
   \   00000116   0x2002             MOVS     R0,#+2
    914          		}
    915          		fs->wflag = 1;
   \                     ??put_fat_7:
   \   00000118   0x2101             MOVS     R1,#+1
   \   0000011A   0x7121             STRB     R1,[R4, #+4]
    916          	}
    917          
    918          	return res;
   \                     ??put_fat_2:
   \   0000011C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    919          }
    920          #endif /* !_FS_READONLY */
    921          
    922          
    923          
    924          
    925          /*-----------------------------------------------------------------------*/
    926          /* FAT handling - Remove a cluster chain                                 */
    927          /*-----------------------------------------------------------------------*/
    928          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    929          static
    930          FRESULT remove_chain (
    931          	FATFS *fs,			/* File system object */
    932          	DWORD clst			/* Cluster# to remove a chain from */
    933          )
    934          {
   \                     remove_chain:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    935          	FRESULT res;
    936          	DWORD nxt;
    937          #if _USE_ERASE
    938          	DWORD scl = clst, ecl = clst, resion[2];
    939          #endif
    940          
    941          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000006   0x2E02             CMP      R6,#+2
   \   00000008   0xD302             BCC.N    ??remove_chain_0
   \   0000000A   0x69E0             LDR      R0,[R4, #+28]
   \   0000000C   0x4286             CMP      R6,R0
   \   0000000E   0xD301             BCC.N    ??remove_chain_1
    942          		res = FR_INT_ERR;
   \                     ??remove_chain_0:
   \   00000010   0x2502             MOVS     R5,#+2
   \   00000012   0xE027             B.N      ??remove_chain_2
    943          
    944          	} else {
    945          		res = FR_OK;
   \                     ??remove_chain_1:
   \   00000014   0x2500             MOVS     R5,#+0
   \   00000016   0xE009             B.N      ??remove_chain_3
    946          		while (clst < fs->n_fatent) {			/* Not a last link? */
    947          			nxt = get_fat(fs, clst);			/* Get cluster status */
    948          			if (nxt == 0) break;				/* Empty cluster? */
    949          			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    950          			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    951          			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    952          			if (res != FR_OK) break;
    953          			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
   \                     ??remove_chain_4:
   \   00000018   0x6920             LDR      R0,[R4, #+16]
   \   0000001A   0xF110 0x0F01      CMN      R0,#+1
   \   0000001E   0xD004             BEQ.N    ??remove_chain_5
    954          				fs->free_clust++;
   \   00000020   0x6920             LDR      R0,[R4, #+16]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0x6120             STR      R0,[R4, #+16]
    955          				fs->fsi_flag = 1;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x7160             STRB     R0,[R4, #+5]
    956          			}
    957          #if _USE_ERASE
    958          			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
    959          				ecl = nxt;
    960          			} else {				/* End of contiguous clusters */ 
    961          				resion[0] = clust2sect(fs, scl);					/* Start sector */
    962          				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
    963          				LPLD_Disk_IOC(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
    964          				scl = ecl = nxt;
    965          			}
    966          #endif
    967          			clst = nxt;	/* Next cluster */
   \                     ??remove_chain_5:
   \   0000002A   0x003E             MOVS     R6,R7
   \                     ??remove_chain_3:
   \   0000002C   0x69E0             LDR      R0,[R4, #+28]
   \   0000002E   0x4286             CMP      R6,R0
   \   00000030   0xD218             BCS.N    ??remove_chain_2
   \   00000032   0x0031             MOVS     R1,R6
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       get_fat
   \   0000003A   0x0007             MOVS     R7,R0
   \   0000003C   0x2F00             CMP      R7,#+0
   \   0000003E   0xD011             BEQ.N    ??remove_chain_2
   \                     ??remove_chain_6:
   \   00000040   0x2F01             CMP      R7,#+1
   \   00000042   0xD101             BNE.N    ??remove_chain_7
   \   00000044   0x2502             MOVS     R5,#+2
   \   00000046   0xE00D             B.N      ??remove_chain_2
   \                     ??remove_chain_7:
   \   00000048   0xF117 0x0F01      CMN      R7,#+1
   \   0000004C   0xD101             BNE.N    ??remove_chain_8
   \   0000004E   0x2501             MOVS     R5,#+1
   \   00000050   0xE008             B.N      ??remove_chain_2
   \                     ??remove_chain_8:
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0031             MOVS     R1,R6
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       put_fat
   \   0000005C   0x0005             MOVS     R5,R0
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0x2D00             CMP      R5,#+0
   \   00000062   0xD0D9             BEQ.N    ??remove_chain_4
    968          		}
    969          	}
    970          
    971          	return res;
   \                     ??remove_chain_2:
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    972          }
    973          #endif
    974          
    975          
    976          
    977          
    978          /*-----------------------------------------------------------------------*/
    979          /* FAT handling - Stretch or Create a cluster chain                      */
    980          /*-----------------------------------------------------------------------*/
    981          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    982          static
    983          DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
    984          	FATFS *fs,			/* File system object */
    985          	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
    986          )
    987          {
   \                     create_chain:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    988          	DWORD cs, ncl, scl;
    989          	FRESULT res;
    990          
    991          
    992          	if (clst == 0) {		/* Create a new chain */
   \   00000006   0x2E00             CMP      R6,#+0
   \   00000008   0xD107             BNE.N    ??create_chain_0
    993          		scl = fs->last_clust;			/* Get suggested start point */
   \   0000000A   0x68E7             LDR      R7,[R4, #+12]
    994          		if (!scl || scl >= fs->n_fatent) scl = 1;
   \   0000000C   0x2F00             CMP      R7,#+0
   \   0000000E   0xD002             BEQ.N    ??create_chain_1
   \   00000010   0x69E0             LDR      R0,[R4, #+28]
   \   00000012   0x4287             CMP      R7,R0
   \   00000014   0xD30D             BCC.N    ??create_chain_2
   \                     ??create_chain_1:
   \   00000016   0x2701             MOVS     R7,#+1
   \   00000018   0xE00B             B.N      ??create_chain_2
    995          	}
    996          	else {					/* Stretch the current chain */
    997          		cs = get_fat(fs, clst);			/* Check the cluster status */
   \                     ??create_chain_0:
   \   0000001A   0x0031             MOVS     R1,R6
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       get_fat
    998          		if (cs < 2) return 1;			/* It is an invalid cluster */
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD201             BCS.N    ??create_chain_3
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE043             B.N      ??create_chain_4
    999          		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   \                     ??create_chain_3:
   \   0000002A   0x69E1             LDR      R1,[R4, #+28]
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD340             BCC.N    ??create_chain_4
   1000          		scl = clst;
   \                     ??create_chain_5:
   \   00000030   0x0037             MOVS     R7,R6
   1001          	}
   1002          
   1003          	ncl = scl;				/* Start cluster */
   \                     ??create_chain_2:
   \   00000032   0x003D             MOVS     R5,R7
   1004          	for (;;) {
   1005          		ncl++;							/* Next cluster */
   \                     ??create_chain_6:
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
   1006          		if (ncl >= fs->n_fatent) {		/* Wrap around */
   \   00000036   0x69E0             LDR      R0,[R4, #+28]
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD304             BCC.N    ??create_chain_7
   1007          			ncl = 2;
   \   0000003C   0x2502             MOVS     R5,#+2
   1008          			if (ncl > scl) return 0;	/* No free cluster */
   \   0000003E   0x42AF             CMP      R7,R5
   \   00000040   0xD201             BCS.N    ??create_chain_7
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE035             B.N      ??create_chain_4
   1009          		}
   1010          		cs = get_fat(fs, ncl);			/* Get the cluster status */
   \                     ??create_chain_7:
   \   00000046   0x0029             MOVS     R1,R5
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       get_fat
   1011          		if (cs == 0) break;				/* Found a free cluster */
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD11D             BNE.N    ??create_chain_8
   1012          		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   1013          			return cs;
   1014          		if (ncl == scl) return 0;		/* No free cluster */
   1015          	}
   1016          
   1017          	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   \   00000052   0xF07F 0x4270      MVNS     R2,#-268435456
   \   00000056   0x0029             MOVS     R1,R5
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       put_fat
   1018          	if (res == FR_OK && clst != 0) {
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD106             BNE.N    ??create_chain_9
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD004             BEQ.N    ??create_chain_9
   1019          		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   \   00000068   0x002A             MOVS     R2,R5
   \   0000006A   0x0031             MOVS     R1,R6
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       put_fat
   1020          	}
   1021          	if (res == FR_OK) {
   \                     ??create_chain_9:
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD114             BNE.N    ??create_chain_10
   1022          		fs->last_clust = ncl;			/* Update FSINFO */
   \   00000078   0x60E5             STR      R5,[R4, #+12]
   1023          		if (fs->free_clust != 0xFFFFFFFF) {
   \   0000007A   0x6920             LDR      R0,[R4, #+16]
   \   0000007C   0xF110 0x0F01      CMN      R0,#+1
   \   00000080   0xD016             BEQ.N    ??create_chain_11
   1024          			fs->free_clust--;
   \   00000082   0x6920             LDR      R0,[R4, #+16]
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0x6120             STR      R0,[R4, #+16]
   1025          			fs->fsi_flag = 1;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x7160             STRB     R0,[R4, #+5]
   \   0000008C   0xE010             B.N      ??create_chain_11
   1026          		}
   1027          	} else {
   \                     ??create_chain_8:
   \   0000008E   0xF110 0x0F01      CMN      R0,#+1
   \   00000092   0xD001             BEQ.N    ??create_chain_12
   \   00000094   0x2801             CMP      R0,#+1
   \   00000096   0xD100             BNE.N    ??create_chain_13
   \                     ??create_chain_12:
   \   00000098   0xE00B             B.N      ??create_chain_4
   \                     ??create_chain_13:
   \   0000009A   0x42BD             CMP      R5,R7
   \   0000009C   0xD1CA             BNE.N    ??create_chain_6
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xE007             B.N      ??create_chain_4
   1028          		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   \                     ??create_chain_10:
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0x2801             CMP      R0,#+1
   \   000000A6   0xD102             BNE.N    ??create_chain_14
   \   000000A8   0xF05F 0x35FF      MOVS     R5,#-1
   \   000000AC   0xE000             B.N      ??create_chain_11
   \                     ??create_chain_14:
   \   000000AE   0x2501             MOVS     R5,#+1
   1029          	}
   1030          
   1031          	return ncl;		/* Return new cluster number or error code */
   \                     ??create_chain_11:
   \   000000B0   0x0028             MOVS     R0,R5
   \                     ??create_chain_4:
   \   000000B2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1032          }
   1033          #endif /* !_FS_READONLY */
   1034          
   1035          
   1036          
   1037          /*-----------------------------------------------------------------------*/
   1038          /* FAT handling - Convert offset into cluster with link map table        */
   1039          /*-----------------------------------------------------------------------*/
   1040          
   1041          #if _USE_FASTSEEK

   \                                 In section .text, align 2, keep-with-next
   1042          static
   1043          DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
   1044          	FIL* fp,		/* Pointer to the file object */
   1045          	DWORD ofs		/* File offset to be converted to cluster# */
   1046          )
   1047          {
   1048          	DWORD cl, ncl, *tbl;
   1049          
   1050          
   1051          	tbl = fp->cltbl + 1;	/* Top of CLMT */
   \                     clmt_clust:
   \   00000000   0x6A42             LDR      R2,[R0, #+36]
   \   00000002   0x1D12             ADDS     R2,R2,#+4
   1052          	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
   \   00000004   0x0A49             LSRS     R1,R1,#+9
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x7880             LDRB     R0,[R0, #+2]
   \   0000000A   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   0000000E   0xE001             B.N      ??clmt_clust_0
   1053          	for (;;) {
   1054          		ncl = *tbl++;			/* Number of cluters in the fragment */
   1055          		if (!ncl) return 0;		/* End of table? (error) */
   1056          		if (cl < ncl) break;	/* In this fragment? */
   1057          		cl -= ncl; tbl++;		/* Next fragment */
   \                     ??clmt_clust_1:
   \   00000010   0x1A40             SUBS     R0,R0,R1
   \   00000012   0x1D12             ADDS     R2,R2,#+4
   \                     ??clmt_clust_0:
   \   00000014   0x6811             LDR      R1,[R2, #+0]
   \   00000016   0x1D12             ADDS     R2,R2,#+4
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD101             BNE.N    ??clmt_clust_2
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE003             B.N      ??clmt_clust_3
   \                     ??clmt_clust_2:
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD2F5             BCS.N    ??clmt_clust_1
   1058          	}
   1059          	return cl + *tbl;	/* Return the cluster number */
   \   00000024   0x6811             LDR      R1,[R2, #+0]
   \   00000026   0x1808             ADDS     R0,R1,R0
   \                     ??clmt_clust_3:
   \   00000028   0x4770             BX       LR               ;; return
   1060          }
   1061          #endif	/* _USE_FASTSEEK */
   1062          
   1063          
   1064          
   1065          /*-----------------------------------------------------------------------*/
   1066          /* Directory handling - Set directory index                              */
   1067          /*-----------------------------------------------------------------------*/
   1068          

   \                                 In section .text, align 2, keep-with-next
   1069          static
   1070          FRESULT dir_sdi (
   1071          	DIR *dj,		/* Pointer to directory object */
   1072          	WORD idx		/* Directory index number */
   1073          )
   1074          {
   \                     dir_sdi:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1075          	DWORD clst;
   1076          	WORD ic;
   1077          
   1078          
   1079          	dj->index = idx;
   \   00000006   0x80E5             STRH     R5,[R4, #+6]
   1080          	clst = dj->sclust;
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   1081          	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD003             BEQ.N    ??dir_sdi_0
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x69C9             LDR      R1,[R1, #+28]
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD301             BCC.N    ??dir_sdi_1
   1082          		return FR_INT_ERR;
   \                     ??dir_sdi_0:
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE048             B.N      ??dir_sdi_2
   1083          	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   \                     ??dir_sdi_1:
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD105             BNE.N    ??dir_sdi_3
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x2903             CMP      R1,#+3
   \   00000024   0xD101             BNE.N    ??dir_sdi_3
   1084          		clst = dj->fs->dirbase;
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6A80             LDR      R0,[R0, #+40]
   1085          
   1086          	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
   \                     ??dir_sdi_3:
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD10E             BNE.N    ??dir_sdi_4
   1087          		dj->clust = clst;
   \   0000002E   0x60E0             STR      R0,[R4, #+12]
   1088          		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x8900             LDRH     R0,[R0, #+8]
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0x4285             CMP      R5,R0
   \   00000038   0xD301             BCC.N    ??dir_sdi_5
   1089          			return FR_INT_ERR;
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0xE036             B.N      ??dir_sdi_2
   1090          		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \                     ??dir_sdi_5:
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6A80             LDR      R0,[R0, #+40]
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0xEB10 0x1015      ADDS     R0,R0,R5, LSR #+4
   \   00000048   0x6120             STR      R0,[R4, #+16]
   \   0000004A   0xE023             B.N      ??dir_sdi_6
   1091          	}
   1092          	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
   1093          		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
   \                     ??dir_sdi_4:
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x7889             LDRB     R1,[R1, #+2]
   \   00000050   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000052   0x010E             LSLS     R6,R1,#+4
   \   00000054   0xE000             B.N      ??dir_sdi_7
   1094          		while (idx >= ic) {	/* Follow cluster chain */
   1095          			clst = get_fat(dj->fs, clst);				/* Get next cluster */
   1096          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1097          			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
   1098          				return FR_INT_ERR;
   1099          			idx -= ic;
   \                     ??dir_sdi_8:
   \   00000056   0x1BAD             SUBS     R5,R5,R6
   \                     ??dir_sdi_7:
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000005C   0x42B5             CMP      R5,R6
   \   0000005E   0xD310             BCC.N    ??dir_sdi_9
   \   00000060   0x0001             MOVS     R1,R0
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x.... 0x....      BL       get_fat
   \   00000068   0xF110 0x0F01      CMN      R0,#+1
   \   0000006C   0xD101             BNE.N    ??dir_sdi_10
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0xE01C             B.N      ??dir_sdi_2
   \                     ??dir_sdi_10:
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xD303             BCC.N    ??dir_sdi_11
   \   00000076   0x6821             LDR      R1,[R4, #+0]
   \   00000078   0x69C9             LDR      R1,[R1, #+28]
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xD3EB             BCC.N    ??dir_sdi_8
   \                     ??dir_sdi_11:
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0xE014             B.N      ??dir_sdi_2
   1100          		}
   1101          		dj->clust = clst;
   \                     ??dir_sdi_9:
   \   00000082   0x60E0             STR      R0,[R4, #+12]
   1102          		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \   00000084   0x0001             MOVS     R1,R0
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x.... 0x....      BL       clust2sect
   \   0000008C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000008E   0xEB10 0x1015      ADDS     R0,R0,R5, LSR #+4
   \   00000092   0x6120             STR      R0,[R4, #+16]
   1103          	}
   1104          
   1105          	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
   \                     ??dir_sdi_6:
   \   00000094   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000096   0x2010             MOVS     R0,#+16
   \   00000098   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   0000009C   0xFB01 0x5110      MLS      R1,R1,R0,R5
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0xEB10 0x1041      ADDS     R0,R0,R1, LSL #+5
   \   000000A6   0x3034             ADDS     R0,R0,#+52
   \   000000A8   0x6160             STR      R0,[R4, #+20]
   1106          
   1107          	return FR_OK;	/* Seek succeeded */
   \   000000AA   0x2000             MOVS     R0,#+0
   \                     ??dir_sdi_2:
   \   000000AC   0xBD70             POP      {R4-R6,PC}       ;; return
   1108          }
   1109          
   1110          
   1111          
   1112          
   1113          /*-----------------------------------------------------------------------*/
   1114          /* Directory handling - Move directory index next                        */
   1115          /*-----------------------------------------------------------------------*/
   1116          

   \                                 In section .text, align 2, keep-with-next
   1117          static
   1118          FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
   1119          	DIR *dj,		/* Pointer to directory object */
   1120          	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
   1121          )
   1122          {
   \                     dir_next:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1123          	DWORD clst;
   1124          	WORD i;
   1125          
   1126          
   1127          	stretch = stretch;		/* To suppress warning on read-only cfg. */
   1128          	i = dj->index + 1;
   \   00000006   0x88E0             LDRH     R0,[R4, #+6]
   \   00000008   0x1C46             ADDS     R6,R0,#+1
   1129          	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
   \   0000000A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD002             BEQ.N    ??dir_next_0
   \   00000010   0x6920             LDR      R0,[R4, #+16]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??dir_next_1
   1130          		return FR_NO_FILE;
   \                     ??dir_next_0:
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0xE089             B.N      ??dir_next_2
   1131          
   1132          	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
   \                     ??dir_next_1:
   \   0000001A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001C   0x2010             MOVS     R0,#+16
   \   0000001E   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   00000022   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD174             BNE.N    ??dir_next_3
   1133          		dj->sect++;					/* Next sector */
   \   0000002A   0x6920             LDR      R0,[R4, #+16]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x6120             STR      R0,[R4, #+16]
   1134          
   1135          		if (dj->clust == 0) {	/* Static table */
   \   00000030   0x68E0             LDR      R0,[R4, #+12]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD106             BNE.N    ??dir_next_4
   1136          			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x8900             LDRH     R0,[R0, #+8]
   \   0000003A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003C   0x4286             CMP      R6,R0
   \   0000003E   0xD369             BCC.N    ??dir_next_3
   1137          				return FR_NO_FILE;
   \   00000040   0x2004             MOVS     R0,#+4
   \   00000042   0xE074             B.N      ??dir_next_2
   1138          		}
   1139          		else {					/* Dynamic table */
   1140          			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
   \                     ??dir_next_4:
   \   00000044   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x7880             LDRB     R0,[R0, #+2]
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   \   0000004C   0xEA10 0x1F16      TST      R0,R6, LSR #+4
   \   00000050   0xD160             BNE.N    ??dir_next_3
   1141          				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
   \   00000052   0x68E1             LDR      R1,[R4, #+12]
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       get_fat
   \   0000005A   0x0007             MOVS     R7,R0
   1142          				if (clst <= 1) return FR_INT_ERR;
   \   0000005C   0x2F02             CMP      R7,#+2
   \   0000005E   0xD201             BCS.N    ??dir_next_5
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0xE064             B.N      ??dir_next_2
   1143          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_5:
   \   00000064   0xF117 0x0F01      CMN      R7,#+1
   \   00000068   0xD101             BNE.N    ??dir_next_6
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xE05F             B.N      ??dir_next_2
   1144          				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
   \                     ??dir_next_6:
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x69C0             LDR      R0,[R0, #+28]
   \   00000072   0x4287             CMP      R7,R0
   \   00000074   0xD348             BCC.N    ??dir_next_7
   1145          #if !_FS_READONLY
   1146          					BYTE c;
   1147          					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD101             BNE.N    ??dir_next_8
   \   0000007A   0x2004             MOVS     R0,#+4
   \   0000007C   0xE057             B.N      ??dir_next_2
   1148          					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
   \                     ??dir_next_8:
   \   0000007E   0x68E1             LDR      R1,[R4, #+12]
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x.... 0x....      BL       create_chain
   \   00000086   0x0007             MOVS     R7,R0
   1149          					if (clst == 0) return FR_DENIED;			/* No free cluster */
   \   00000088   0x2F00             CMP      R7,#+0
   \   0000008A   0xD101             BNE.N    ??dir_next_9
   \   0000008C   0x2007             MOVS     R0,#+7
   \   0000008E   0xE04E             B.N      ??dir_next_2
   1150          					if (clst == 1) return FR_INT_ERR;
   \                     ??dir_next_9:
   \   00000090   0x2F01             CMP      R7,#+1
   \   00000092   0xD101             BNE.N    ??dir_next_10
   \   00000094   0x2002             MOVS     R0,#+2
   \   00000096   0xE04A             B.N      ??dir_next_2
   1151          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_10:
   \   00000098   0xF117 0x0F01      CMN      R7,#+1
   \   0000009C   0xD101             BNE.N    ??dir_next_11
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xE045             B.N      ??dir_next_2
   1152          					/* Clean-up stretched table */
   1153          					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
   \                     ??dir_next_11:
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x.... 0x....      BL       move_window
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD001             BEQ.N    ??dir_next_12
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xE03D             B.N      ??dir_next_2
   1154          					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
   \                     ??dir_next_12:
   \   000000B2   0xF44F 0x7200      MOV      R2,#+512
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x3034             ADDS     R0,R0,#+52
   \   000000BC   0x.... 0x....      BL       mem_set
   1155          					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
   \   000000C0   0x0039             MOVS     R1,R7
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x.... 0x....      BL       clust2sect
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x6308             STR      R0,[R1, #+48]
   1156          					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   \   000000CC   0x2500             MOVS     R5,#+0
   \   000000CE   0xE005             B.N      ??dir_next_13
   1157          						dj->fs->wflag = 1;
   1158          						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
   1159          						dj->fs->winsect++;
   \                     ??dir_next_14:
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6B00             LDR      R0,[R0, #+48]
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \   000000D6   0x6821             LDR      R1,[R4, #+0]
   \   000000D8   0x6308             STR      R0,[R1, #+48]
   \   000000DA   0x1C6D             ADDS     R5,R5,#+1
   \                     ??dir_next_13:
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x7880             LDRB     R0,[R0, #+2]
   \   000000E0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E2   0x4285             CMP      R5,R0
   \   000000E4   0xD20A             BCS.N    ??dir_next_15
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x2101             MOVS     R1,#+1
   \   000000EA   0x7101             STRB     R1,[R0, #+4]
   \   000000EC   0x2100             MOVS     R1,#+0
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x.... 0x....      BL       move_window
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD0EB             BEQ.N    ??dir_next_14
   \   000000F8   0x2001             MOVS     R0,#+1
   \   000000FA   0xE018             B.N      ??dir_next_2
   1160          					}
   1161          					dj->fs->winsect -= c;						/* Rewind window address */
   \                     ??dir_next_15:
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x6B00             LDR      R0,[R0, #+48]
   \   00000100   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000102   0x1B40             SUBS     R0,R0,R5
   \   00000104   0x6821             LDR      R1,[R4, #+0]
   \   00000106   0x6308             STR      R0,[R1, #+48]
   1162          #else
   1163          					return FR_NO_FILE;			/* Report EOT */
   1164          #endif
   1165          				}
   1166          				dj->clust = clst;				/* Initialize data for new cluster */
   \                     ??dir_next_7:
   \   00000108   0x60E7             STR      R7,[R4, #+12]
   1167          				dj->sect = clust2sect(dj->fs, clst);
   \   0000010A   0x0039             MOVS     R1,R7
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x.... 0x....      BL       clust2sect
   \   00000112   0x6120             STR      R0,[R4, #+16]
   1168          			}
   1169          		}
   1170          	}
   1171          
   1172          	dj->index = i;
   \                     ??dir_next_3:
   \   00000114   0x80E6             STRH     R6,[R4, #+6]
   1173          	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
   \   00000116   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000118   0x2010             MOVS     R0,#+16
   \   0000011A   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   0000011E   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0xEB10 0x1041      ADDS     R0,R0,R1, LSL #+5
   \   00000128   0x3034             ADDS     R0,R0,#+52
   \   0000012A   0x6160             STR      R0,[R4, #+20]
   1174          
   1175          	return FR_OK;
   \   0000012C   0x2000             MOVS     R0,#+0
   \                     ??dir_next_2:
   \   0000012E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1176          }
   1177          
   1178          
   1179          
   1180          
   1181          /*-----------------------------------------------------------------------*/
   1182          /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
   1183          /*-----------------------------------------------------------------------*/
   1184          #if _USE_LFN
   1185          static

   \                                 In section .rodata, align 4
   1186          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
   \                     LfnOfs:
   \   00000000   0x01 0x03          DC8 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30, 0, 0, 0
   \              0x05 0x07    
   \              0x09 0x0E    
   \              0x10 0x12    
   \              0x14 0x16    
   \              0x18 0x1C    
   \              0x1E 0x00    
   \              0x00 0x00    
   1187          
   1188          

   \                                 In section .text, align 2, keep-with-next
   1189          static
   1190          int cmp_lfn (			/* 1:Matched, 0:Not matched */
   1191          	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
   1192          	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
   1193          )
   1194          {
   \                     cmp_lfn:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1195          	UINT i, s;
   1196          	WCHAR wc, uc;
   1197          
   1198          
   1199          	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x210D             MOVS     R1,#+13
   \   00000012   0xFB01 0xF600      MUL      R6,R1,R0
   1200          	s = 0; wc = 1;
   \   00000016   0x2700             MOVS     R7,#+0
   \   00000018   0xF05F 0x0801      MOVS     R8,#+1
   1201          	do {
   1202          		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
   \                     ??cmp_lfn_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000020   0x5C38             LDRB     R0,[R7, R0]
   \   00000022   0x1940             ADDS     R0,R0,R5
   \   00000024   0x7840             LDRB     R0,[R0, #+1]
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable9
   \   0000002A   0x5C79             LDRB     R1,[R7, R1]
   \   0000002C   0x5D49             LDRB     R1,[R1, R5]
   \   0000002E   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   1203          		if (wc) {	/* Last char has not been processed */
   \   00000032   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000036   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000003A   0xD011             BEQ.N    ??cmp_lfn_1
   1204          			wc = ff_wtoupper(uc);		/* Convert it to upper case */
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x.... 0x....      BL       ff_wtoupper
   \   00000042   0x4680             MOV      R8,R0
   1205          			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   \   00000044   0x2E40             CMP      R6,#+64
   \   00000046   0xD209             BCS.N    ??cmp_lfn_2
   \   00000048   0xF834 0x0016      LDRH     R0,[R4, R6, LSL #+1]
   \   0000004C   0x.... 0x....      BL       ff_wtoupper
   \   00000050   0x1C76             ADDS     R6,R6,#+1
   \   00000052   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000056   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000058   0x4580             CMP      R8,R0
   \   0000005A   0xD008             BEQ.N    ??cmp_lfn_3
   1206          				return 0;				/* Not matched */
   \                     ??cmp_lfn_2:
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE018             B.N      ??cmp_lfn_4
   1207          		} else {
   1208          			if (uc != 0xFFFF) return 0;	/* Check filler */
   \                     ??cmp_lfn_1:
   \   00000060   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000064   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xD001             BEQ.N    ??cmp_lfn_3
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE011             B.N      ??cmp_lfn_4
   1209          		}
   1210          	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
   \                     ??cmp_lfn_3:
   \   0000006E   0x1C7F             ADDS     R7,R7,#+1
   \   00000070   0x2F0D             CMP      R7,#+13
   \   00000072   0xD3D3             BCC.N    ??cmp_lfn_0
   1211          
   1212          	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
   \   00000074   0x7828             LDRB     R0,[R5, #+0]
   \   00000076   0x0640             LSLS     R0,R0,#+25
   \   00000078   0xD50A             BPL.N    ??cmp_lfn_5
   \   0000007A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000007E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000082   0xD005             BEQ.N    ??cmp_lfn_5
   \   00000084   0xF834 0x0016      LDRH     R0,[R4, R6, LSL #+1]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD001             BEQ.N    ??cmp_lfn_5
   1213          		return 0;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE000             B.N      ??cmp_lfn_4
   1214          
   1215          	return 1;						/* The part of LFN matched */
   \                     ??cmp_lfn_5:
   \   00000090   0x2001             MOVS     R0,#+1
   \                     ??cmp_lfn_4:
   \   00000092   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1216          }
   1217          
   1218          
   1219          

   \                                 In section .text, align 2, keep-with-next
   1220          static
   1221          int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
   1222          	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
   1223          	BYTE *dir			/* Pointer to the directory entry */
   1224          )
   1225          {
   \                     pick_lfn:
   \   00000000   0xB470             PUSH     {R4-R6}
   1226          	UINT i, s;
   1227          	WCHAR wc, uc;
   1228          
   1229          
   1230          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   00000008   0x1E52             SUBS     R2,R2,#+1
   \   0000000A   0x230D             MOVS     R3,#+13
   \   0000000C   0x435A             MULS     R2,R3,R2
   1231          
   1232          	s = 0; wc = 1;
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x2401             MOVS     R4,#+1
   1233          	do {
   1234          		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
   \                     ??pick_lfn_0:
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable9
   \   00000016   0x5D5D             LDRB     R5,[R3, R5]
   \   00000018   0x186D             ADDS     R5,R5,R1
   \   0000001A   0x786D             LDRB     R5,[R5, #+1]
   \   0000001C   0x.... 0x....      LDR.W    R6,??DataTable9
   \   00000020   0x5D9E             LDRB     R6,[R3, R6]
   \   00000022   0x5C76             LDRB     R6,[R6, R1]
   \   00000024   0xEA56 0x2505      ORRS     R5,R6,R5, LSL #+8
   1235          		if (wc) {	/* Last char has not been processed */
   \   00000028   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD011             BEQ.N    ??pick_lfn_1
   1236          			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   \   0000002E   0x2A40             CMP      R2,#+64
   \   00000030   0xD301             BCC.N    ??pick_lfn_2
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE018             B.N      ??pick_lfn_3
   1237          			lfnbuf[i++] = wc = uc;			/* Store it */
   \                     ??pick_lfn_2:
   \   00000036   0x002C             MOVS     R4,R5
   \   00000038   0xF820 0x4012      STRH     R4,[R0, R2, LSL #+1]
   \   0000003C   0x1C52             ADDS     R2,R2,#+1
   1238          		} else {
   1239          			if (uc != 0xFFFF) return 0;		/* Check filler */
   1240          		}
   1241          	} while (++s < 13);						/* Read all character in the entry */
   \                     ??pick_lfn_4:
   \   0000003E   0x1C5B             ADDS     R3,R3,#+1
   \   00000040   0x2B0D             CMP      R3,#+13
   \   00000042   0xD3E6             BCC.N    ??pick_lfn_0
   1242          
   1243          	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
   \   00000044   0x7809             LDRB     R1,[R1, #+0]
   \   00000046   0x0649             LSLS     R1,R1,#+25
   \   00000048   0xD50D             BPL.N    ??pick_lfn_5
   1244          		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   \   0000004A   0x2A40             CMP      R2,#+64
   \   0000004C   0xD308             BCC.N    ??pick_lfn_6
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE00A             B.N      ??pick_lfn_3
   \                     ??pick_lfn_1:
   \   00000052   0xF64F 0x76FF      MOVW     R6,#+65535
   \   00000056   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000058   0x42B5             CMP      R5,R6
   \   0000005A   0xD0F0             BEQ.N    ??pick_lfn_4
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE003             B.N      ??pick_lfn_3
   1245          		lfnbuf[i] = 0;
   \                     ??pick_lfn_6:
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0xF820 0x1012      STRH     R1,[R0, R2, LSL #+1]
   1246          	}
   1247          
   1248          	return 1;
   \                     ??pick_lfn_5:
   \   00000066   0x2001             MOVS     R0,#+1
   \                     ??pick_lfn_3:
   \   00000068   0xBC70             POP      {R4-R6}
   \   0000006A   0x4770             BX       LR               ;; return
   1249          }
   1250          
   1251          
   1252          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1253          static
   1254          void fit_lfn (
   1255          	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
   1256          	BYTE *dir,				/* Pointer to the directory entry */
   1257          	BYTE ord,				/* LFN order (1-20) */
   1258          	BYTE sum				/* SFN sum */
   1259          )
   1260          {
   \                     fit_lfn:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1261          	UINT i, s;
   1262          	WCHAR wc;
   1263          
   1264          
   1265          	dir[LDIR_Chksum] = sum;			/* Set check sum */
   \   00000002   0x734B             STRB     R3,[R1, #+13]
   1266          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   \   00000004   0x230F             MOVS     R3,#+15
   \   00000006   0x72CB             STRB     R3,[R1, #+11]
   1267          	dir[LDIR_Type] = 0;
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x730B             STRB     R3,[R1, #+12]
   1268          	ST_WORD(dir+LDIR_FstClusLO, 0);
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x768B             STRB     R3,[R1, #+26]
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x76CB             STRB     R3,[R1, #+27]
   1269          
   1270          	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x1E53             SUBS     R3,R2,#+1
   \   00000018   0x240D             MOVS     R4,#+13
   \   0000001A   0x4363             MULS     R3,R4,R3
   1271          	s = wc = 0;
   \   0000001C   0x2400             MOVS     R4,#+0
   \   0000001E   0x0025             MOVS     R5,R4
   \   00000020   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   1272          	do {
   1273          		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
   \                     ??fit_lfn_0:
   \   00000022   0xF64F 0x76FF      MOVW     R6,#+65535
   \   00000026   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000028   0x42B5             CMP      R5,R6
   \   0000002A   0xD002             BEQ.N    ??fit_lfn_1
   \   0000002C   0xF830 0x5013      LDRH     R5,[R0, R3, LSL #+1]
   \   00000030   0x1C5B             ADDS     R3,R3,#+1
   1274          		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
   \                     ??fit_lfn_1:
   \   00000032   0x.... 0x....      LDR.W    R6,??DataTable9
   \   00000036   0x5DA6             LDRB     R6,[R4, R6]
   \   00000038   0x5475             STRB     R5,[R6, R1]
   \   0000003A   0x.... 0x....      LDR.W    R6,??DataTable9
   \   0000003E   0x5DA6             LDRB     R6,[R4, R6]
   \   00000040   0x1876             ADDS     R6,R6,R1
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x0A2F             LSRS     R7,R5,#+8
   \   00000046   0x7077             STRB     R7,[R6, #+1]
   1275          		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD101             BNE.N    ??fit_lfn_2
   \   0000004E   0xF64F 0x75FF      MOVW     R5,#+65535
   1276          	} while (++s < 13);
   \                     ??fit_lfn_2:
   \   00000052   0x1C64             ADDS     R4,R4,#+1
   \   00000054   0x2C0D             CMP      R4,#+13
   \   00000056   0xD3E4             BCC.N    ??fit_lfn_0
   1277          	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
   \   00000058   0xF64F 0x74FF      MOVW     R4,#+65535
   \   0000005C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005E   0x42A5             CMP      R5,R4
   \   00000060   0xD003             BEQ.N    ??fit_lfn_3
   \   00000062   0xF830 0x0013      LDRH     R0,[R0, R3, LSL #+1]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD101             BNE.N    ??fit_lfn_4
   \                     ??fit_lfn_3:
   \   0000006A   0xF052 0x0240      ORRS     R2,R2,#0x40
   1278          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   \                     ??fit_lfn_4:
   \   0000006E   0x700A             STRB     R2,[R1, #+0]
   1279          }
   \   00000070   0xBCF0             POP      {R4-R7}
   \   00000072   0x4770             BX       LR               ;; return
   1280          
   1281          #endif
   1282          #endif
   1283          
   1284          
   1285          
   1286          /*-----------------------------------------------------------------------*/
   1287          /* Create numbered name                                                  */
   1288          /*-----------------------------------------------------------------------*/
   1289          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
   1290          void gen_numname (
   1291          	BYTE *dst,			/* Pointer to generated SFN */
   1292          	const BYTE *src,	/* Pointer to source SFN to be modified */
   1293          	const WCHAR *lfn,	/* Pointer to LFN */
   1294          	WORD seq			/* Sequence number */
   1295          )
   1296          {
   \                     gen_numname:
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0016             MOVS     R6,R2
   \   00000006   0x001D             MOVS     R5,R3
   1297          	BYTE ns[8], c;
   1298          	UINT i, j;
   1299          
   1300          
   1301          	mem_cpy(dst, src, 11);
   \   00000008   0x220B             MOVS     R2,#+11
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       mem_cpy
   1302          
   1303          	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
   \   00000010   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000012   0x2D06             CMP      R5,#+6
   \   00000014   0xD309             BCC.N    ??gen_numname_0
   1304          		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
   \                     ??gen_numname_1:
   \   00000016   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000018   0x03E8             LSLS     R0,R5,#+15
   \   0000001A   0xEB10 0x0055      ADDS     R0,R0,R5, LSR #+1
   \   0000001E   0x8831             LDRH     R1,[R6, #+0]
   \   00000020   0x180D             ADDS     R5,R1,R0
   \   00000022   0x1CB6             ADDS     R6,R6,#+2
   \   00000024   0x8830             LDRH     R0,[R6, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD1F5             BNE.N    ??gen_numname_1
   1305          	}
   1306          
   1307          	/* itoa (hexdecimal) */
   1308          	i = 7;
   \                     ??gen_numname_0:
   \   0000002A   0x2007             MOVS     R0,#+7
   1309          	do {
   1310          		c = (seq % 16) + '0';
   \                     ??gen_numname_2:
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x2110             MOVS     R1,#+16
   \   00000030   0xFB95 0xF2F1      SDIV     R2,R5,R1
   \   00000034   0xFB02 0x5211      MLS      R2,R2,R1,R5
   \   00000038   0xF112 0x0130      ADDS     R1,R2,#+48
   1311          		if (c > '9') c += 7;
   \   0000003C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003E   0x293A             CMP      R1,#+58
   \   00000040   0xD300             BCC.N    ??gen_numname_3
   \   00000042   0x1DC9             ADDS     R1,R1,#+7
   1312          		ns[i--] = c;
   \                     ??gen_numname_3:
   \   00000044   0xAA00             ADD      R2,SP,#+0
   \   00000046   0x5481             STRB     R1,[R0, R2]
   \   00000048   0x1E40             SUBS     R0,R0,#+1
   1313          		seq /= 16;
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0x2110             MOVS     R1,#+16
   \   0000004E   0xFB95 0xF5F1      SDIV     R5,R5,R1
   1314          	} while (seq);
   \   00000052   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD1E9             BNE.N    ??gen_numname_2
   1315          	ns[i] = '~';
   \   00000058   0xA900             ADD      R1,SP,#+0
   \   0000005A   0x227E             MOVS     R2,#+126
   \   0000005C   0x5442             STRB     R2,[R0, R1]
   1316          
   1317          	/* Append the number */
   1318          	for (j = 0; j < i && dst[j] != ' '; j++) {
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0xE000             B.N      ??gen_numname_4
   1319          		if (IsDBCS1(dst[j])) {
   \                     ??gen_numname_5:
   \   00000062   0x1C49             ADDS     R1,R1,#+1
   \                     ??gen_numname_4:
   \   00000064   0x4281             CMP      R1,R0
   \   00000066   0xD202             BCS.N    ??gen_numname_6
   \   00000068   0x5D0A             LDRB     R2,[R1, R4]
   \   0000006A   0x2A20             CMP      R2,#+32
   \   0000006C   0xD1F9             BNE.N    ??gen_numname_5
   1320          			if (j == i - 1) break;
   1321          			j++;
   1322          		}
   1323          	}
   1324          	do {
   1325          		dst[j++] = (i < 8) ? ns[i++] : ' ';
   \                     ??gen_numname_6:
   \   0000006E   0x000A             MOVS     R2,R1
   \   00000070   0x1C51             ADDS     R1,R2,#+1
   \   00000072   0x2808             CMP      R0,#+8
   \   00000074   0xD203             BCS.N    ??gen_numname_7
   \   00000076   0xAB00             ADD      R3,SP,#+0
   \   00000078   0x5CC3             LDRB     R3,[R0, R3]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0xE000             B.N      ??gen_numname_8
   \                     ??gen_numname_7:
   \   0000007E   0x2320             MOVS     R3,#+32
   \                     ??gen_numname_8:
   \   00000080   0x5513             STRB     R3,[R2, R4]
   1326          	} while (j < 8);
   \   00000082   0x2908             CMP      R1,#+8
   \   00000084   0xD3F3             BCC.N    ??gen_numname_6
   1327          }
   \   00000086   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1328          #endif
   1329          
   1330          
   1331          
   1332          
   1333          /*-----------------------------------------------------------------------*/
   1334          /* Calculate sum of an SFN                                               */
   1335          /*-----------------------------------------------------------------------*/
   1336          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
   1337          static
   1338          BYTE sum_sfn (
   1339          	const BYTE *dir		/* Ptr to directory entry */
   1340          )
   1341          {
   1342          	BYTE sum = 0;
   \                     sum_sfn:
   \   00000000   0x2100             MOVS     R1,#+0
   1343          	UINT n = 11;
   \   00000002   0x220B             MOVS     R2,#+11
   1344          
   1345          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   \                     ??sum_sfn_0:
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x01CB             LSLS     R3,R1,#+7
   \   00000008   0xEB13 0x0151      ADDS     R1,R3,R1, LSR #+1
   \   0000000C   0x7803             LDRB     R3,[R0, #+0]
   \   0000000E   0x1859             ADDS     R1,R3,R1
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x1E52             SUBS     R2,R2,#+1
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD1F5             BNE.N    ??sum_sfn_0
   1346          	return sum;
   \   00000018   0x0008             MOVS     R0,R1
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x4770             BX       LR               ;; return
   1347          }
   1348          #endif
   1349          
   1350          
   1351          
   1352          
   1353          /*-----------------------------------------------------------------------*/
   1354          /* Directory handling - Find an object in the directory                  */
   1355          /*-----------------------------------------------------------------------*/
   1356          

   \                                 In section .text, align 2, keep-with-next
   1357          static
   1358          FRESULT dir_find (
   1359          	DIR *dj			/* Pointer to the directory object linked to the file name */
   1360          )
   1361          {
   \                     dir_find:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   1362          	FRESULT res;
   1363          	BYTE c, *dir;
   1364          #if _USE_LFN
   1365          	BYTE a, ord, sum;
   1366          #endif
   1367          
   1368          	res = dir_sdi(dj, 0);			/* Rewind directory object */
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0028             MOVS     R0,R5
   \   0000000A   0x.... 0x....      BL       dir_sdi
   \   0000000E   0x0004             MOVS     R4,R0
   1369          	if (res != FR_OK) return res;
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD002             BEQ.N    ??dir_find_0
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xE026             B.N      ??dir_find_1
   1370          
   1371          #if _USE_LFN
   1372          	ord = sum = 0xFF;
   \                     ??dir_find_0:
   \   0000001C   0x27FF             MOVS     R7,#+255
   \   0000001E   0x46B8             MOV      R8,R7
   1373          #endif
   1374          	do {
   1375          		res = move_window(dj->fs, dj->sect);
   \                     ??dir_find_2:
   \   00000020   0x6929             LDR      R1,[R5, #+16]
   \   00000022   0x6828             LDR      R0,[R5, #+0]
   \   00000024   0x.... 0x....      BL       move_window
   \   00000028   0x0004             MOVS     R4,R0
   1376          		if (res != FR_OK) break;
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD11A             BNE.N    ??dir_find_3
   1377          		dir = dj->dir;					/* Ptr to the directory entry of current index */
   \                     ??dir_find_4:
   \   00000030   0x696E             LDR      R6,[R5, #+20]
   1378          		c = dir[DIR_Name];
   \   00000032   0x7830             LDRB     R0,[R6, #+0]
   1379          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD101             BNE.N    ??dir_find_5
   \   0000003A   0x2404             MOVS     R4,#+4
   \   0000003C   0xE013             B.N      ??dir_find_3
   1380          #if _USE_LFN	/* LFN configuration */
   1381          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_find_5:
   \   0000003E   0x7AF1             LDRB     R1,[R6, #+11]
   \   00000040   0xF011 0x013F      ANDS     R1,R1,#0x3F
   1382          		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x28E5             CMP      R0,#+229
   \   00000048   0xD004             BEQ.N    ??dir_find_6
   \   0000004A   0x070A             LSLS     R2,R1,#+28
   \   0000004C   0xD50F             BPL.N    ??dir_find_7
   \   0000004E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000050   0x290F             CMP      R1,#+15
   \   00000052   0xD00C             BEQ.N    ??dir_find_7
   1383          			ord = 0xFF;
   \                     ??dir_find_6:
   \   00000054   0x27FF             MOVS     R7,#+255
   1384          		} else {
   1385          			if (a == AM_LFN) {			/* An LFN entry is found */
   1386          				if (dj->lfn) {
   1387          					if (c & LLE) {		/* Is it start of LFN sequence? */
   1388          						sum = dir[LDIR_Chksum];
   1389          						c &= ~LLE; ord = c;	/* LFN start order */
   1390          						dj->lfn_idx = dj->index;
   1391          					}
   1392          					/* Check validity of the LFN entry and compare it with given name */
   1393          					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1394          				}
   1395          			} else {					/* An SFN entry is found */
   1396          				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   1397          				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1398          				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
   1399          			}
   1400          		}
   1401          #else		/* Non LFN configuration */
   1402          		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
   1403          			break;
   1404          #endif
   1405          		res = dir_next(dj, 0);		/* Next entry */
   \                     ??dir_find_8:
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0x.... 0x....      BL       dir_next
   \   0000005E   0x0004             MOVS     R4,R0
   1406          	} while (res == FR_OK);
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x2C00             CMP      R4,#+0
   \   00000064   0xD0DC             BEQ.N    ??dir_find_2
   1407          
   1408          	return res;
   \                     ??dir_find_3:
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??dir_find_1:
   \   0000006A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??dir_find_7:
   \   0000006E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000070   0x290F             CMP      R1,#+15
   \   00000072   0xD11E             BNE.N    ??dir_find_9
   \   00000074   0x69E9             LDR      R1,[R5, #+28]
   \   00000076   0x2900             CMP      R1,#+0
   \   00000078   0xD0ED             BEQ.N    ??dir_find_8
   \   0000007A   0x0641             LSLS     R1,R0,#+25
   \   0000007C   0xD506             BPL.N    ??dir_find_10
   \   0000007E   0xF896 0x800D      LDRB     R8,[R6, #+13]
   \   00000082   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000086   0x0007             MOVS     R7,R0
   \   00000088   0x88E9             LDRH     R1,[R5, #+6]
   \   0000008A   0x8429             STRH     R1,[R5, #+32]
   \                     ??dir_find_10:
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000090   0x42B8             CMP      R0,R7
   \   00000092   0xD10C             BNE.N    ??dir_find_11
   \   00000094   0x7B70             LDRB     R0,[R6, #+13]
   \   00000096   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009A   0x4580             CMP      R8,R0
   \   0000009C   0xD107             BNE.N    ??dir_find_11
   \   0000009E   0x0031             MOVS     R1,R6
   \   000000A0   0x69E8             LDR      R0,[R5, #+28]
   \   000000A2   0x.... 0x....      BL       cmp_lfn
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD001             BEQ.N    ??dir_find_11
   \   000000AA   0x1E7F             SUBS     R7,R7,#+1
   \   000000AC   0xE000             B.N      ??dir_find_12
   \                     ??dir_find_11:
   \   000000AE   0x27FF             MOVS     R7,#+255
   \                     ??dir_find_12:
   \   000000B0   0xE7D1             B.N      ??dir_find_8
   \                     ??dir_find_9:
   \   000000B2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B4   0x2F00             CMP      R7,#+0
   \   000000B6   0xD106             BNE.N    ??dir_find_13
   \   000000B8   0x0030             MOVS     R0,R6
   \   000000BA   0x.... 0x....      BL       sum_sfn
   \   000000BE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C2   0x4580             CMP      R8,R0
   \   000000C4   0xD0CF             BEQ.N    ??dir_find_3
   \                     ??dir_find_13:
   \   000000C6   0x27FF             MOVS     R7,#+255
   \   000000C8   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000CC   0x8428             STRH     R0,[R5, #+32]
   \   000000CE   0x69A8             LDR      R0,[R5, #+24]
   \   000000D0   0x7AC0             LDRB     R0,[R0, #+11]
   \   000000D2   0x07C0             LSLS     R0,R0,#+31
   \   000000D4   0xD4BF             BMI.N    ??dir_find_8
   \   000000D6   0x220B             MOVS     R2,#+11
   \   000000D8   0x69A9             LDR      R1,[R5, #+24]
   \   000000DA   0x0030             MOVS     R0,R6
   \   000000DC   0x.... 0x....      BL       mem_cmp
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD1B8             BNE.N    ??dir_find_8
   \   000000E4   0xE7BF             B.N      ??dir_find_3
   1409          }
   1410          
   1411          
   1412          
   1413          
   1414          /*-----------------------------------------------------------------------*/
   1415          /* Read an object from the directory                                     */
   1416          /*-----------------------------------------------------------------------*/
   1417          #if _FS_MINIMIZE <= 1

   \                                 In section .text, align 2, keep-with-next
   1418          static
   1419          FRESULT dir_read (
   1420          	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
   1421          )
   1422          {
   \                     dir_read:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1423          	FRESULT res;
   1424          	BYTE c, *dir;
   1425          #if _USE_LFN
   1426          	BYTE a, ord = 0xFF, sum = 0xFF;
   \   00000004   0x26FF             MOVS     R6,#+255
   \   00000006   0x27FF             MOVS     R7,#+255
   1427          #endif
   1428          
   1429          	res = FR_NO_FILE;
   \   00000008   0x2504             MOVS     R5,#+4
   1430          	while (dj->sect) {
   \                     ??dir_read_0:
   \   0000000A   0x6920             LDR      R0,[R4, #+16]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD022             BEQ.N    ??dir_read_1
   1431          		res = move_window(dj->fs, dj->sect);
   \   00000010   0x6921             LDR      R1,[R4, #+16]
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       move_window
   \   00000018   0x0005             MOVS     R5,R0
   1432          		if (res != FR_OK) break;
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD11A             BNE.N    ??dir_read_1
   1433          		dir = dj->dir;					/* Ptr to the directory entry of current index */
   \                     ??dir_read_2:
   \   00000020   0x6960             LDR      R0,[R4, #+20]
   1434          		c = dir[DIR_Name];
   \   00000022   0x7801             LDRB     R1,[R0, #+0]
   1435          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   00000024   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD101             BNE.N    ??dir_read_3
   \   0000002A   0x2504             MOVS     R5,#+4
   \   0000002C   0xE013             B.N      ??dir_read_1
   1436          #if _USE_LFN	/* LFN configuration */
   1437          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_read_3:
   \   0000002E   0x7AC2             LDRB     R2,[R0, #+11]
   \   00000030   0xF012 0x023F      ANDS     R2,R2,#0x3F
   1438          		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0x29E5             CMP      R1,#+229
   \   00000038   0xD004             BEQ.N    ??dir_read_4
   \   0000003A   0x0713             LSLS     R3,R2,#+28
   \   0000003C   0xD513             BPL.N    ??dir_read_5
   \   0000003E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   0x2A0F             CMP      R2,#+15
   \   00000042   0xD010             BEQ.N    ??dir_read_5
   1439          			ord = 0xFF;
   \                     ??dir_read_4:
   \   00000044   0x26FF             MOVS     R6,#+255
   1440          		} else {
   1441          			if (a == AM_LFN) {			/* An LFN entry is found */
   1442          				if (c & LLE) {			/* Is it start of LFN sequence? */
   1443          					sum = dir[LDIR_Chksum];
   1444          					c &= ~LLE; ord = c;
   1445          					dj->lfn_idx = dj->index;
   1446          				}
   1447          				/* Check LFN validity and capture it */
   1448          				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1449          			} else {					/* An SFN entry is found */
   1450          				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
   1451          					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
   1452          				break;
   1453          			}
   1454          		}
   1455          #else		/* Non LFN configuration */
   1456          		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
   1457          			break;
   1458          #endif
   1459          		res = dir_next(dj, 0);				/* Next entry */
   \                     ??dir_read_6:
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       dir_next
   \   0000004E   0x0005             MOVS     R5,R0
   1460          		if (res != FR_OK) break;
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD0D9             BEQ.N    ??dir_read_0
   1461          	}
   1462          
   1463          	if (res != FR_OK) dj->sect = 0;
   \                     ??dir_read_1:
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x2D00             CMP      R5,#+0
   \   0000005A   0xD001             BEQ.N    ??dir_read_7
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x6120             STR      R0,[R4, #+16]
   1464          
   1465          	return res;
   \                     ??dir_read_7:
   \   00000060   0x0028             MOVS     R0,R5
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??dir_read_5:
   \   00000066   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000068   0x2A0F             CMP      R2,#+15
   \   0000006A   0xD119             BNE.N    ??dir_read_8
   \   0000006C   0x064A             LSLS     R2,R1,#+25
   \   0000006E   0xD505             BPL.N    ??dir_read_9
   \   00000070   0x7B47             LDRB     R7,[R0, #+13]
   \   00000072   0xF011 0x01BF      ANDS     R1,R1,#0xBF
   \   00000076   0x000E             MOVS     R6,R1
   \   00000078   0x88E2             LDRH     R2,[R4, #+6]
   \   0000007A   0x8422             STRH     R2,[R4, #+32]
   \                     ??dir_read_9:
   \   0000007C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000080   0x42B1             CMP      R1,R6
   \   00000082   0xD10B             BNE.N    ??dir_read_10
   \   00000084   0x7B41             LDRB     R1,[R0, #+13]
   \   00000086   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000088   0x428F             CMP      R7,R1
   \   0000008A   0xD107             BNE.N    ??dir_read_10
   \   0000008C   0x0001             MOVS     R1,R0
   \   0000008E   0x69E0             LDR      R0,[R4, #+28]
   \   00000090   0x.... 0x....      BL       pick_lfn
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD001             BEQ.N    ??dir_read_10
   \   00000098   0x1E76             SUBS     R6,R6,#+1
   \   0000009A   0xE000             B.N      ??dir_read_11
   \                     ??dir_read_10:
   \   0000009C   0x26FF             MOVS     R6,#+255
   \                     ??dir_read_11:
   \   0000009E   0xE7D2             B.N      ??dir_read_6
   \                     ??dir_read_8:
   \   000000A0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A2   0x2E00             CMP      R6,#+0
   \   000000A4   0xD104             BNE.N    ??dir_read_12
   \   000000A6   0x.... 0x....      BL       sum_sfn
   \   000000AA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000AC   0x4287             CMP      R7,R0
   \   000000AE   0xD002             BEQ.N    ??dir_read_13
   \                     ??dir_read_12:
   \   000000B0   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000B4   0x8420             STRH     R0,[R4, #+32]
   \                     ??dir_read_13:
   \   000000B6   0xE7CE             B.N      ??dir_read_1
   1466          }
   1467          #endif
   1468          
   1469          
   1470          
   1471          /*-----------------------------------------------------------------------*/
   1472          /* Register an object to the directory                                   */
   1473          /*-----------------------------------------------------------------------*/
   1474          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1475          static
   1476          FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
   1477          	DIR *dj				/* Target directory with object name to be created */
   1478          )
   1479          {
   \                     dir_register:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   1480          	FRESULT res;
   1481          	BYTE c, *dir;
   1482          #if _USE_LFN	/* LFN configuration */
   1483          	WORD n, ne, is;
   1484          	BYTE sn[12], *fn, sum;
   1485          	WCHAR *lfn;
   1486          
   1487          
   1488          	fn = dj->fn; lfn = dj->lfn;
   \   00000008   0x69A7             LDR      R7,[R4, #+24]
   \   0000000A   0x69E6             LDR      R6,[R4, #+28]
   1489          	mem_cpy(sn, fn, 12);
   \   0000000C   0x220C             MOVS     R2,#+12
   \   0000000E   0x0039             MOVS     R1,R7
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       mem_cpy
   1490          
   1491          	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
   \   00000016   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   0000001A   0x0680             LSLS     R0,R0,#+26
   \   0000001C   0xD501             BPL.N    ??dir_register_0
   1492          		return FR_INVALID_NAME;
   \   0000001E   0x2006             MOVS     R0,#+6
   \   00000020   0xE0CE             B.N      ??dir_register_1
   1493          
   1494          	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   \                     ??dir_register_0:
   \   00000022   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000026   0x07C0             LSLS     R0,R0,#+31
   \   00000028   0xD52C             BPL.N    ??dir_register_2
   1495          		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x72F8             STRB     R0,[R7, #+11]
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x61E0             STR      R0,[R4, #+28]
   1496          		for (n = 1; n < 100; n++) {
   \   00000032   0xF05F 0x0801      MOVS     R8,#+1
   \   00000036   0xE001             B.N      ??dir_register_3
   \                     ??dir_register_4:
   \   00000038   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??dir_register_3:
   \   0000003C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000040   0xF1B8 0x0F64      CMP      R8,#+100
   \   00000044   0xD20D             BCS.N    ??dir_register_5
   1497          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   \   00000046   0x4643             MOV      R3,R8
   \   00000048   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000004A   0x0032             MOVS     R2,R6
   \   0000004C   0xA900             ADD      R1,SP,#+0
   \   0000004E   0x0038             MOVS     R0,R7
   \   00000050   0x.... 0x....      BL       gen_numname
   1498          			res = dir_find(dj);				/* Check if the name collides with existing SFN */
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       dir_find
   \   0000005A   0x0005             MOVS     R5,R0
   1499          			if (res != FR_OK) break;
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD0EA             BEQ.N    ??dir_register_4
   1500          		}
   1501          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   \                     ??dir_register_5:
   \   00000062   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000066   0xF1B8 0x0F64      CMP      R8,#+100
   \   0000006A   0xD101             BNE.N    ??dir_register_6
   \   0000006C   0x2007             MOVS     R0,#+7
   \   0000006E   0xE0A7             B.N      ??dir_register_1
   1502          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   \                     ??dir_register_6:
   \   00000070   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000072   0x2D04             CMP      R5,#+4
   \   00000074   0xD002             BEQ.N    ??dir_register_7
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0xE0A1             B.N      ??dir_register_1
   1503          		fn[NS] = sn[NS]; dj->lfn = lfn;
   \                     ??dir_register_7:
   \   0000007C   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000080   0x72F8             STRB     R0,[R7, #+11]
   \   00000082   0x61E6             STR      R6,[R4, #+28]
   1504          	}
   1505          
   1506          	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
   \                     ??dir_register_2:
   \   00000084   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000088   0x0780             LSLS     R0,R0,#+30
   \   0000008A   0xD50E             BPL.N    ??dir_register_8
   1507          		for (ne = 0; lfn[ne]; ne++) ;
   \   0000008C   0x2700             MOVS     R7,#+0
   \   0000008E   0xE000             B.N      ??dir_register_9
   \                     ??dir_register_10:
   \   00000090   0x1C7F             ADDS     R7,R7,#+1
   \                     ??dir_register_9:
   \   00000092   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000094   0xF836 0x0017      LDRH     R0,[R6, R7, LSL #+1]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD1F9             BNE.N    ??dir_register_10
   1508          		ne = (ne + 25) / 13;
   \   0000009C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000009E   0xF117 0x0019      ADDS     R0,R7,#+25
   \   000000A2   0x210D             MOVS     R1,#+13
   \   000000A4   0xFB90 0xF7F1      SDIV     R7,R0,R1
   \   000000A8   0xE000             B.N      ??dir_register_11
   1509          	} else {						/* Otherwise reserve only an SFN entry. */
   1510          		ne = 1;
   \                     ??dir_register_8:
   \   000000AA   0x2701             MOVS     R7,#+1
   1511          	}
   1512          
   1513          	/* Reserve contiguous entries */
   1514          	res = dir_sdi(dj, 0);
   \                     ??dir_register_11:
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       dir_sdi
   \   000000B4   0x0005             MOVS     R5,R0
   1515          	if (res != FR_OK) return res;
   \   000000B6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B8   0x2D00             CMP      R5,#+0
   \   000000BA   0xD002             BEQ.N    ??dir_register_12
   \   000000BC   0x0028             MOVS     R0,R5
   \   000000BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C0   0xE07E             B.N      ??dir_register_1
   1516          	n = is = 0;
   \                     ??dir_register_12:
   \   000000C2   0xF05F 0x0800      MOVS     R8,#+0
   \   000000C6   0x4646             MOV      R6,R8
   1517          	do {
   1518          		res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_13:
   \   000000C8   0x6921             LDR      R1,[R4, #+16]
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x.... 0x....      BL       move_window
   \   000000D0   0x0005             MOVS     R5,R0
   1519          		if (res != FR_OK) break;
   \   000000D2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D4   0x2D00             CMP      R5,#+0
   \   000000D6   0xD11F             BNE.N    ??dir_register_14
   1520          		c = *dj->dir;				/* Check the entry status */
   \                     ??dir_register_15:
   \   000000D8   0x6960             LDR      R0,[R4, #+20]
   \   000000DA   0x7800             LDRB     R0,[R0, #+0]
   1521          		if (c == DDE || c == 0) {	/* Is it a blank entry? */
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0x28E5             CMP      R0,#+229
   \   000000E0   0xD002             BEQ.N    ??dir_register_16
   \   000000E2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD10D             BNE.N    ??dir_register_17
   1522          			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
   \                     ??dir_register_16:
   \   000000E8   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000EC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000F0   0xD100             BNE.N    ??dir_register_18
   \   000000F2   0x88E6             LDRH     R6,[R4, #+6]
   1523          			if (++n == ne) break;	/* A contiguous entry that required count is found */
   \                     ??dir_register_18:
   \   000000F4   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000F8   0x4640             MOV      R0,R8
   \   000000FA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000FC   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000FE   0x42B8             CMP      R0,R7
   \   00000100   0xD102             BNE.N    ??dir_register_19
   \   00000102   0xE009             B.N      ??dir_register_14
   1524          		} else {
   1525          			n = 0;					/* Not a blank entry. Restart to search */
   \                     ??dir_register_17:
   \   00000104   0xF05F 0x0800      MOVS     R8,#+0
   1526          		}
   1527          		res = dir_next(dj, 1);		/* Next entry with table stretch */
   \                     ??dir_register_19:
   \   00000108   0x2101             MOVS     R1,#+1
   \   0000010A   0x0020             MOVS     R0,R4
   \   0000010C   0x.... 0x....      BL       dir_next
   \   00000110   0x0005             MOVS     R5,R0
   1528          	} while (res == FR_OK);
   \   00000112   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000114   0x2D00             CMP      R5,#+0
   \   00000116   0xD0D7             BEQ.N    ??dir_register_13
   1529          
   1530          	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
   \                     ??dir_register_14:
   \   00000118   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011A   0x2D00             CMP      R5,#+0
   \   0000011C   0xD130             BNE.N    ??dir_register_20
   \   0000011E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000120   0x2F02             CMP      R7,#+2
   \   00000122   0xD32D             BCC.N    ??dir_register_20
   1531          		res = dir_sdi(dj, is);
   \   00000124   0x0031             MOVS     R1,R6
   \   00000126   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000128   0x0020             MOVS     R0,R4
   \   0000012A   0x.... 0x....      BL       dir_sdi
   \   0000012E   0x0005             MOVS     R5,R0
   1532          		if (res == FR_OK) {
   \   00000130   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000132   0x2D00             CMP      R5,#+0
   \   00000134   0xD124             BNE.N    ??dir_register_20
   1533          			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
   \   00000136   0x69A0             LDR      R0,[R4, #+24]
   \   00000138   0x.... 0x....      BL       sum_sfn
   \   0000013C   0x0006             MOVS     R6,R0
   1534          			ne--;
   \   0000013E   0x1E7F             SUBS     R7,R7,#+1
   1535          			do {					/* Store LFN entries in bottom first */
   1536          				res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_21:
   \   00000140   0x6921             LDR      R1,[R4, #+16]
   \   00000142   0x6820             LDR      R0,[R4, #+0]
   \   00000144   0x.... 0x....      BL       move_window
   \   00000148   0x0005             MOVS     R5,R0
   1537          				if (res != FR_OK) break;
   \   0000014A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000014C   0x2D00             CMP      R5,#+0
   \   0000014E   0xD117             BNE.N    ??dir_register_20
   1538          				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
   \                     ??dir_register_22:
   \   00000150   0x0033             MOVS     R3,R6
   \   00000152   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000154   0x003A             MOVS     R2,R7
   \   00000156   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000158   0x6961             LDR      R1,[R4, #+20]
   \   0000015A   0x69E0             LDR      R0,[R4, #+28]
   \   0000015C   0x.... 0x....      BL       fit_lfn
   1539          				dj->fs->wflag = 1;
   \   00000160   0x6820             LDR      R0,[R4, #+0]
   \   00000162   0x2101             MOVS     R1,#+1
   \   00000164   0x7101             STRB     R1,[R0, #+4]
   1540          				res = dir_next(dj, 0);	/* Next entry */
   \   00000166   0x2100             MOVS     R1,#+0
   \   00000168   0x0020             MOVS     R0,R4
   \   0000016A   0x.... 0x....      BL       dir_next
   \   0000016E   0x0005             MOVS     R5,R0
   1541          			} while (res == FR_OK && --ne);
   \   00000170   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000172   0x2D00             CMP      R5,#+0
   \   00000174   0xD104             BNE.N    ??dir_register_20
   \   00000176   0x1E7F             SUBS     R7,R7,#+1
   \   00000178   0x0038             MOVS     R0,R7
   \   0000017A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000017C   0x2800             CMP      R0,#+0
   \   0000017E   0xD1DF             BNE.N    ??dir_register_21
   1542          		}
   1543          	}
   1544          
   1545          #else	/* Non LFN configuration */
   1546          	res = dir_sdi(dj, 0);
   1547          	if (res == FR_OK) {
   1548          		do {	/* Find a blank entry for the SFN */
   1549          			res = move_window(dj->fs, dj->sect);
   1550          			if (res != FR_OK) break;
   1551          			c = *dj->dir;
   1552          			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
   1553          			res = dir_next(dj, 1);			/* Next entry with table stretch */
   1554          		} while (res == FR_OK);
   1555          	}
   1556          #endif
   1557          
   1558          	if (res == FR_OK) {		/* Initialize the SFN entry */
   \                     ??dir_register_20:
   \   00000180   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000182   0x2D00             CMP      R5,#+0
   \   00000184   0xD11A             BNE.N    ??dir_register_23
   1559          		res = move_window(dj->fs, dj->sect);
   \   00000186   0x6921             LDR      R1,[R4, #+16]
   \   00000188   0x6820             LDR      R0,[R4, #+0]
   \   0000018A   0x.... 0x....      BL       move_window
   \   0000018E   0x0005             MOVS     R5,R0
   1560          		if (res == FR_OK) {
   \   00000190   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000192   0x2D00             CMP      R5,#+0
   \   00000194   0xD112             BNE.N    ??dir_register_23
   1561          			dir = dj->dir;
   \   00000196   0x6966             LDR      R6,[R4, #+20]
   1562          			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
   \   00000198   0x2220             MOVS     R2,#+32
   \   0000019A   0x2100             MOVS     R1,#+0
   \   0000019C   0x0030             MOVS     R0,R6
   \   0000019E   0x.... 0x....      BL       mem_set
   1563          			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
   \   000001A2   0x220B             MOVS     R2,#+11
   \   000001A4   0x69A1             LDR      R1,[R4, #+24]
   \   000001A6   0x0030             MOVS     R0,R6
   \   000001A8   0x.... 0x....      BL       mem_cpy
   1564          #if _USE_LFN
   1565          			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
   \   000001AC   0x69A0             LDR      R0,[R4, #+24]
   \   000001AE   0x7AC0             LDRB     R0,[R0, #+11]
   \   000001B0   0xF010 0x0018      ANDS     R0,R0,#0x18
   \   000001B4   0x7330             STRB     R0,[R6, #+12]
   1566          #endif
   1567          			dj->fs->wflag = 1;
   \   000001B6   0x6820             LDR      R0,[R4, #+0]
   \   000001B8   0x2101             MOVS     R1,#+1
   \   000001BA   0x7101             STRB     R1,[R0, #+4]
   1568          		}
   1569          	}
   1570          
   1571          	return res;
   \                     ??dir_register_23:
   \   000001BC   0x0028             MOVS     R0,R5
   \   000001BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??dir_register_1:
   \   000001C0   0xB004             ADD      SP,SP,#+16
   \   000001C2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1572          }
   1573          #endif /* !_FS_READONLY */
   1574          
   1575          
   1576          
   1577          
   1578          /*-----------------------------------------------------------------------*/
   1579          /* Remove an object from the directory                                   */
   1580          /*-----------------------------------------------------------------------*/
   1581          #if !_FS_READONLY && !_FS_MINIMIZE

   \                                 In section .text, align 2, keep-with-next
   1582          static
   1583          FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
   1584          	DIR *dj				/* Directory object pointing the entry to be removed */
   1585          )
   1586          {
   \                     dir_remove:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1587          	FRESULT res;
   1588          #if _USE_LFN	/* LFN configuration */
   1589          	WORD i;
   1590          
   1591          	i = dj->index;	/* SFN index */
   \   00000004   0x88E5             LDRH     R5,[R4, #+6]
   1592          	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
   \   00000006   0x8C20             LDRH     R0,[R4, #+32]
   \   00000008   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD101             BNE.N    ??dir_remove_0
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0xE000             B.N      ??dir_remove_1
   \                     ??dir_remove_0:
   \   00000014   0x8C21             LDRH     R1,[R4, #+32]
   \                     ??dir_remove_1:
   \   00000016   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       dir_sdi
   1593          	if (res == FR_OK) {
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD11B             BNE.N    ??dir_remove_2
   1594          		do {
   1595          			res = move_window(dj->fs, dj->sect);
   \                     ??dir_remove_3:
   \   00000024   0x6921             LDR      R1,[R4, #+16]
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       move_window
   1596          			if (res != FR_OK) break;
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD110             BNE.N    ??dir_remove_4
   1597          			*dj->dir = DDE;			/* Mark the entry "deleted" */
   \                     ??dir_remove_5:
   \   00000032   0x6961             LDR      R1,[R4, #+20]
   \   00000034   0x22E5             MOVS     R2,#+229
   \   00000036   0x700A             STRB     R2,[R1, #+0]
   1598          			dj->fs->wflag = 1;
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x710A             STRB     R2,[R1, #+4]
   1599          			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   \   0000003E   0x88E1             LDRH     R1,[R4, #+6]
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0x42A9             CMP      R1,R5
   \   00000044   0xD206             BCS.N    ??dir_remove_4
   1600          			res = dir_next(dj, 0);		/* Next entry */
   \                     ??dir_remove_6:
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       dir_next
   1601          		} while (res == FR_OK);
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD0E7             BEQ.N    ??dir_remove_3
   1602          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   \                     ??dir_remove_4:
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x2804             CMP      R0,#+4
   \   00000058   0xD100             BNE.N    ??dir_remove_2
   \   0000005A   0x2002             MOVS     R0,#+2
   1603          	}
   1604          
   1605          #else			/* Non LFN configuration */
   1606          	res = dir_sdi(dj, dj->index);
   1607          	if (res == FR_OK) {
   1608          		res = move_window(dj->fs, dj->sect);
   1609          		if (res == FR_OK) {
   1610          			*dj->dir = DDE;			/* Mark the entry "deleted" */
   1611          			dj->fs->wflag = 1;
   1612          		}
   1613          	}
   1614          #endif
   1615          
   1616          	return res;
   \                     ??dir_remove_2:
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1617          }
   1618          #endif /* !_FS_READONLY */
   1619          
   1620          
   1621          
   1622          
   1623          /*-----------------------------------------------------------------------*/
   1624          /* Pick a segment and create the object name in directory form           */
   1625          /*-----------------------------------------------------------------------*/
   1626          

   \                                 In section .text, align 2, keep-with-next
   1627          static
   1628          FRESULT create_name (
   1629          	DIR *dj,			/* Pointer to the directory object */
   1630          	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
   1631          )
   1632          {
   \                     create_name:
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0x4688             MOV      R8,R1
   1633          #ifdef _EXCVT
   1634          	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
   1635          #endif
   1636          
   1637          #if _USE_LFN	/* LFN configuration */
   1638          	BYTE b, cf;
   1639          	WCHAR w, *lfn;
   1640          	UINT i, ni, si, di;
   1641          	const TCHAR *p;
   1642          
   1643          	/* Create LFN in Unicode */
   1644          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   \   00000006   0xF8D8 0x9000      LDR      R9,[R8, #+0]
   \   0000000A   0xE001             B.N      ??create_name_0
   \                     ??create_name_1:
   \   0000000C   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??create_name_0:
   \   00000010   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000014   0x282F             CMP      R0,#+47
   \   00000016   0xD0F9             BEQ.N    ??create_name_1
   \   00000018   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000001C   0x285C             CMP      R0,#+92
   \   0000001E   0xD0F5             BEQ.N    ??create_name_1
   1645          	lfn = dj->lfn;
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x69C6             LDR      R6,[R0, #+28]
   1646          	si = di = 0;
   \   00000024   0x2400             MOVS     R4,#+0
   \   00000026   0x0025             MOVS     R5,R4
   \   00000028   0xE002             B.N      ??create_name_2
   1647          	for (;;) {
   1648          		w = p[si++];					/* Get a character */
   1649          		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   1650          		if (di >= _MAX_LFN)				/* Reject too long name */
   1651          			return FR_INVALID_NAME;
   1652          #if !_LFN_UNICODE
   1653          		w &= 0xFF;
   1654          		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1655          			b = (BYTE)p[si++];			/* Get 2nd byte */
   1656          			if (!IsDBCS2(b))
   1657          				return FR_INVALID_NAME;	/* Reject invalid sequence */
   1658          			w = (w << 8) + b;			/* Create a DBC */
   1659          		}
   1660          		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   1661          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   1662          #endif
   1663          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
   1664          			return FR_INVALID_NAME;
   1665          		lfn[di++] = w;					/* Store the Unicode char */
   \                     ??create_name_3:
   \   0000002A   0xF826 0x7015      STRH     R7,[R6, R5, LSL #+1]
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??create_name_2:
   \   00000030   0xF814 0x7009      LDRB     R7,[R4, R9]
   \   00000034   0x1C64             ADDS     R4,R4,#+1
   \   00000036   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000038   0x2F20             CMP      R7,#+32
   \   0000003A   0xD305             BCC.N    ??create_name_4
   \   0000003C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003E   0x2F2F             CMP      R7,#+47
   \   00000040   0xD002             BEQ.N    ??create_name_4
   \   00000042   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000044   0x2F5C             CMP      R7,#+92
   \   00000046   0xD109             BNE.N    ??create_name_5
   1666          	}
   1667          	*path = &p[si];						/* Return pointer to the next segment */
   \                     ??create_name_4:
   \   00000048   0xEB14 0x0009      ADDS     R0,R4,R9
   \   0000004C   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1668          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   \   00000050   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000052   0x2F20             CMP      R7,#+32
   \   00000054   0xD21F             BCS.N    ??create_name_6
   \   00000056   0xF05F 0x0804      MOVS     R8,#+4
   \   0000005A   0xE01E             B.N      ??create_name_7
   \                     ??create_name_5:
   \   0000005C   0x2D40             CMP      R5,#+64
   \   0000005E   0xD301             BCC.N    ??create_name_8
   \   00000060   0x2006             MOVS     R0,#+6
   \   00000062   0xE0C1             B.N      ??create_name_9
   \                     ??create_name_8:
   \   00000064   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x0038             MOVS     R0,R7
   \   0000006A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006C   0x.... 0x....      BL       ff_convert
   \   00000070   0x0007             MOVS     R7,R0
   \   00000072   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000074   0x2F00             CMP      R7,#+0
   \   00000076   0xD101             BNE.N    ??create_name_10
   \   00000078   0x2006             MOVS     R0,#+6
   \   0000007A   0xE0B5             B.N      ??create_name_9
   \                     ??create_name_10:
   \   0000007C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000007E   0x2F80             CMP      R7,#+128
   \   00000080   0xD2D3             BCS.N    ??create_name_3
   \   00000082   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000084   0x0039             MOVS     R1,R7
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000008A   0x.... 0x....      BL       chk_chr
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD0CB             BEQ.N    ??create_name_3
   \   00000092   0x2006             MOVS     R0,#+6
   \   00000094   0xE0A8             B.N      ??create_name_9
   \                     ??create_name_6:
   \   00000096   0xF05F 0x0800      MOVS     R8,#+0
   1669          #if _FS_RPATH
   1670          	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
   1671          		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
   \                     ??create_name_7:
   \   0000009A   0x2D01             CMP      R5,#+1
   \   0000009C   0xD105             BNE.N    ??create_name_11
   \   0000009E   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   000000A2   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   000000A6   0x282E             CMP      R0,#+46
   \   000000A8   0xD00D             BEQ.N    ??create_name_12
   \                     ??create_name_11:
   \   000000AA   0x2D02             CMP      R5,#+2
   \   000000AC   0xD128             BNE.N    ??create_name_13
   \   000000AE   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   000000B2   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   000000B6   0x282E             CMP      R0,#+46
   \   000000B8   0xD122             BNE.N    ??create_name_13
   \   000000BA   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   000000BE   0xF830 0x0C04      LDRH     R0,[R0, #-4]
   \   000000C2   0x282E             CMP      R0,#+46
   \   000000C4   0xD11C             BNE.N    ??create_name_13
   1672          		lfn[di] = 0;
   \                     ??create_name_12:
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF826 0x0015      STRH     R0,[R6, R5, LSL #+1]
   1673          		for (i = 0; i < 11; i++)
   \   000000CC   0xF05F 0x0900      MOVS     R9,#+0
   \   000000D0   0xE006             B.N      ??create_name_14
   1674          			dj->fn[i] = (i < di) ? '.' : ' ';
   \                     ??create_name_15:
   \   000000D2   0x2020             MOVS     R0,#+32
   \                     ??create_name_16:
   \   000000D4   0x9900             LDR      R1,[SP, #+0]
   \   000000D6   0x6989             LDR      R1,[R1, #+24]
   \   000000D8   0xF809 0x0001      STRB     R0,[R9, R1]
   \   000000DC   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??create_name_14:
   \   000000E0   0xF1B9 0x0F0B      CMP      R9,#+11
   \   000000E4   0xD203             BCS.N    ??create_name_17
   \   000000E6   0x45A9             CMP      R9,R5
   \   000000E8   0xD2F3             BCS.N    ??create_name_15
   \   000000EA   0x202E             MOVS     R0,#+46
   \   000000EC   0xE7F2             B.N      ??create_name_16
   1675          		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   \                     ??create_name_17:
   \   000000EE   0x9800             LDR      R0,[SP, #+0]
   \   000000F0   0x6980             LDR      R0,[R0, #+24]
   \   000000F2   0xF058 0x0120      ORRS     R1,R8,#0x20
   \   000000F6   0xF809 0x1000      STRB     R1,[R9, R0]
   1676          		return FR_OK;
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xE074             B.N      ??create_name_9
   1677          	}
   1678          #endif
   1679          	while (di) {						/* Strip trailing spaces and dots */
   1680          		w = lfn[di-1];
   1681          		if (w != ' ' && w != '.') break;
   1682          		di--;
   \                     ??create_name_18:
   \   000000FE   0x1E6D             SUBS     R5,R5,#+1
   \                     ??create_name_13:
   \   00000100   0x2D00             CMP      R5,#+0
   \   00000102   0xD009             BEQ.N    ??create_name_19
   \   00000104   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   00000108   0xF830 0x7C02      LDRH     R7,[R0, #-2]
   \   0000010C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000010E   0x2F20             CMP      R7,#+32
   \   00000110   0xD0F5             BEQ.N    ??create_name_18
   \   00000112   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000114   0x2F2E             CMP      R7,#+46
   \   00000116   0xD0F2             BEQ.N    ??create_name_18
   1683          	}
   1684          	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
   \                     ??create_name_19:
   \   00000118   0x2D00             CMP      R5,#+0
   \   0000011A   0xD101             BNE.N    ??create_name_20
   \   0000011C   0x2006             MOVS     R0,#+6
   \   0000011E   0xE063             B.N      ??create_name_9
   1685          
   1686          	lfn[di] = 0;						/* LFN is created */
   \                     ??create_name_20:
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0xF826 0x0015      STRH     R0,[R6, R5, LSL #+1]
   1687          
   1688          	/* Create SFN in directory form */
   1689          	mem_set(dj->fn, ' ', 11);
   \   00000126   0x220B             MOVS     R2,#+11
   \   00000128   0x2120             MOVS     R1,#+32
   \   0000012A   0x9800             LDR      R0,[SP, #+0]
   \   0000012C   0x6980             LDR      R0,[R0, #+24]
   \   0000012E   0x.... 0x....      BL       mem_set
   1690          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   \   00000132   0x2400             MOVS     R4,#+0
   \   00000134   0xE000             B.N      ??create_name_21
   \                     ??create_name_22:
   \   00000136   0x1C64             ADDS     R4,R4,#+1
   \                     ??create_name_21:
   \   00000138   0xF836 0x0014      LDRH     R0,[R6, R4, LSL #+1]
   \   0000013C   0x2820             CMP      R0,#+32
   \   0000013E   0xD0FA             BEQ.N    ??create_name_22
   \   00000140   0xF836 0x0014      LDRH     R0,[R6, R4, LSL #+1]
   \   00000144   0x282E             CMP      R0,#+46
   \   00000146   0xD0F6             BEQ.N    ??create_name_22
   1691          	if (si) cf |= NS_LOSS | NS_LFN;
   \   00000148   0x2C00             CMP      R4,#+0
   \   0000014A   0xD003             BEQ.N    ??create_name_23
   \   0000014C   0xF058 0x0803      ORRS     R8,R8,#0x3
   \   00000150   0xE000             B.N      ??create_name_23
   1692          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   \                     ??create_name_24:
   \   00000152   0x1E6D             SUBS     R5,R5,#+1
   \                     ??create_name_23:
   \   00000154   0x2D00             CMP      R5,#+0
   \   00000156   0xD005             BEQ.N    ??create_name_25
   \   00000158   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   0000015C   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   00000160   0x282E             CMP      R0,#+46
   \   00000162   0xD1F6             BNE.N    ??create_name_24
   1693          
   1694          	b = i = 0; ni = 8;
   \                     ??create_name_25:
   \   00000164   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000168   0x46D1             MOV      R9,R10
   \   0000016A   0xF05F 0x0B08      MOVS     R11,#+8
   \   0000016E   0xE001             B.N      ??create_name_26
   1695          	for (;;) {
   1696          		w = lfn[si++];					/* Get an LFN char */
   1697          		if (!w) break;					/* Break on end of the LFN */
   1698          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   1699          			cf |= NS_LOSS | NS_LFN; continue;
   \                     ??create_name_27:
   \   00000170   0xF058 0x0803      ORRS     R8,R8,#0x3
   1700          		}
   \                     ??create_name_26:
   \   00000174   0xF836 0x7014      LDRH     R7,[R6, R4, LSL #+1]
   \   00000178   0x1C64             ADDS     R4,R4,#+1
   \   0000017A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000017C   0x2F00             CMP      R7,#+0
   \   0000017E   0xD135             BNE.N    ??create_name_28
   1701          
   1702          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   1703          			if (ni == 11) {				/* Long extension */
   1704          				cf |= NS_LOSS | NS_LFN; break;
   1705          			}
   1706          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   1707          			if (si > di) break;			/* No extension */
   1708          			si = di; i = 8; ni = 11;	/* Enter extension section */
   1709          			b <<= 2; continue;
   1710          		}
   1711          
   1712          		if (w >= 0x80) {				/* Non ASCII char */
   1713          #ifdef _EXCVT
   1714          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   1715          			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
   1716          #else
   1717          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   1718          #endif
   1719          			cf |= NS_LFN;				/* Force create LFN entry */
   1720          		}
   1721          
   1722          		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
   1723          			if (i >= ni - 1) {
   1724          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   1725          			}
   1726          			dj->fn[i++] = (BYTE)(w >> 8);
   1727          		} else {						/* Single byte char */
   1728          			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
   1729          				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   1730          			} else {
   1731          				if (IsUpper(w)) {		/* ASCII large capital */
   1732          					b |= 2;
   1733          				} else {
   1734          					if (IsLower(w)) {	/* ASCII small capital */
   1735          						b |= 1; w -= 0x20;
   1736          					}
   1737          				}
   1738          			}
   1739          		}
   1740          		dj->fn[i++] = (BYTE)w;
   1741          	}
   1742          
   1743          	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
   \                     ??create_name_29:
   \   00000180   0x9800             LDR      R0,[SP, #+0]
   \   00000182   0x6980             LDR      R0,[R0, #+24]
   \   00000184   0x7800             LDRB     R0,[R0, #+0]
   \   00000186   0x28E5             CMP      R0,#+229
   \   00000188   0xD103             BNE.N    ??create_name_30
   \   0000018A   0x9800             LDR      R0,[SP, #+0]
   \   0000018C   0x6980             LDR      R0,[R0, #+24]
   \   0000018E   0x2105             MOVS     R1,#+5
   \   00000190   0x7001             STRB     R1,[R0, #+0]
   1744          
   1745          	if (ni == 8) b <<= 2;
   \                     ??create_name_30:
   \   00000192   0xF1BB 0x0F08      CMP      R11,#+8
   \   00000196   0xD101             BNE.N    ??create_name_31
   \   00000198   0xEA5F 0x0A8A      LSLS     R10,R10,#+2
   1746          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   \                     ??create_name_31:
   \   0000019C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001A0   0xF01A 0x000C      ANDS     R0,R10,#0xC
   \   000001A4   0x280C             CMP      R0,#+12
   \   000001A6   0xD005             BEQ.N    ??create_name_32
   \   000001A8   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001AC   0xF01A 0x0003      ANDS     R0,R10,#0x3
   \   000001B0   0x2803             CMP      R0,#+3
   \   000001B2   0xD101             BNE.N    ??create_name_33
   1747          		cf |= NS_LFN;
   \                     ??create_name_32:
   \   000001B4   0xF058 0x0802      ORRS     R8,R8,#0x2
   1748          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
   \                     ??create_name_33:
   \   000001B8   0xEA5F 0x7088      LSLS     R0,R8,#+30
   \   000001BC   0xD40F             BMI.N    ??create_name_34
   1749          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   \   000001BE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001C2   0xF01A 0x0003      ANDS     R0,R10,#0x3
   \   000001C6   0x2801             CMP      R0,#+1
   \   000001C8   0xD101             BNE.N    ??create_name_35
   \   000001CA   0xF058 0x0810      ORRS     R8,R8,#0x10
   1750          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   \                     ??create_name_35:
   \   000001CE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001D2   0xF01A 0x000C      ANDS     R0,R10,#0xC
   \   000001D6   0x2804             CMP      R0,#+4
   \   000001D8   0xD101             BNE.N    ??create_name_34
   \   000001DA   0xF058 0x0808      ORRS     R8,R8,#0x8
   1751          	}
   1752          
   1753          	dj->fn[NS] = cf;	/* SFN is created */
   \                     ??create_name_34:
   \   000001DE   0x9800             LDR      R0,[SP, #+0]
   \   000001E0   0x6980             LDR      R0,[R0, #+24]
   \   000001E2   0xF880 0x800B      STRB     R8,[R0, #+11]
   1754          
   1755          	return FR_OK;
   \   000001E6   0x2000             MOVS     R0,#+0
   \                     ??create_name_9:
   \   000001E8   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??create_name_28:
   \   000001EC   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001EE   0x2F20             CMP      R7,#+32
   \   000001F0   0xD0BE             BEQ.N    ??create_name_27
   \   000001F2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001F4   0x2F2E             CMP      R7,#+46
   \   000001F6   0xD101             BNE.N    ??create_name_36
   \   000001F8   0x42AC             CMP      R4,R5
   \   000001FA   0xD1B9             BNE.N    ??create_name_27
   \                     ??create_name_36:
   \   000001FC   0x45D9             CMP      R9,R11
   \   000001FE   0xD201             BCS.N    ??create_name_37
   \   00000200   0x42AC             CMP      R4,R5
   \   00000202   0xD113             BNE.N    ??create_name_38
   \                     ??create_name_37:
   \   00000204   0xF1BB 0x0F0B      CMP      R11,#+11
   \   00000208   0xD102             BNE.N    ??create_name_39
   \   0000020A   0xF058 0x0803      ORRS     R8,R8,#0x3
   \   0000020E   0xE7B7             B.N      ??create_name_29
   \                     ??create_name_39:
   \   00000210   0x42AC             CMP      R4,R5
   \   00000212   0xD001             BEQ.N    ??create_name_40
   \   00000214   0xF058 0x0803      ORRS     R8,R8,#0x3
   \                     ??create_name_40:
   \   00000218   0x42A5             CMP      R5,R4
   \   0000021A   0xD3B1             BCC.N    ??create_name_29
   \                     ??create_name_41:
   \   0000021C   0x002C             MOVS     R4,R5
   \   0000021E   0xF05F 0x0908      MOVS     R9,#+8
   \   00000222   0xF05F 0x0B0B      MOVS     R11,#+11
   \   00000226   0xEA5F 0x0A8A      LSLS     R10,R10,#+2
   \   0000022A   0xE7A3             B.N      ??create_name_26
   \                     ??create_name_38:
   \   0000022C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000022E   0x2F80             CMP      R7,#+128
   \   00000230   0xD310             BCC.N    ??create_name_42
   \   00000232   0x2100             MOVS     R1,#+0
   \   00000234   0x0038             MOVS     R0,R7
   \   00000236   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000238   0x.... 0x....      BL       ff_convert
   \   0000023C   0x0007             MOVS     R7,R0
   \   0000023E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000240   0x2F00             CMP      R7,#+0
   \   00000242   0xD005             BEQ.N    ??create_name_43
   \   00000244   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000246   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   0000024A   0x1838             ADDS     R0,R7,R0
   \   0000024C   0xF810 0x7C80      LDRB     R7,[R0, #-128]
   \                     ??create_name_43:
   \   00000250   0xF058 0x0802      ORRS     R8,R8,#0x2
   \                     ??create_name_42:
   \   00000254   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000256   0x2F00             CMP      R7,#+0
   \   00000258   0xD007             BEQ.N    ??create_name_44
   \   0000025A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000025C   0x0039             MOVS     R1,R7
   \   0000025E   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000262   0x.... 0x....      BL       chk_chr
   \   00000266   0x2800             CMP      R0,#+0
   \   00000268   0xD003             BEQ.N    ??create_name_45
   \                     ??create_name_44:
   \   0000026A   0x275F             MOVS     R7,#+95
   \   0000026C   0xF058 0x0803      ORRS     R8,R8,#0x3
   \   00000270   0xE00F             B.N      ??create_name_46
   \                     ??create_name_45:
   \   00000272   0xF1B7 0x0041      SUBS     R0,R7,#+65
   \   00000276   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000278   0x281A             CMP      R0,#+26
   \   0000027A   0xD202             BCS.N    ??create_name_47
   \   0000027C   0xF05A 0x0A02      ORRS     R10,R10,#0x2
   \   00000280   0xE007             B.N      ??create_name_46
   \                     ??create_name_47:
   \   00000282   0xF1B7 0x0061      SUBS     R0,R7,#+97
   \   00000286   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000288   0x281A             CMP      R0,#+26
   \   0000028A   0xD202             BCS.N    ??create_name_46
   \   0000028C   0xF05A 0x0A01      ORRS     R10,R10,#0x1
   \   00000290   0x3F20             SUBS     R7,R7,#+32
   \                     ??create_name_46:
   \   00000292   0x9800             LDR      R0,[SP, #+0]
   \   00000294   0x6980             LDR      R0,[R0, #+24]
   \   00000296   0xF809 0x7000      STRB     R7,[R9, R0]
   \   0000029A   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000029E   0xE769             B.N      ??create_name_26
   1756          
   1757          
   1758          #else	/* Non-LFN configuration */
   1759          	BYTE b, c, d, *sfn;
   1760          	UINT ni, si, i;
   1761          	const char *p;
   1762          
   1763          	/* Create file name in directory form */
   1764          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   1765          	sfn = dj->fn;
   1766          	mem_set(sfn, ' ', 11);
   1767          	si = i = b = 0; ni = 8;
   1768          #if _FS_RPATH
   1769          	if (p[si] == '.') { /* Is this a dot entry? */
   1770          		for (;;) {
   1771          			c = (BYTE)p[si++];
   1772          			if (c != '.' || si >= 3) break;
   1773          			sfn[i++] = c;
   1774          		}
   1775          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   1776          		*path = &p[si];									/* Return pointer to the next segment */
   1777          		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   1778          		return FR_OK;
   1779          	}
   1780          #endif
   1781          	for (;;) {
   1782          		c = (BYTE)p[si++];
   1783          		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
   1784          		if (c == '.' || i >= ni) {
   1785          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   1786          			i = 8; ni = 11;
   1787          			b <<= 2; continue;
   1788          		}
   1789          		if (c >= 0x80) {				/* Extended char? */
   1790          			b |= 3;						/* Eliminate NT flag */
   1791          #ifdef _EXCVT
   1792          			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
   1793          #else
   1794          #if !_DF1S	/* ASCII only cfg */
   1795          			return FR_INVALID_NAME;
   1796          #endif
   1797          #endif
   1798          		}
   1799          		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1800          			d = (BYTE)p[si++];			/* Get 2nd byte */
   1801          			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
   1802          				return FR_INVALID_NAME;
   1803          			sfn[i++] = c;
   1804          			sfn[i++] = d;
   1805          		} else {						/* Single byte code */
   1806          			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
   1807          				return FR_INVALID_NAME;
   1808          			if (IsUpper(c)) {			/* ASCII large capital? */
   1809          				b |= 2;
   1810          			} else {
   1811          				if (IsLower(c)) {		/* ASCII small capital? */
   1812          					b |= 1; c -= 0x20;
   1813          				}
   1814          			}
   1815          			sfn[i++] = c;
   1816          		}
   1817          	}
   1818          	*path = &p[si];						/* Return pointer to the next segment */
   1819          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   1820          
   1821          	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
   1822          	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
   1823          
   1824          	if (ni == 8) b <<= 2;
   1825          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
   1826          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
   1827          
   1828          	sfn[NS] = c;		/* Store NT flag, File name is created */
   1829          
   1830          	return FR_OK;
   1831          #endif
   1832          }

   \                                 In section .rodata, align 4
   \                     ??excvt:
   \   00000000   0x80 0x81          DC8 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140
   \              0x82 0x83    
   \              0x84 0x85    
   \              0x86 0x87    
   \              0x88 0x89    
   \              0x8A 0x8B    
   \              0x8C         
   \   0000000D   0x8D 0x8E          DC8 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153
   \              0x8F 0x90    
   \              0x91 0x92    
   \              0x93 0x94    
   \              0x95 0x96    
   \              0x97 0x98    
   \              0x99         
   \   0000001A   0x8A 0x9B          DC8 138, 155, 140, 141, 142, 143, 160, 161, 162, 163, 164, 165, 166
   \              0x8C 0x8D    
   \              0x8E 0x8F    
   \              0xA0 0xA1    
   \              0xA2 0xA3    
   \              0xA4 0xA5    
   \              0xA6         
   \   00000027   0xA7 0xA8          DC8 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 163
   \              0xA9 0xAA    
   \              0xAB 0xAC    
   \              0xAD 0xAE    
   \              0xAF 0xB0    
   \              0xB1 0xB2    
   \              0xA3         
   \   00000034   0xB4 0xB5          DC8 180, 181, 182, 183, 184, 165, 170, 187, 188, 189, 188, 175, 192
   \              0xB6 0xB7    
   \              0xB8 0xA5    
   \              0xAA 0xBB    
   \              0xBC 0xBD    
   \              0xBC 0xAF    
   \              0xC0         
   \   00000041   0xC1 0xC2          DC8 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205
   \              0xC3 0xC4    
   \              0xC5 0xC6    
   \              0xC7 0xC8    
   \              0xC9 0xCA    
   \              0xCB 0xCC    
   \              0xCD         
   \   0000004E   0xCE 0xCF          DC8 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218
   \              0xD0 0xD1    
   \              0xD2 0xD3    
   \              0xD4 0xD5    
   \              0xD6 0xD7    
   \              0xD8 0xD9    
   \              0xDA         
   \   0000005B   0xDB 0xDC          DC8 219, 220, 221, 222, 223, 192, 193, 194, 195, 196, 197, 198, 199
   \              0xDD 0xDE    
   \              0xDF 0xC0    
   \              0xC1 0xC2    
   \              0xC3 0xC4    
   \              0xC5 0xC6    
   \              0xC7         
   \   00000068   0xC8 0xC9          DC8 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212
   \              0xCA 0xCB    
   \              0xCC 0xCD    
   \              0xCE 0xCF    
   \              0xD0 0xD1    
   \              0xD2 0xD3    
   \              0xD4         
   \   00000075   0xD5 0xD6          DC8 213, 214, 247, 216, 217, 218, 219, 220, 221, 222, 255
   \              0xF7 0xD8    
   \              0xD9 0xDA    
   \              0xDB 0xDC    
   \              0xDD 0xDE    
   \              0xFF         
   1833          
   1834          
   1835          
   1836          
   1837          /*-----------------------------------------------------------------------*/
   1838          /* Get file information from directory entry                             */
   1839          /*-----------------------------------------------------------------------*/
   1840          #if _FS_MINIMIZE <= 1

   \                                 In section .text, align 2, keep-with-next
   1841          static
   1842          void get_fileinfo (		/* No return code */
   1843          	DIR *dj,			/* Pointer to the directory object */
   1844          	FILINFO *fno	 	/* Pointer to the file information to be filled */
   1845          )
   1846          {
   \                     get_fileinfo:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1847          	UINT i;
   1848          	BYTE nt, *dir;
   1849          	TCHAR *p, c;
   1850          
   1851          
   1852          	p = fno->fname;
   \   00000004   0xF204 0x0109      ADDW     R1,R4,#+9
   1853          	if (dj->sect) {
   \   00000008   0x6902             LDR      R2,[R0, #+16]
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD048             BEQ.N    ??get_fileinfo_0
   1854          		dir = dj->dir;
   \   0000000E   0x6942             LDR      R2,[R0, #+20]
   1855          		nt = dir[DIR_NTres];		/* NT flag */
   \   00000010   0x7B13             LDRB     R3,[R2, #+12]
   1856          		for (i = 0; i < 8; i++) {	/* Copy name body */
   \   00000012   0x2500             MOVS     R5,#+0
   \   00000014   0xE00E             B.N      ??get_fileinfo_1
   1857          			c = dir[i];
   1858          			if (c == ' ') break;
   1859          			if (c == NDDE) c = (TCHAR)DDE;
   \                     ??get_fileinfo_2:
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E05             CMP      R6,#+5
   \   0000001A   0xD100             BNE.N    ??get_fileinfo_3
   \   0000001C   0x26E5             MOVS     R6,#+229
   1860          			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
   \                     ??get_fileinfo_3:
   \   0000001E   0x071F             LSLS     R7,R3,#+28
   \   00000020   0xD505             BPL.N    ??get_fileinfo_4
   \   00000022   0xF1B6 0x0741      SUBS     R7,R6,#+65
   \   00000026   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000028   0x2F1A             CMP      R7,#+26
   \   0000002A   0xD200             BCS.N    ??get_fileinfo_4
   \   0000002C   0x3620             ADDS     R6,R6,#+32
   1861          #if _LFN_UNICODE
   1862          			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
   1863          				c = (c << 8) | dir[++i];
   1864          			c = ff_convert(c, 1);
   1865          			if (!c) c = '?';
   1866          #endif
   1867          			*p++ = c;
   \                     ??get_fileinfo_4:
   \   0000002E   0x700E             STRB     R6,[R1, #+0]
   \   00000030   0x1C49             ADDS     R1,R1,#+1
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \                     ??get_fileinfo_1:
   \   00000034   0x2D08             CMP      R5,#+8
   \   00000036   0xD203             BCS.N    ??get_fileinfo_5
   \   00000038   0x5CAE             LDRB     R6,[R5, R2]
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x2E20             CMP      R6,#+32
   \   0000003E   0xD1EA             BNE.N    ??get_fileinfo_2
   1868          		}
   1869          		if (dir[8] != ' ') {		/* Copy name extension */
   \                     ??get_fileinfo_5:
   \   00000040   0x7A15             LDRB     R5,[R2, #+8]
   \   00000042   0x2D20             CMP      R5,#+32
   \   00000044   0xD015             BEQ.N    ??get_fileinfo_6
   1870          			*p++ = '.';
   \   00000046   0x252E             MOVS     R5,#+46
   \   00000048   0x700D             STRB     R5,[R1, #+0]
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
   1871          			for (i = 8; i < 11; i++) {
   \   0000004C   0x2508             MOVS     R5,#+8
   \   0000004E   0xE00A             B.N      ??get_fileinfo_7
   1872          				c = dir[i];
   1873          				if (c == ' ') break;
   1874          				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
   \                     ??get_fileinfo_8:
   \   00000050   0x06DF             LSLS     R7,R3,#+27
   \   00000052   0xD505             BPL.N    ??get_fileinfo_9
   \   00000054   0xF1B6 0x0741      SUBS     R7,R6,#+65
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0x2F1A             CMP      R7,#+26
   \   0000005C   0xD200             BCS.N    ??get_fileinfo_9
   \   0000005E   0x3620             ADDS     R6,R6,#+32
   1875          #if _LFN_UNICODE
   1876          				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
   1877          					c = (c << 8) | dir[++i];
   1878          				c = ff_convert(c, 1);
   1879          				if (!c) c = '?';
   1880          #endif
   1881          				*p++ = c;
   \                     ??get_fileinfo_9:
   \   00000060   0x700E             STRB     R6,[R1, #+0]
   \   00000062   0x1C49             ADDS     R1,R1,#+1
   \   00000064   0x1C6D             ADDS     R5,R5,#+1
   \                     ??get_fileinfo_7:
   \   00000066   0x2D0B             CMP      R5,#+11
   \   00000068   0xD203             BCS.N    ??get_fileinfo_6
   \   0000006A   0x5CAE             LDRB     R6,[R5, R2]
   \   0000006C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006E   0x2E20             CMP      R6,#+32
   \   00000070   0xD1EE             BNE.N    ??get_fileinfo_8
   1882          			}
   1883          		}
   1884          		fno->fattrib = dir[DIR_Attr];				/* Attribute */
   \                     ??get_fileinfo_6:
   \   00000072   0x7AD3             LDRB     R3,[R2, #+11]
   \   00000074   0x7223             STRB     R3,[R4, #+8]
   1885          		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
   \   00000076   0x7FD3             LDRB     R3,[R2, #+31]
   \   00000078   0x7F95             LDRB     R5,[R2, #+30]
   \   0000007A   0x042D             LSLS     R5,R5,#+16
   \   0000007C   0xEA55 0x6303      ORRS     R3,R5,R3, LSL #+24
   \   00000080   0x7F55             LDRB     R5,[R2, #+29]
   \   00000082   0xEA53 0x2305      ORRS     R3,R3,R5, LSL #+8
   \   00000086   0x7F15             LDRB     R5,[R2, #+28]
   \   00000088   0x432B             ORRS     R3,R5,R3
   \   0000008A   0x6023             STR      R3,[R4, #+0]
   1886          		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
   \   0000008C   0x7E53             LDRB     R3,[R2, #+25]
   \   0000008E   0x7E15             LDRB     R5,[R2, #+24]
   \   00000090   0xEA55 0x2303      ORRS     R3,R5,R3, LSL #+8
   \   00000094   0x80A3             STRH     R3,[R4, #+4]
   1887          		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
   \   00000096   0x7DD3             LDRB     R3,[R2, #+23]
   \   00000098   0x7D92             LDRB     R2,[R2, #+22]
   \   0000009A   0xEA52 0x2203      ORRS     R2,R2,R3, LSL #+8
   \   0000009E   0x80E2             STRH     R2,[R4, #+6]
   1888          	}
   1889          	*p = 0;		/* Terminate SFN str by a \0 */
   \                     ??get_fileinfo_0:
   \   000000A0   0x2200             MOVS     R2,#+0
   \   000000A2   0x700A             STRB     R2,[R1, #+0]
   1890          
   1891          #if _USE_LFN
   1892          	if (fno->lfname && fno->lfsize) {
   \   000000A4   0x69A1             LDR      R1,[R4, #+24]
   \   000000A6   0x2900             CMP      R1,#+0
   \   000000A8   0xD026             BEQ.N    ??get_fileinfo_10
   \   000000AA   0x69E1             LDR      R1,[R4, #+28]
   \   000000AC   0x2900             CMP      R1,#+0
   \   000000AE   0xD023             BEQ.N    ??get_fileinfo_10
   1893          		TCHAR *tp = fno->lfname;
   \   000000B0   0x69A6             LDR      R6,[R4, #+24]
   1894          		WCHAR w, *lfn;
   1895          
   1896          		i = 0;
   \   000000B2   0x2500             MOVS     R5,#+0
   1897          		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
   \   000000B4   0x6901             LDR      R1,[R0, #+16]
   \   000000B6   0x2900             CMP      R1,#+0
   \   000000B8   0xD01C             BEQ.N    ??get_fileinfo_11
   \   000000BA   0x8C01             LDRH     R1,[R0, #+32]
   \   000000BC   0xF64F 0x72FF      MOVW     R2,#+65535
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0xD017             BEQ.N    ??get_fileinfo_11
   1898          			lfn = dj->lfn;
   \   000000C4   0x69C7             LDR      R7,[R0, #+28]
   \   000000C6   0xE001             B.N      ??get_fileinfo_12
   1899          			while ((w = *lfn++) != 0) {			/* Get an LFN char */
   1900          #if !_LFN_UNICODE
   1901          				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
   1902          				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
   1903          				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
   1904          					tp[i++] = (TCHAR)(w >> 8);
   1905          #endif
   1906          				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
   1907          				tp[i++] = (TCHAR)w;
   \                     ??get_fileinfo_13:
   \   000000C8   0x55A8             STRB     R0,[R5, R6]
   \   000000CA   0x1C6D             ADDS     R5,R5,#+1
   \                     ??get_fileinfo_12:
   \   000000CC   0x8838             LDRH     R0,[R7, #+0]
   \   000000CE   0x1CBF             ADDS     R7,R7,#+2
   \   000000D0   0x0001             MOVS     R1,R0
   \   000000D2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D4   0x2900             CMP      R1,#+0
   \   000000D6   0xD00D             BEQ.N    ??get_fileinfo_11
   \   000000D8   0x2100             MOVS     R1,#+0
   \   000000DA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DC   0x.... 0x....      BL       ff_convert
   \   000000E0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD101             BNE.N    ??get_fileinfo_14
   \   000000E6   0x2500             MOVS     R5,#+0
   \   000000E8   0xE004             B.N      ??get_fileinfo_11
   \                     ??get_fileinfo_14:
   \   000000EA   0x69E1             LDR      R1,[R4, #+28]
   \   000000EC   0x1E49             SUBS     R1,R1,#+1
   \   000000EE   0x428D             CMP      R5,R1
   \   000000F0   0xD3EA             BCC.N    ??get_fileinfo_13
   \   000000F2   0x2500             MOVS     R5,#+0
   1908          			}
   1909          		}
   1910          		tp[i] = 0;	/* Terminate the LFN str by a \0 */
   \                     ??get_fileinfo_11:
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x55A8             STRB     R0,[R5, R6]
   1911          	}
   1912          #endif
   1913          }
   \                     ??get_fileinfo_10:
   \   000000F8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1914          #endif /* _FS_MINIMIZE <= 1 */
   1915          
   1916          
   1917          
   1918          
   1919          /*-----------------------------------------------------------------------*/
   1920          /* Follow a file path                                                    */
   1921          /*-----------------------------------------------------------------------*/
   1922          

   \                                 In section .text, align 2, keep-with-next
   1923          static
   1924          FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   1925          	DIR *dj,			/* Directory object to return last directory and found object */
   1926          	const TCHAR *path	/* Full-path string to find a file or directory */
   1927          )
   1928          {
   \                     follow_path:
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1929          	FRESULT res;
   1930          	BYTE *dir, ns;
   1931          
   1932          
   1933          #if _FS_RPATH
   1934          	if (*path == '/' || *path == '\\') { /* There is a heading separator */
   \   00000004   0x9801             LDR      R0,[SP, #+4]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x282F             CMP      R0,#+47
   \   0000000A   0xD003             BEQ.N    ??follow_path_0
   \   0000000C   0x9801             LDR      R0,[SP, #+4]
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x285C             CMP      R0,#+92
   \   00000012   0xD105             BNE.N    ??follow_path_1
   1935          		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
   \                     ??follow_path_0:
   \   00000014   0x9801             LDR      R0,[SP, #+4]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x9001             STR      R0,[SP, #+4]
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x60A0             STR      R0,[R4, #+8]
   \   0000001E   0xE002             B.N      ??follow_path_2
   1936          	} else {							/* No heading separator */
   1937          		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
   \                     ??follow_path_1:
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6980             LDR      R0,[R0, #+24]
   \   00000024   0x60A0             STR      R0,[R4, #+8]
   1938          	}
   1939          #else
   1940          	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
   1941          		path++;
   1942          	dj->sclust = 0;						/* Start from the root dir */
   1943          #endif
   1944          
   1945          	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
   \                     ??follow_path_2:
   \   00000026   0x9801             LDR      R0,[SP, #+4]
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2820             CMP      R0,#+32
   \   0000002C   0xD20E             BCS.N    ??follow_path_3
   1946          		res = dir_sdi(dj, 0);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       dir_sdi
   1947          		dj->dir = 0;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6161             STR      R1,[R4, #+20]
   1948          
   1949          	} else {							/* Follow path */
   1950          		for (;;) {
   1951          			res = create_name(dj, &path);	/* Get a segment */
   1952          			if (res != FR_OK) break;
   1953          			res = dir_find(dj);				/* Find it */
   1954          			ns = *(dj->fn+NS);
   1955          			if (res != FR_OK) {				/* Failed to find the object */
   1956          				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
   1957          				/* Object not found */
   1958          				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
   1959          					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
   1960          					res = FR_OK;
   1961          					if (!(ns & NS_LAST)) continue;
   1962          				} else {							/* Could not find the object */
   1963          					if (!(ns & NS_LAST)) res = FR_NO_PATH;
   1964          				}
   1965          				break;
   1966          			}
   1967          			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
   1968          			dir = dj->dir;						/* There is next segment. Follow the sub directory */
   1969          			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
   1970          				res = FR_NO_PATH; break;
   1971          			}
   1972          			dj->sclust = LD_CLUST(dir);
   1973          		}
   1974          	}
   1975          
   1976          	return res;
   \                     ??follow_path_4:
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   \                     ??follow_path_5:
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x60A0             STR      R0,[R4, #+8]
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6160             STR      R0,[R4, #+20]
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x0749             LSLS     R1,R1,#+29
   \   0000004A   0xD416             BMI.N    ??follow_path_6
   \                     ??follow_path_3:
   \   0000004C   0xA901             ADD      R1,SP,#+4
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       create_name
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD1EF             BNE.N    ??follow_path_4
   \                     ??follow_path_7:
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       dir_find
   \   00000060   0x69A1             LDR      R1,[R4, #+24]
   \   00000062   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD008             BEQ.N    ??follow_path_8
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0x2804             CMP      R0,#+4
   \   0000006E   0xD1E4             BNE.N    ??follow_path_4
   \                     ??follow_path_9:
   \   00000070   0x068A             LSLS     R2,R1,#+26
   \   00000072   0xD4E4             BMI.N    ??follow_path_5
   \   00000074   0x0749             LSLS     R1,R1,#+29
   \   00000076   0xD400             BMI.N    ??follow_path_6
   \   00000078   0x2005             MOVS     R0,#+5
   \                     ??follow_path_6:
   \   0000007A   0xE7DE             B.N      ??follow_path_4
   \                     ??follow_path_8:
   \   0000007C   0x0749             LSLS     R1,R1,#+29
   \   0000007E   0xD4DC             BMI.N    ??follow_path_4
   \                     ??follow_path_10:
   \   00000080   0x6960             LDR      R0,[R4, #+20]
   \   00000082   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000084   0x06C9             LSLS     R1,R1,#+27
   \   00000086   0xD401             BMI.N    ??follow_path_11
   \   00000088   0x2005             MOVS     R0,#+5
   \   0000008A   0xE7D6             B.N      ??follow_path_4
   \                     ??follow_path_11:
   \   0000008C   0x7D41             LDRB     R1,[R0, #+21]
   \   0000008E   0x7D02             LDRB     R2,[R0, #+20]
   \   00000090   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000094   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000096   0x7EC2             LDRB     R2,[R0, #+27]
   \   00000098   0x7E80             LDRB     R0,[R0, #+26]
   \   0000009A   0xEA50 0x2002      ORRS     R0,R0,R2, LSL #+8
   \   0000009E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A0   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   000000A4   0x60A0             STR      R0,[R4, #+8]
   \   000000A6   0xE7D1             B.N      ??follow_path_3
   1977          }
   1978          
   1979          
   1980          
   1981          
   1982          /*-----------------------------------------------------------------------*/
   1983          /* Load a sector and check if it is an FAT Volume Boot Record            */
   1984          /*-----------------------------------------------------------------------*/
   1985          

   \                                 In section .text, align 2, keep-with-next
   1986          static
   1987          BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
   1988          	FATFS *fs,	/* File system object */
   1989          	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
   1990          )
   1991          {
   \                     check_fs:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1992          	if (LPLD_Disk_Read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x000A             MOVS     R2,R1
   \   00000008   0xF114 0x0134      ADDS     R1,R4,#+52
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x.... 0x....      BL       LPLD_Disk_Read
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??check_fs_0
   1993          		return 3;
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0xE02D             B.N      ??check_fs_1
   1994          	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
   \                     ??check_fs_0:
   \   0000001A   0xF894 0x0233      LDRB     R0,[R4, #+563]
   \   0000001E   0xF894 0x1232      LDRB     R1,[R4, #+562]
   \   00000022   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000026   0xF64A 0x2155      MOVW     R1,#+43605
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD001             BEQ.N    ??check_fs_2
   1995          		return 2;
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xE020             B.N      ??check_fs_1
   1996          
   1997          	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   \                     ??check_fs_2:
   \   00000034   0xF894 0x006C      LDRB     R0,[R4, #+108]
   \   00000038   0xF894 0x106B      LDRB     R1,[R4, #+107]
   \   0000003C   0x0209             LSLS     R1,R1,#+8
   \   0000003E   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000042   0xF894 0x106A      LDRB     R1,[R4, #+106]
   \   00000046   0x4308             ORRS     R0,R1,R0
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x544146
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD101             BNE.N    ??check_fs_3
   1998          		return 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE010             B.N      ??check_fs_1
   1999          	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
   \                     ??check_fs_3:
   \   00000054   0xF894 0x0088      LDRB     R0,[R4, #+136]
   \   00000058   0xF894 0x1087      LDRB     R1,[R4, #+135]
   \   0000005C   0x0209             LSLS     R1,R1,#+8
   \   0000005E   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000062   0xF894 0x1086      LDRB     R1,[R4, #+134]
   \   00000066   0x4308             ORRS     R0,R1,R0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x544146
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD101             BNE.N    ??check_fs_4
   2000          		return 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xE000             B.N      ??check_fs_1
   2001          
   2002          	return 1;
   \                     ??check_fs_4:
   \   00000074   0x2001             MOVS     R0,#+1
   \                     ??check_fs_1:
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
   2003          }
   2004          
   2005          
   2006          
   2007          
   2008          /*-----------------------------------------------------------------------*/
   2009          /* Check if the file system object is valid or not                       */
   2010          /*-----------------------------------------------------------------------*/
   2011          

   \                                 In section .text, align 2, keep-with-next
   2012          static
   2013          FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
   2014          	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
   2015          	FATFS **rfs,		/* Pointer to pointer to the found file system object */
   2016          	BYTE chk_wp			/* !=0: Check media write protection for write access */
   2017          )
   2018          {
   \                     chk_mounted:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0015             MOVS     R5,R2
   2019          	BYTE fmt, b, pi, *tbl;
   2020          	UINT vol;
   2021          	DSTATUS stat;
   2022          	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
   2023          	WORD nrsv;
   2024          	const TCHAR *p = *path;
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   2025          	FATFS *fs;
   2026          
   2027          	/* Get logical drive number from the path name */
   2028          	vol = p[0] - '0';					/* Is there a drive number? */
   \   00000006   0x7813             LDRB     R3,[R2, #+0]
   \   00000008   0xF1B3 0x0630      SUBS     R6,R3,#+48
   2029          	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
   \   0000000C   0x2E0A             CMP      R6,#+10
   \   0000000E   0xD205             BCS.N    ??chk_mounted_0
   \   00000010   0x7853             LDRB     R3,[R2, #+1]
   \   00000012   0x2B3A             CMP      R3,#+58
   \   00000014   0xD102             BNE.N    ??chk_mounted_0
   2030          		p += 2; *path = p;				/* Return pointer to the path name */
   \   00000016   0x1C92             ADDS     R2,R2,#+2
   \   00000018   0x6002             STR      R2,[R0, #+0]
   \   0000001A   0xE002             B.N      ??chk_mounted_1
   2031          	} else {							/* No drive number is given */
   2032          #if _FS_RPATH
   2033          		vol = CurrVol;					/* Use current drive */
   \                     ??chk_mounted_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000020   0x7806             LDRB     R6,[R0, #+0]
   2034          #else
   2035          		vol = 0;						/* Use drive 0 */
   2036          #endif
   2037          	}
   2038          
   2039          	/* Check if the file system object is valid or not */
   2040          	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
   \                     ??chk_mounted_1:
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD001             BEQ.N    ??chk_mounted_2
   2041          		return FR_INVALID_DRIVE;
   \   00000026   0x200B             MOVS     R0,#+11
   \   00000028   0xE1A1             B.N      ??chk_mounted_3
   2042          	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
   \                     ??chk_mounted_2:
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   0000002E   0xF850 0x4026      LDR      R4,[R0, R6, LSL #+2]
   \   00000032   0x600C             STR      R4,[R1, #+0]
   2043          	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD101             BNE.N    ??chk_mounted_4
   \   00000038   0x200C             MOVS     R0,#+12
   \   0000003A   0xE198             B.N      ??chk_mounted_3
   2044          
   2045          	ENTER_FF(fs);						/* Lock file system */
   2046          
   2047          	if (fs->fs_type) {					/* If the logical drive has been mounted */
   \                     ??chk_mounted_4:
   \   0000003C   0x7820             LDRB     R0,[R4, #+0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD00D             BEQ.N    ??chk_mounted_5
   2048          		stat = LPLD_Disk_Status(fs->drv);
   \   00000042   0x7860             LDRB     R0,[R4, #+1]
   \   00000044   0x.... 0x....      BL       LPLD_Disk_Status
   2049          		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
   \   00000048   0x07C1             LSLS     R1,R0,#+31
   \   0000004A   0xD408             BMI.N    ??chk_mounted_5
   2050          			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD003             BEQ.N    ??chk_mounted_6
   \   00000052   0x0740             LSLS     R0,R0,#+29
   \   00000054   0xD501             BPL.N    ??chk_mounted_6
   2051          				return FR_WRITE_PROTECTED;
   \   00000056   0x200A             MOVS     R0,#+10
   \   00000058   0xE189             B.N      ??chk_mounted_3
   2052          			return FR_OK;				/* The file system object is valid */
   \                     ??chk_mounted_6:
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xE187             B.N      ??chk_mounted_3
   2053          		}
   2054          	}
   2055          
   2056          	/* The file system object is not valid. */
   2057          	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
   2058          
   2059          	fs->fs_type = 0;					/* Clear the file system object */
   \                     ??chk_mounted_5:
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x7020             STRB     R0,[R4, #+0]
   2060          	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   \   00000062   0x7066             STRB     R6,[R4, #+1]
   2061          	stat = LPLD_Disk_Initialize(fs->drv);	/* Initialize low level disk I/O layer */
   \   00000064   0x7860             LDRB     R0,[R4, #+1]
   \   00000066   0x.... 0x....      BL       LPLD_Disk_Initialize
   2062          	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   \   0000006A   0x07C1             LSLS     R1,R0,#+31
   \   0000006C   0xD501             BPL.N    ??chk_mounted_7
   2063          		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
   \   0000006E   0x2003             MOVS     R0,#+3
   \   00000070   0xE17D             B.N      ??chk_mounted_3
   2064          	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   \                     ??chk_mounted_7:
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0x2D00             CMP      R5,#+0
   \   00000076   0xD003             BEQ.N    ??chk_mounted_8
   \   00000078   0x0740             LSLS     R0,R0,#+29
   \   0000007A   0xD501             BPL.N    ??chk_mounted_8
   2065          		return FR_WRITE_PROTECTED;
   \   0000007C   0x200A             MOVS     R0,#+10
   \   0000007E   0xE176             B.N      ??chk_mounted_3
   2066          #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
   2067          	if (LPLD_Disk_IOC(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
   2068          		return FR_DISK_ERR;
   2069          #endif
   2070          	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
   2071          	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
   \                     ??chk_mounted_8:
   \   00000080   0x2500             MOVS     R5,#+0
   \   00000082   0x0029             MOVS     R1,R5
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       check_fs
   \   0000008A   0x0006             MOVS     R6,R0
   2072          	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
   2073          	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
   \   0000008C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008E   0x2E01             CMP      R6,#+1
   \   00000090   0xD11C             BNE.N    ??chk_mounted_9
   2074          		/* Check the partition listed in the partition table */
   2075          		pi = LD2PT(vol);
   \   00000092   0x2000             MOVS     R0,#+0
   2076          		if (pi) pi--;
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD000             BEQ.N    ??chk_mounted_10
   \   0000009A   0x1E40             SUBS     R0,R0,#+1
   2077          		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
   \                     ??chk_mounted_10:
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0xEB14 0x1000      ADDS     R0,R4,R0, LSL #+4
   \   000000A2   0xF200 0x10F2      ADDW     R0,R0,#+498
   2078          		if (tbl[4]) {						/* Is the partition existing? */
   \   000000A6   0x7901             LDRB     R1,[R0, #+4]
   \   000000A8   0x2900             CMP      R1,#+0
   \   000000AA   0xD00F             BEQ.N    ??chk_mounted_9
   2079          			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
   \   000000AC   0x7AC1             LDRB     R1,[R0, #+11]
   \   000000AE   0x7A82             LDRB     R2,[R0, #+10]
   \   000000B0   0x0412             LSLS     R2,R2,#+16
   \   000000B2   0xEA52 0x6101      ORRS     R1,R2,R1, LSL #+24
   \   000000B6   0x7A42             LDRB     R2,[R0, #+9]
   \   000000B8   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   000000BC   0x7A00             LDRB     R0,[R0, #+8]
   \   000000BE   0xEA50 0x0501      ORRS     R5,R0,R1
   2080          			fmt = check_fs(fs, bsect);		/* Check the partition */
   \   000000C2   0x0029             MOVS     R1,R5
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x.... 0x....      BL       check_fs
   \   000000CA   0x0006             MOVS     R6,R0
   2081          		}
   2082          	}
   2083          	if (fmt == 3) return FR_DISK_ERR;
   \                     ??chk_mounted_9:
   \   000000CC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000CE   0x2E03             CMP      R6,#+3
   \   000000D0   0xD101             BNE.N    ??chk_mounted_11
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xE14B             B.N      ??chk_mounted_3
   2084          	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   \                     ??chk_mounted_11:
   \   000000D6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D8   0x2E00             CMP      R6,#+0
   \   000000DA   0xD001             BEQ.N    ??chk_mounted_12
   \   000000DC   0x200D             MOVS     R0,#+13
   \   000000DE   0xE146             B.N      ??chk_mounted_3
   2085          
   2086          	/* An FAT volume is found. Following code initializes the file system object */
   2087          
   2088          	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
   \                     ??chk_mounted_12:
   \   000000E0   0xF894 0x0040      LDRB     R0,[R4, #+64]
   \   000000E4   0xF894 0x103F      LDRB     R1,[R4, #+63]
   \   000000E8   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000EC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000EE   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000F2   0xD001             BEQ.N    ??chk_mounted_13
   2089          		return FR_NO_FILESYSTEM;
   \   000000F4   0x200D             MOVS     R0,#+13
   \   000000F6   0xE13A             B.N      ??chk_mounted_3
   2090          
   2091          	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
   \                     ??chk_mounted_13:
   \   000000F8   0xF894 0x004B      LDRB     R0,[R4, #+75]
   \   000000FC   0xF894 0x104A      LDRB     R1,[R4, #+74]
   \   00000100   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000104   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   2092          	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD10D             BNE.N    ??chk_mounted_14
   \   0000010A   0xF894 0x005B      LDRB     R0,[R4, #+91]
   \   0000010E   0xF894 0x105A      LDRB     R1,[R4, #+90]
   \   00000112   0x0409             LSLS     R1,R1,#+16
   \   00000114   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   00000118   0xF894 0x1059      LDRB     R1,[R4, #+89]
   \   0000011C   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000120   0xF894 0x1058      LDRB     R1,[R4, #+88]
   \   00000124   0x4308             ORRS     R0,R1,R0
   2093          	fs->fsize = fasize;
   \                     ??chk_mounted_14:
   \   00000126   0x6220             STR      R0,[R4, #+32]
   2094          
   2095          	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
   \   00000128   0xF894 0x1044      LDRB     R1,[R4, #+68]
   \   0000012C   0x70E1             STRB     R1,[R4, #+3]
   2096          	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
   \   0000012E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000130   0x2901             CMP      R1,#+1
   \   00000132   0xD004             BEQ.N    ??chk_mounted_15
   \   00000134   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000136   0x2902             CMP      R1,#+2
   \   00000138   0xD001             BEQ.N    ??chk_mounted_15
   \   0000013A   0x200D             MOVS     R0,#+13
   \   0000013C   0xE117             B.N      ??chk_mounted_3
   2097          	fasize *= b;										/* Number of sectors for FAT area */
   \                     ??chk_mounted_15:
   \   0000013E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000140   0x4348             MULS     R0,R1,R0
   2098          
   2099          	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
   \   00000142   0xF894 0x1041      LDRB     R1,[R4, #+65]
   \   00000146   0x70A1             STRB     R1,[R4, #+2]
   2100          	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
   \   00000148   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000014A   0x2900             CMP      R1,#+0
   \   0000014C   0xD003             BEQ.N    ??chk_mounted_16
   \   0000014E   0x1E4A             SUBS     R2,R1,#+1
   \   00000150   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000152   0x4211             TST      R1,R2
   \   00000154   0xD001             BEQ.N    ??chk_mounted_17
   \                     ??chk_mounted_16:
   \   00000156   0x200D             MOVS     R0,#+13
   \   00000158   0xE109             B.N      ??chk_mounted_3
   2101          
   2102          	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
   \                     ??chk_mounted_17:
   \   0000015A   0xF894 0x1046      LDRB     R1,[R4, #+70]
   \   0000015E   0xF894 0x2045      LDRB     R2,[R4, #+69]
   \   00000162   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000166   0x8121             STRH     R1,[R4, #+8]
   2103          	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
   \   00000168   0x8921             LDRH     R1,[R4, #+8]
   \   0000016A   0x2210             MOVS     R2,#+16
   \   0000016C   0xFBB1 0xF3F2      UDIV     R3,R1,R2
   \   00000170   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   00000174   0x2B00             CMP      R3,#+0
   \   00000176   0xD001             BEQ.N    ??chk_mounted_18
   \   00000178   0x200D             MOVS     R0,#+13
   \   0000017A   0xE0F8             B.N      ??chk_mounted_3
   2104          
   2105          	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
   \                     ??chk_mounted_18:
   \   0000017C   0xF894 0x1048      LDRB     R1,[R4, #+72]
   \   00000180   0xF894 0x2047      LDRB     R2,[R4, #+71]
   \   00000184   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \   00000188   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   2106          	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   \   0000018A   0x2A00             CMP      R2,#+0
   \   0000018C   0xD10D             BNE.N    ??chk_mounted_19
   \   0000018E   0xF894 0x1057      LDRB     R1,[R4, #+87]
   \   00000192   0xF894 0x2056      LDRB     R2,[R4, #+86]
   \   00000196   0x0412             LSLS     R2,R2,#+16
   \   00000198   0xEA52 0x6101      ORRS     R1,R2,R1, LSL #+24
   \   0000019C   0xF894 0x2055      LDRB     R2,[R4, #+85]
   \   000001A0   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   000001A4   0xF894 0x2054      LDRB     R2,[R4, #+84]
   \   000001A8   0x430A             ORRS     R2,R2,R1
   2107          
   2108          	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
   \                     ??chk_mounted_19:
   \   000001AA   0xF894 0x1043      LDRB     R1,[R4, #+67]
   \   000001AE   0xF894 0x3042      LDRB     R3,[R4, #+66]
   \   000001B2   0xEA53 0x2101      ORRS     R1,R3,R1, LSL #+8
   2109          	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
   \   000001B6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000001B8   0x2900             CMP      R1,#+0
   \   000001BA   0xD101             BNE.N    ??chk_mounted_20
   \   000001BC   0x200D             MOVS     R0,#+13
   \   000001BE   0xE0D6             B.N      ??chk_mounted_3
   2110          
   2111          	/* Determine the FAT sub type */
   2112          	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
   \                     ??chk_mounted_20:
   \   000001C0   0xFA10 0xF381      UXTAH    R3,R0,R1
   \   000001C4   0x8926             LDRH     R6,[R4, #+8]
   \   000001C6   0xEB13 0x1316      ADDS     R3,R3,R6, LSR #+4
   2113          	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   \   000001CA   0x429A             CMP      R2,R3
   \   000001CC   0xD201             BCS.N    ??chk_mounted_21
   \   000001CE   0x200D             MOVS     R0,#+13
   \   000001D0   0xE0CD             B.N      ??chk_mounted_3
   2114          	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   \                     ??chk_mounted_21:
   \   000001D2   0x1AD2             SUBS     R2,R2,R3
   \   000001D4   0x78A6             LDRB     R6,[R4, #+2]
   \   000001D6   0xFBB2 0xF2F6      UDIV     R2,R2,R6
   2115          	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   \   000001DA   0x2A00             CMP      R2,#+0
   \   000001DC   0xD101             BNE.N    ??chk_mounted_22
   \   000001DE   0x200D             MOVS     R0,#+13
   \   000001E0   0xE0C5             B.N      ??chk_mounted_3
   2116          	fmt = FS_FAT12;
   \                     ??chk_mounted_22:
   \   000001E2   0x2601             MOVS     R6,#+1
   2117          	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   \   000001E4   0xF640 0x77F6      MOVW     R7,#+4086
   \   000001E8   0x42BA             CMP      R2,R7
   \   000001EA   0xD300             BCC.N    ??chk_mounted_23
   \   000001EC   0x2602             MOVS     R6,#+2
   2118          	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   \                     ??chk_mounted_23:
   \   000001EE   0xF64F 0x77F6      MOVW     R7,#+65526
   \   000001F2   0x42BA             CMP      R2,R7
   \   000001F4   0xD300             BCC.N    ??chk_mounted_24
   \   000001F6   0x2603             MOVS     R6,#+3
   2119          
   2120          	/* Boundaries and Limits */
   2121          	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   \                     ??chk_mounted_24:
   \   000001F8   0x1C92             ADDS     R2,R2,#+2
   \   000001FA   0x61E2             STR      R2,[R4, #+28]
   2122          	fs->database = bsect + sysect;						/* Data start sector */
   \   000001FC   0x195A             ADDS     R2,R3,R5
   \   000001FE   0x62E2             STR      R2,[R4, #+44]
   2123          	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   \   00000200   0xFA15 0xF181      UXTAH    R1,R5,R1
   \   00000204   0x6261             STR      R1,[R4, #+36]
   2124          	if (fmt == FS_FAT32) {
   \   00000206   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000208   0x2E03             CMP      R6,#+3
   \   0000020A   0xD116             BNE.N    ??chk_mounted_25
   2125          		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   \   0000020C   0x8920             LDRH     R0,[R4, #+8]
   \   0000020E   0x2800             CMP      R0,#+0
   \   00000210   0xD001             BEQ.N    ??chk_mounted_26
   \   00000212   0x200D             MOVS     R0,#+13
   \   00000214   0xE0AB             B.N      ??chk_mounted_3
   2126          		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   \                     ??chk_mounted_26:
   \   00000216   0xF894 0x0063      LDRB     R0,[R4, #+99]
   \   0000021A   0xF894 0x1062      LDRB     R1,[R4, #+98]
   \   0000021E   0x0409             LSLS     R1,R1,#+16
   \   00000220   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   00000224   0xF894 0x1061      LDRB     R1,[R4, #+97]
   \   00000228   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   0000022C   0xF894 0x1060      LDRB     R1,[R4, #+96]
   \   00000230   0x4308             ORRS     R0,R1,R0
   \   00000232   0x62A0             STR      R0,[R4, #+40]
   2127          		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
   \   00000234   0x69E0             LDR      R0,[R4, #+28]
   \   00000236   0x0080             LSLS     R0,R0,#+2
   \   00000238   0xE015             B.N      ??chk_mounted_27
   2128          	} else {
   2129          		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   \                     ??chk_mounted_25:
   \   0000023A   0x8921             LDRH     R1,[R4, #+8]
   \   0000023C   0x2900             CMP      R1,#+0
   \   0000023E   0xD101             BNE.N    ??chk_mounted_28
   \   00000240   0x200D             MOVS     R0,#+13
   \   00000242   0xE094             B.N      ??chk_mounted_3
   2130          		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   \                     ??chk_mounted_28:
   \   00000244   0x6A61             LDR      R1,[R4, #+36]
   \   00000246   0x1840             ADDS     R0,R0,R1
   \   00000248   0x62A0             STR      R0,[R4, #+40]
   2131          		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
   2132          			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   \   0000024A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000024C   0x2E02             CMP      R6,#+2
   \   0000024E   0xD102             BNE.N    ??chk_mounted_29
   \   00000250   0x69E0             LDR      R0,[R4, #+28]
   \   00000252   0x0040             LSLS     R0,R0,#+1
   \   00000254   0xE007             B.N      ??chk_mounted_27
   \                     ??chk_mounted_29:
   \   00000256   0x69E0             LDR      R0,[R4, #+28]
   \   00000258   0x2103             MOVS     R1,#+3
   \   0000025A   0x4348             MULS     R0,R1,R0
   \   0000025C   0x7F21             LDRB     R1,[R4, #+28]
   \   0000025E   0xF011 0x0101      ANDS     R1,R1,#0x1
   \   00000262   0xEB11 0x0050      ADDS     R0,R1,R0, LSR #+1
   2133          	}
   2134          	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
   \                     ??chk_mounted_27:
   \   00000266   0x6A21             LDR      R1,[R4, #+32]
   \   00000268   0xF200 0x10FF      ADDW     R0,R0,#+511
   \   0000026C   0xEBB1 0x2F50      CMP      R1,R0, LSR #+9
   \   00000270   0xD201             BCS.N    ??chk_mounted_30
   2135          		return FR_NO_FILESYSTEM;
   \   00000272   0x200D             MOVS     R0,#+13
   \   00000274   0xE07B             B.N      ??chk_mounted_3
   2136          
   2137          #if !_FS_READONLY
   2138          	/* Initialize cluster allocation information */
   2139          	fs->free_clust = 0xFFFFFFFF;
   \                     ??chk_mounted_30:
   \   00000276   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000027A   0x6120             STR      R0,[R4, #+16]
   2140          	fs->last_clust = 0;
   \   0000027C   0x2000             MOVS     R0,#+0
   \   0000027E   0x60E0             STR      R0,[R4, #+12]
   2141          
   2142          	/* Get fsinfo if available */
   2143          	if (fmt == FS_FAT32) {
   \   00000280   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000282   0x2E03             CMP      R6,#+3
   \   00000284   0xD160             BNE.N    ??chk_mounted_31
   2144          	 	fs->fsi_flag = 0;
   \   00000286   0x2000             MOVS     R0,#+0
   \   00000288   0x7160             STRB     R0,[R4, #+5]
   2145          		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   \   0000028A   0xF894 0x0065      LDRB     R0,[R4, #+101]
   \   0000028E   0xF894 0x1064      LDRB     R1,[R4, #+100]
   \   00000292   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000296   0xFA15 0xF080      UXTAH    R0,R5,R0
   \   0000029A   0x6160             STR      R0,[R4, #+20]
   2146          		if (LPLD_Disk_Read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   2147          			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   2148          			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   2149          			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
   \   0000029C   0x2301             MOVS     R3,#+1
   \   0000029E   0x6962             LDR      R2,[R4, #+20]
   \   000002A0   0xF114 0x0134      ADDS     R1,R4,#+52
   \   000002A4   0x7860             LDRB     R0,[R4, #+1]
   \   000002A6   0x.... 0x....      BL       LPLD_Disk_Read
   \   000002AA   0x2800             CMP      R0,#+0
   \   000002AC   0xD14C             BNE.N    ??chk_mounted_31
   \   000002AE   0xF894 0x0233      LDRB     R0,[R4, #+563]
   \   000002B2   0xF894 0x1232      LDRB     R1,[R4, #+562]
   \   000002B6   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000002BA   0xF64A 0x2155      MOVW     R1,#+43605
   \   000002BE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000002C0   0x4288             CMP      R0,R1
   \   000002C2   0xD141             BNE.N    ??chk_mounted_31
   \   000002C4   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   000002C8   0xF894 0x1036      LDRB     R1,[R4, #+54]
   \   000002CC   0x0409             LSLS     R1,R1,#+16
   \   000002CE   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000002D2   0xF894 0x1035      LDRB     R1,[R4, #+53]
   \   000002D6   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000002DA   0xF894 0x1034      LDRB     R1,[R4, #+52]
   \   000002DE   0x4308             ORRS     R0,R1,R0
   \   000002E0   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x41615252
   \   000002E4   0x4288             CMP      R0,R1
   \   000002E6   0xD12F             BNE.N    ??chk_mounted_31
   \   000002E8   0xF894 0x021B      LDRB     R0,[R4, #+539]
   \   000002EC   0xF894 0x121A      LDRB     R1,[R4, #+538]
   \   000002F0   0x0409             LSLS     R1,R1,#+16
   \   000002F2   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000002F6   0xF894 0x1219      LDRB     R1,[R4, #+537]
   \   000002FA   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000002FE   0xF894 0x1218      LDRB     R1,[R4, #+536]
   \   00000302   0x4308             ORRS     R0,R1,R0
   \   00000304   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x61417272
   \   00000308   0x4288             CMP      R0,R1
   \   0000030A   0xD11D             BNE.N    ??chk_mounted_31
   2150          				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   \   0000030C   0xF894 0x0223      LDRB     R0,[R4, #+547]
   \   00000310   0xF894 0x1222      LDRB     R1,[R4, #+546]
   \   00000314   0x0409             LSLS     R1,R1,#+16
   \   00000316   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000031A   0xF894 0x1221      LDRB     R1,[R4, #+545]
   \   0000031E   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000322   0xF894 0x1220      LDRB     R1,[R4, #+544]
   \   00000326   0x4308             ORRS     R0,R1,R0
   \   00000328   0x60E0             STR      R0,[R4, #+12]
   2151          				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   \   0000032A   0xF894 0x021F      LDRB     R0,[R4, #+543]
   \   0000032E   0xF894 0x121E      LDRB     R1,[R4, #+542]
   \   00000332   0x0409             LSLS     R1,R1,#+16
   \   00000334   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   00000338   0xF894 0x121D      LDRB     R1,[R4, #+541]
   \   0000033C   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000340   0xF894 0x121C      LDRB     R1,[R4, #+540]
   \   00000344   0x4308             ORRS     R0,R1,R0
   \   00000346   0x6120             STR      R0,[R4, #+16]
   2152          		}
   2153          	}
   2154          #endif
   2155          	fs->fs_type = fmt;		/* FAT sub-type */
   \                     ??chk_mounted_31:
   \   00000348   0x7026             STRB     R6,[R4, #+0]
   2156          	fs->id = ++Fsid;		/* File system mount ID */
   \   0000034A   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   0000034E   0x8800             LDRH     R0,[R0, #+0]
   \   00000350   0x1C40             ADDS     R0,R0,#+1
   \   00000352   0x.... 0x....      LDR.W    R1,??DataTable13_5
   \   00000356   0x8008             STRH     R0,[R1, #+0]
   \   00000358   0x80E0             STRH     R0,[R4, #+6]
   2157          	fs->winsect = 0;		/* Invalidate sector cache */
   \   0000035A   0x2000             MOVS     R0,#+0
   \   0000035C   0x6320             STR      R0,[R4, #+48]
   2158          	fs->wflag = 0;
   \   0000035E   0x2000             MOVS     R0,#+0
   \   00000360   0x7120             STRB     R0,[R4, #+4]
   2159          #if _FS_RPATH
   2160          	fs->cdir = 0;			/* Current directory (root dir) */
   \   00000362   0x2000             MOVS     R0,#+0
   \   00000364   0x61A0             STR      R0,[R4, #+24]
   2161          #endif
   2162          #if _FS_SHARE				/* Clear file lock semaphores */
   2163          	clear_lock(fs);
   \   00000366   0x0020             MOVS     R0,R4
   \   00000368   0x.... 0x....      BL       clear_lock
   2164          #endif
   2165          
   2166          	return FR_OK;
   \   0000036C   0x2000             MOVS     R0,#+0
   \                     ??chk_mounted_3:
   \   0000036E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2167          }
   2168          
   2169          
   2170          
   2171          
   2172          /*-----------------------------------------------------------------------*/
   2173          /* Check if the file/dir object is valid or not                          */
   2174          /*-----------------------------------------------------------------------*/
   2175          

   \                                 In section .text, align 2, keep-with-next
   2176          static
   2177          FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
   2178          	FATFS *fs,		/* Pointer to the file system object */
   2179          	WORD id			/* Member id of the target object to be checked */
   2180          )
   2181          {
   \                     validate:
   \   00000000   0xB580             PUSH     {R7,LR}
   2182          	if (!fs || !fs->fs_type || fs->id != id)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD006             BEQ.N    ??validate_0
   \   00000006   0x7802             LDRB     R2,[R0, #+0]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD003             BEQ.N    ??validate_0
   \   0000000C   0x88C2             LDRH     R2,[R0, #+6]
   \   0000000E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000010   0x428A             CMP      R2,R1
   \   00000012   0xD001             BEQ.N    ??validate_1
   2183          		return FR_INVALID_OBJECT;
   \                     ??validate_0:
   \   00000014   0x2009             MOVS     R0,#+9
   \   00000016   0xE007             B.N      ??validate_2
   2184          
   2185          	ENTER_FF(fs);		/* Lock file system */
   2186          
   2187          	if (LPLD_Disk_Status(fs->drv) & STA_NOINIT)
   \                     ??validate_1:
   \   00000018   0x7840             LDRB     R0,[R0, #+1]
   \   0000001A   0x.... 0x....      BL       LPLD_Disk_Status
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD501             BPL.N    ??validate_3
   2188          		return FR_NOT_READY;
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xE000             B.N      ??validate_2
   2189          
   2190          	return FR_OK;
   \                     ??validate_3:
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??validate_2:
   \   00000028   0xBD02             POP      {R1,PC}          ;; return
   2191          }
   2192          
   2193          
   2194          
   2195          
   2196          /*--------------------------------------------------------------------------
   2197          
   2198             Public Functions
   2199          
   2200          --------------------------------------------------------------------------*/
   2201          
   2202          
   2203          
   2204          /*-----------------------------------------------------------------------*/
   2205          /* Mount/Unmount a Logical Drive                                         */
   2206          /*-----------------------------------------------------------------------*/
   2207          

   \                                 In section .text, align 2, keep-with-next
   2208          FRESULT f_mount (
   2209          	BYTE vol,		/* Logical drive number to be mounted/unmounted */
   2210          	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
   2211          )
   2212          {
   \                     f_mount:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2213          	FATFS *rfs;
   2214          
   2215          
   2216          	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD301             BCC.N    ??f_mount_0
   2217          		return FR_INVALID_DRIVE;
   \   0000000C   0x200B             MOVS     R0,#+11
   \   0000000E   0xE015             B.N      ??f_mount_1
   2218          	rfs = FatFs[vol];			/* Get current fs object */
   \                     ??f_mount_0:
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000016   0xF850 0x6024      LDR      R6,[R0, R4, LSL #+2]
   2219          
   2220          	if (rfs) {
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD004             BEQ.N    ??f_mount_2
   2221          #if _FS_SHARE
   2222          		clear_lock(rfs);
   \   0000001E   0x0030             MOVS     R0,R6
   \   00000020   0x.... 0x....      BL       clear_lock
   2223          #endif
   2224          #if _FS_REENTRANT				/* Discard sync object of the current volume */
   2225          		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
   2226          #endif
   2227          		rfs->fs_type = 0;		/* Clear old fs object */
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x7030             STRB     R0,[R6, #+0]
   2228          	}
   2229          
   2230          	if (fs) {
   \                     ??f_mount_2:
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD001             BEQ.N    ??f_mount_3
   2231          		fs->fs_type = 0;		/* Clear new fs object */
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7028             STRB     R0,[R5, #+0]
   2232          #if _FS_REENTRANT				/* Create sync object for the new volume */
   2233          		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
   2234          #endif
   2235          	}
   2236          	FatFs[vol] = fs;			/* Register new fs object */
   \                     ??f_mount_3:
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000036   0xF840 0x5024      STR      R5,[R0, R4, LSL #+2]
   2237          
   2238          	return FR_OK;
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??f_mount_1:
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
   2239          }
   2240          
   2241          
   2242          
   2243          
   2244          /*-----------------------------------------------------------------------*/
   2245          /* Open or Create a File                                                 */
   2246          /*-----------------------------------------------------------------------*/
   2247          

   \                                 In section .text, align 2, keep-with-next
   2248          FRESULT f_open (
   2249          	FIL *fp,			/* Pointer to the blank file object */
   2250          	const TCHAR *path,	/* Pointer to the file name */
   2251          	BYTE mode			/* Access mode and file open mode flags */
   2252          )
   2253          {
   \                     f_open:
   \   00000000   0xE92D 0x47F2      PUSH     {R1,R4-R10,LR}
   \   00000004   0xB08D             SUB      SP,SP,#+52
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x0016             MOVS     R6,R2
   2254          	FRESULT res;
   2255          	DIR dj;
   2256          	BYTE *dir;
   2257          	DEF_NAMEBUF;
   2258          
   2259          
   2260          	fp->fs = 0;			/* Clear file object */
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x6020             STR      R0,[R4, #+0]
   2261          
   2262          #if !_FS_READONLY
   2263          	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   \   0000000E   0xF016 0x061F      ANDS     R6,R6,#0x1F
   2264          	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
   \   00000012   0xF016 0x02FE      ANDS     R2,R6,#0xFE
   \   00000016   0xA900             ADD      R1,SP,#+0
   \   00000018   0xA80D             ADD      R0,SP,#+52
   \   0000001A   0x.... 0x....      BL       chk_mounted
   \   0000001E   0x0007             MOVS     R7,R0
   2265          #else
   2266          	mode &= FA_READ;
   2267          	res = chk_mounted(&path, &dj.fs, 0);
   2268          #endif
   2269          	INIT_BUF(dj);
   \   00000020   0x2082             MOVS     R0,#+130
   \   00000022   0x.... 0x....      BL       ff_memalloc
   \   00000026   0x0005             MOVS     R5,R0
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD101             BNE.N    ??f_open_0
   \   0000002C   0x2011             MOVS     R0,#+17
   \   0000002E   0xE0FB             B.N      ??f_open_1
   \                     ??f_open_0:
   \   00000030   0x9507             STR      R5,[SP, #+28]
   \   00000032   0xA809             ADD      R0,SP,#+36
   \   00000034   0x9006             STR      R0,[SP, #+24]
   2270          	if (res == FR_OK)
   \   00000036   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000038   0x2F00             CMP      R7,#+0
   \   0000003A   0xD104             BNE.N    ??f_open_2
   2271          		res = follow_path(&dj, path);	/* Follow the file path */
   \   0000003C   0x990D             LDR      R1,[SP, #+52]
   \   0000003E   0xA800             ADD      R0,SP,#+0
   \   00000040   0x.... 0x....      BL       follow_path
   \   00000044   0x0007             MOVS     R7,R0
   2272          	dir = dj.dir;
   \                     ??f_open_2:
   \   00000046   0xF8DD 0x8014      LDR      R8,[SP, #+20]
   2273          
   2274          #if !_FS_READONLY	/* R/W configuration */
   2275          	if (res == FR_OK) {
   \   0000004A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   0x2F00             CMP      R7,#+0
   \   0000004E   0xD10E             BNE.N    ??f_open_3
   2276          		if (!dir)	/* Current dir itself */
   \   00000050   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000054   0xD101             BNE.N    ??f_open_4
   2277          			res = FR_INVALID_NAME;
   \   00000056   0x2706             MOVS     R7,#+6
   \   00000058   0xE009             B.N      ??f_open_3
   2278          #if _FS_SHARE
   2279          		else
   2280          			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   \                     ??f_open_4:
   \   0000005A   0x20FE             MOVS     R0,#+254
   \   0000005C   0x4206             TST      R6,R0
   \   0000005E   0xD001             BEQ.N    ??f_open_5
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0xE000             B.N      ??f_open_6
   \                     ??f_open_5:
   \   00000064   0x2100             MOVS     R1,#+0
   \                     ??f_open_6:
   \   00000066   0xA800             ADD      R0,SP,#+0
   \   00000068   0x.... 0x....      BL       chk_lock
   \   0000006C   0x0007             MOVS     R7,R0
   2281          #endif
   2282          	}
   2283          	/* Create or Open a file */
   2284          	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   \                     ??f_open_3:
   \   0000006E   0x201C             MOVS     R0,#+28
   \   00000070   0x4206             TST      R6,R0
   \   00000072   0xD07B             BEQ.N    ??f_open_7
   2285          		DWORD dw, cl;
   2286          
   2287          		if (res != FR_OK) {					/* No file, create new */
   \   00000074   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000076   0x2F00             CMP      R7,#+0
   \   00000078   0xD011             BEQ.N    ??f_open_8
   2288          			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   \   0000007A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007C   0x2F04             CMP      R7,#+4
   \   0000007E   0xD109             BNE.N    ??f_open_9
   2289          #if _FS_SHARE
   2290          				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   \   00000080   0x.... 0x....      BL       enq_lock
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD004             BEQ.N    ??f_open_10
   \   00000088   0xA800             ADD      R0,SP,#+0
   \   0000008A   0x.... 0x....      BL       dir_register
   \   0000008E   0x0007             MOVS     R7,R0
   \   00000090   0xE000             B.N      ??f_open_11
   \                     ??f_open_10:
   \   00000092   0x2712             MOVS     R7,#+18
   2291          #else
   2292          				res = dir_register(&dj);
   2293          #endif
   2294          			mode |= FA_CREATE_ALWAYS;		/* File is created */
   \                     ??f_open_11:
   \                     ??f_open_9:
   \   00000094   0xF056 0x0608      ORRS     R6,R6,#0x8
   2295          			dir = dj.dir;					/* New entry */
   \   00000098   0xF8DD 0x8014      LDR      R8,[SP, #+20]
   \   0000009C   0xE009             B.N      ??f_open_12
   2296          		}
   2297          		else {								/* Any object is already existing */
   2298          			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   \                     ??f_open_8:
   \   0000009E   0xF898 0x000B      LDRB     R0,[R8, #+11]
   \   000000A2   0x2111             MOVS     R1,#+17
   \   000000A4   0x4208             TST      R0,R1
   \   000000A6   0xD001             BEQ.N    ??f_open_13
   2299          				res = FR_DENIED;
   \   000000A8   0x2707             MOVS     R7,#+7
   \   000000AA   0xE002             B.N      ??f_open_12
   2300          			} else {
   2301          				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
   \                     ??f_open_13:
   \   000000AC   0x0770             LSLS     R0,R6,#+29
   \   000000AE   0xD500             BPL.N    ??f_open_12
   2302          					res = FR_EXIST;
   \   000000B0   0x2708             MOVS     R7,#+8
   2303          			}
   2304          		}
   2305          		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   \                     ??f_open_12:
   \   000000B2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B4   0x2F00             CMP      R7,#+0
   \   000000B6   0xD169             BNE.N    ??f_open_14
   \   000000B8   0x0730             LSLS     R0,R6,#+28
   \   000000BA   0xD567             BPL.N    ??f_open_14
   2306          			dw = get_fattime();					/* Created time */
   \   000000BC   0x.... 0x....      BL       get_fattime
   \   000000C0   0x4681             MOV      R9,R0
   2307          			ST_DWORD(dir+DIR_CrtTime, dw);
   \   000000C2   0xF888 0x900E      STRB     R9,[R8, #+14]
   \   000000C6   0x4648             MOV      R0,R9
   \   000000C8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000CA   0x0A00             LSRS     R0,R0,#+8
   \   000000CC   0xF888 0x000F      STRB     R0,[R8, #+15]
   \   000000D0   0xEA5F 0x4019      LSRS     R0,R9,#+16
   \   000000D4   0xF888 0x0010      STRB     R0,[R8, #+16]
   \   000000D8   0xEA5F 0x6019      LSRS     R0,R9,#+24
   \   000000DC   0xF888 0x0011      STRB     R0,[R8, #+17]
   2308          			dir[DIR_Attr] = 0;					/* Reset attribute */
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0xF888 0x000B      STRB     R0,[R8, #+11]
   2309          			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xF888 0x001C      STRB     R0,[R8, #+28]
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xF888 0x001D      STRB     R0,[R8, #+29]
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xF888 0x001E      STRB     R0,[R8, #+30]
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF888 0x001F      STRB     R0,[R8, #+31]
   2310          			cl = LD_CLUST(dir);					/* Get start cluster */
   \   000000FE   0xF898 0x0015      LDRB     R0,[R8, #+21]
   \   00000102   0xF898 0x1014      LDRB     R1,[R8, #+20]
   \   00000106   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000010A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000010C   0xF898 0x101B      LDRB     R1,[R8, #+27]
   \   00000110   0xF898 0x201A      LDRB     R2,[R8, #+26]
   \   00000114   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000118   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000011A   0xEA51 0x4A00      ORRS     R10,R1,R0, LSL #+16
   2311          			ST_CLUST(dir, 0);					/* cluster = 0 */
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0xF888 0x001A      STRB     R0,[R8, #+26]
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0xF888 0x001B      STRB     R0,[R8, #+27]
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0xF888 0x0014      STRB     R0,[R8, #+20]
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0xF888 0x0015      STRB     R0,[R8, #+21]
   2312          			dj.fs->wflag = 1;
   \   00000136   0x9800             LDR      R0,[SP, #+0]
   \   00000138   0x2101             MOVS     R1,#+1
   \   0000013A   0x7101             STRB     R1,[R0, #+4]
   2313          			if (cl) {							/* Remove the cluster chain if exist */
   \   0000013C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000140   0xD024             BEQ.N    ??f_open_14
   2314          				dw = dj.fs->winsect;
   \   00000142   0x9800             LDR      R0,[SP, #+0]
   \   00000144   0xF8D0 0x9030      LDR      R9,[R0, #+48]
   2315          				res = remove_chain(dj.fs, cl);
   \   00000148   0x4651             MOV      R1,R10
   \   0000014A   0x9800             LDR      R0,[SP, #+0]
   \   0000014C   0x.... 0x....      BL       remove_chain
   \   00000150   0x0007             MOVS     R7,R0
   2316          				if (res == FR_OK) {
   \   00000152   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000154   0x2F00             CMP      R7,#+0
   \   00000156   0xD119             BNE.N    ??f_open_14
   2317          					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   \   00000158   0x9800             LDR      R0,[SP, #+0]
   \   0000015A   0xF1BA 0x0101      SUBS     R1,R10,#+1
   \   0000015E   0x60C1             STR      R1,[R0, #+12]
   2318          					res = move_window(dj.fs, dw);
   \   00000160   0x4649             MOV      R1,R9
   \   00000162   0x9800             LDR      R0,[SP, #+0]
   \   00000164   0x.... 0x....      BL       move_window
   \   00000168   0x0007             MOVS     R7,R0
   \   0000016A   0xE00F             B.N      ??f_open_14
   2319          				}
   2320          			}
   2321          		}
   2322          	}
   2323          	else {	/* Open an existing file */
   2324          		if (res == FR_OK) {						/* Follow succeeded */
   \                     ??f_open_7:
   \   0000016C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000016E   0x2F00             CMP      R7,#+0
   \   00000170   0xD10C             BNE.N    ??f_open_14
   2325          			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
   \   00000172   0xF898 0x000B      LDRB     R0,[R8, #+11]
   \   00000176   0x06C0             LSLS     R0,R0,#+27
   \   00000178   0xD501             BPL.N    ??f_open_15
   2326          				res = FR_NO_FILE;
   \   0000017A   0x2704             MOVS     R7,#+4
   \   0000017C   0xE006             B.N      ??f_open_14
   2327          			} else {
   2328          				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   \                     ??f_open_15:
   \   0000017E   0x07B0             LSLS     R0,R6,#+30
   \   00000180   0xD504             BPL.N    ??f_open_14
   \   00000182   0xF898 0x000B      LDRB     R0,[R8, #+11]
   \   00000186   0x07C0             LSLS     R0,R0,#+31
   \   00000188   0xD500             BPL.N    ??f_open_14
   2329          					res = FR_DENIED;
   \   0000018A   0x2707             MOVS     R7,#+7
   2330          			}
   2331          		}
   2332          	}
   2333          	if (res == FR_OK) {
   \                     ??f_open_14:
   \   0000018C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000018E   0x2F00             CMP      R7,#+0
   \   00000190   0xD116             BNE.N    ??f_open_16
   2334          		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
   \   00000192   0x0730             LSLS     R0,R6,#+28
   \   00000194   0xD501             BPL.N    ??f_open_17
   2335          			mode |= FA__WRITTEN;
   \   00000196   0xF056 0x0620      ORRS     R6,R6,#0x20
   2336          		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
   \                     ??f_open_17:
   \   0000019A   0x9800             LDR      R0,[SP, #+0]
   \   0000019C   0x6B00             LDR      R0,[R0, #+48]
   \   0000019E   0x61E0             STR      R0,[R4, #+28]
   2337          		fp->dir_ptr = dir;
   \   000001A0   0xF8C4 0x8020      STR      R8,[R4, #+32]
   2338          #if _FS_SHARE
   2339          		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   \   000001A4   0x20FE             MOVS     R0,#+254
   \   000001A6   0x4206             TST      R6,R0
   \   000001A8   0xD001             BEQ.N    ??f_open_18
   \   000001AA   0x2101             MOVS     R1,#+1
   \   000001AC   0xE000             B.N      ??f_open_19
   \                     ??f_open_18:
   \   000001AE   0x2100             MOVS     R1,#+0
   \                     ??f_open_19:
   \   000001B0   0xA800             ADD      R0,SP,#+0
   \   000001B2   0x.... 0x....      BL       inc_lock
   \   000001B6   0x62A0             STR      R0,[R4, #+40]
   2340          		if (!fp->lockid) res = FR_INT_ERR;
   \   000001B8   0x6AA0             LDR      R0,[R4, #+40]
   \   000001BA   0x2800             CMP      R0,#+0
   \   000001BC   0xD100             BNE.N    ??f_open_16
   \   000001BE   0x2702             MOVS     R7,#+2
   2341          #endif
   2342          	}
   2343          
   2344          #else				/* R/O configuration */
   2345          	if (res == FR_OK) {					/* Follow succeeded */
   2346          		if (!dir) {						/* Current dir itself */
   2347          			res = FR_INVALID_NAME;
   2348          		} else {
   2349          			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
   2350          				res = FR_NO_FILE;
   2351          		}
   2352          	}
   2353          #endif
   2354          	FREE_BUF();
   \                     ??f_open_16:
   \   000001C0   0x0028             MOVS     R0,R5
   \   000001C2   0x.... 0x....      BL       ff_memfree
   2355          
   2356          	if (res == FR_OK) {
   \   000001C6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001C8   0x2F00             CMP      R7,#+0
   \   000001CA   0xD12B             BNE.N    ??f_open_20
   2357          		fp->flag = mode;					/* File access mode */
   \   000001CC   0x71A6             STRB     R6,[R4, #+6]
   2358          		fp->sclust = LD_CLUST(dir);			/* File start cluster */
   \   000001CE   0xF898 0x0015      LDRB     R0,[R8, #+21]
   \   000001D2   0xF898 0x1014      LDRB     R1,[R8, #+20]
   \   000001D6   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000001DA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001DC   0xF898 0x101B      LDRB     R1,[R8, #+27]
   \   000001E0   0xF898 0x201A      LDRB     R2,[R8, #+26]
   \   000001E4   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   000001E8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000001EA   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   000001EE   0x6120             STR      R0,[R4, #+16]
   2359          		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
   \   000001F0   0xF898 0x001F      LDRB     R0,[R8, #+31]
   \   000001F4   0xF898 0x101E      LDRB     R1,[R8, #+30]
   \   000001F8   0x0409             LSLS     R1,R1,#+16
   \   000001FA   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000001FE   0xF898 0x101D      LDRB     R1,[R8, #+29]
   \   00000202   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000206   0xF898 0x101C      LDRB     R1,[R8, #+28]
   \   0000020A   0x4308             ORRS     R0,R1,R0
   \   0000020C   0x60E0             STR      R0,[R4, #+12]
   2360          		fp->fptr = 0;						/* File pointer */
   \   0000020E   0x2000             MOVS     R0,#+0
   \   00000210   0x60A0             STR      R0,[R4, #+8]
   2361          		fp->dsect = 0;
   \   00000212   0x2000             MOVS     R0,#+0
   \   00000214   0x61A0             STR      R0,[R4, #+24]
   2362          #if _USE_FASTSEEK
   2363          		fp->cltbl = 0;						/* Normal seek mode */
   \   00000216   0x2000             MOVS     R0,#+0
   \   00000218   0x6260             STR      R0,[R4, #+36]
   2364          #endif
   2365          		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
   \   0000021A   0x9800             LDR      R0,[SP, #+0]
   \   0000021C   0x6020             STR      R0,[R4, #+0]
   \   0000021E   0x9800             LDR      R0,[SP, #+0]
   \   00000220   0x88C0             LDRH     R0,[R0, #+6]
   \   00000222   0x80A0             STRH     R0,[R4, #+4]
   2366          	}
   2367          
   2368          	LEAVE_FF(dj.fs, res);
   \                     ??f_open_20:
   \   00000224   0x0038             MOVS     R0,R7
   \   00000226   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_open_1:
   \   00000228   0xB00E             ADD      SP,SP,#+56
   \   0000022A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2369          }
   2370          
   2371          
   2372          
   2373          
   2374          /*-----------------------------------------------------------------------*/
   2375          /* Read File                                                             */
   2376          /*-----------------------------------------------------------------------*/
   2377          

   \                                 In section .text, align 2, keep-with-next
   2378          FRESULT f_read (
   2379          	FIL *fp, 		/* Pointer to the file object */
   2380          	void *buff,		/* Pointer to data buffer */
   2381          	UINT btr,		/* Number of bytes to read */
   2382          	UINT *br		/* Pointer to number of bytes read */
   2383          )
   2384          {
   \                     f_read:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   2385          	FRESULT res;
   2386          	DWORD clst, sect, remain;
   2387          	UINT rcnt, cc;
   2388          	BYTE csect, *rbuff = buff;
   \   0000000A   0x000C             MOVS     R4,R1
   2389          
   2390          
   2391          	*br = 0;	/* Initialize byte counter */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6038             STR      R0,[R7, #+0]
   2392          
   2393          	res = validate(fp->fs, fp->id);				/* Check validity */
   \   00000010   0x88A9             LDRH     R1,[R5, #+4]
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x.... 0x....      BL       validate
   2394          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??f_read_0
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xE0EB             B.N      ??f_read_1
   2395          	if (fp->flag & FA__ERROR)					/* Aborted file? */
   \                     ??f_read_0:
   \   00000022   0x79A8             LDRB     R0,[R5, #+6]
   \   00000024   0x0600             LSLS     R0,R0,#+24
   \   00000026   0xD501             BPL.N    ??f_read_2
   2396          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE0E6             B.N      ??f_read_1
   2397          	if (!(fp->flag & FA_READ)) 					/* Check access mode */
   \                     ??f_read_2:
   \   0000002C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000002E   0x07C0             LSLS     R0,R0,#+31
   \   00000030   0xD401             BMI.N    ??f_read_3
   2398          		LEAVE_FF(fp->fs, FR_DENIED);
   \   00000032   0x2007             MOVS     R0,#+7
   \   00000034   0xE0E1             B.N      ??f_read_1
   2399          	remain = fp->fsize - fp->fptr;
   \                     ??f_read_3:
   \   00000036   0x68E8             LDR      R0,[R5, #+12]
   \   00000038   0x68A9             LDR      R1,[R5, #+8]
   \   0000003A   0x1A40             SUBS     R0,R0,R1
   2400          	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
   \   0000003C   0x42B0             CMP      R0,R6
   \   0000003E   0xD229             BCS.N    ??f_read_4
   \   00000040   0x0006             MOVS     R6,R0
   \   00000042   0xE027             B.N      ??f_read_4
   2401          
   2402          	for ( ;  btr;								/* Repeat until all data read */
   2403          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   2404          		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
   2405          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2406          			if (!csect) {						/* On the cluster boundary? */
   2407          				if (fp->fptr == 0) {			/* On the top of the file? */
   2408          					clst = fp->sclust;			/* Follow from the origin */
   2409          				} else {						/* Middle or end of the file */
   2410          #if _USE_FASTSEEK
   2411          					if (fp->cltbl)
   2412          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2413          					else
   2414          #endif
   2415          						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
   2416          				}
   2417          				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
   2418          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2419          				fp->clust = clst;				/* Update current cluster */
   2420          			}
   2421          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   2422          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2423          			sect += csect;
   2424          			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
   2425          			if (cc) {							/* Read maximum contiguous sectors directly */
   2426          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   2427          					cc = fp->fs->csize - csect;
   2428          				if (LPLD_Disk_Read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
   2429          					ABORT(fp->fs, FR_DISK_ERR);
   2430          #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
   2431          #if _FS_TINY
   2432          				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
   2433          					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
   2434          #else
   2435          				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
   2436          					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   2437          #endif
   2438          #endif
   2439          				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
   2440          				continue;
   2441          			}
   2442          #if !_FS_TINY
   2443          			if (fp->dsect != sect) {			/* Load data sector if not in cache */
   2444          #if !_FS_READONLY
   2445          				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   2446          					if (LPLD_Disk_Write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2447          						ABORT(fp->fs, FR_DISK_ERR);
   2448          					fp->flag &= ~FA__DIRTY;
   2449          				}
   2450          #endif
   2451          				if (LPLD_Disk_Read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
   2452          					ABORT(fp->fs, FR_DISK_ERR);
   2453          			}
   2454          #endif
   2455          			fp->dsect = sect;
   \                     ??f_read_5:
   \   00000044   0xF8C5 0x9018      STR      R9,[R5, #+24]
   2456          		}
   2457          		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
   \                     ??f_read_6:
   \   00000048   0x68A8             LDR      R0,[R5, #+8]
   \   0000004A   0xF44F 0x7100      MOV      R1,#+512
   \   0000004E   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000052   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   00000056   0xF5D2 0x7800      RSBS     R8,R2,#+512
   2458          		if (rcnt > btr) rcnt = btr;
   \   0000005A   0x4546             CMP      R6,R8
   \   0000005C   0xD200             BCS.N    ??f_read_7
   \   0000005E   0x46B0             MOV      R8,R6
   2459          #if _FS_TINY
   2460          		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
   2461          			ABORT(fp->fs, FR_DISK_ERR);
   2462          		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   2463          #else
   2464          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   \                     ??f_read_7:
   \   00000060   0x4642             MOV      R2,R8
   \   00000062   0x68A8             LDR      R0,[R5, #+8]
   \   00000064   0xF44F 0x7100      MOV      R1,#+512
   \   00000068   0xFBB0 0xF3F1      UDIV     R3,R0,R1
   \   0000006C   0xFB03 0x0311      MLS      R3,R3,R1,R0
   \   00000070   0x1958             ADDS     R0,R3,R5
   \   00000072   0xF110 0x012C      ADDS     R1,R0,#+44
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       mem_cpy
   \                     ??f_read_8:
   \   0000007C   0xEB18 0x0404      ADDS     R4,R8,R4
   \   00000080   0x68A8             LDR      R0,[R5, #+8]
   \   00000082   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000086   0x60A8             STR      R0,[R5, #+8]
   \   00000088   0x6838             LDR      R0,[R7, #+0]
   \   0000008A   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000008E   0x6038             STR      R0,[R7, #+0]
   \   00000090   0xEBB6 0x0608      SUBS     R6,R6,R8
   \                     ??f_read_4:
   \   00000094   0x2E00             CMP      R6,#+0
   \   00000096   0xF000 0x80AF      BEQ.W    ??f_read_9
   \   0000009A   0x68A8             LDR      R0,[R5, #+8]
   \   0000009C   0xF44F 0x7100      MOV      R1,#+512
   \   000000A0   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000A4   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000A8   0x2A00             CMP      R2,#+0
   \   000000AA   0xD1CD             BNE.N    ??f_read_6
   \   000000AC   0x68A8             LDR      R0,[R5, #+8]
   \   000000AE   0x0A40             LSRS     R0,R0,#+9
   \   000000B0   0x6829             LDR      R1,[R5, #+0]
   \   000000B2   0x7889             LDRB     R1,[R1, #+2]
   \   000000B4   0x1E49             SUBS     R1,R1,#+1
   \   000000B6   0xEA11 0x0800      ANDS     R8,R1,R0
   \   000000BA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000BE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000C2   0xD122             BNE.N    ??f_read_10
   \   000000C4   0x68A8             LDR      R0,[R5, #+8]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD101             BNE.N    ??f_read_11
   \   000000CA   0x6928             LDR      R0,[R5, #+16]
   \   000000CC   0xE00B             B.N      ??f_read_12
   \                     ??f_read_11:
   \   000000CE   0x6A68             LDR      R0,[R5, #+36]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD004             BEQ.N    ??f_read_13
   \   000000D4   0x68A9             LDR      R1,[R5, #+8]
   \   000000D6   0x0028             MOVS     R0,R5
   \   000000D8   0x.... 0x....      BL       clmt_clust
   \   000000DC   0xE003             B.N      ??f_read_12
   \                     ??f_read_13:
   \   000000DE   0x6969             LDR      R1,[R5, #+20]
   \   000000E0   0x6828             LDR      R0,[R5, #+0]
   \   000000E2   0x.... 0x....      BL       get_fat
   \                     ??f_read_12:
   \   000000E6   0x2802             CMP      R0,#+2
   \   000000E8   0xD205             BCS.N    ??f_read_14
   \   000000EA   0x79A8             LDRB     R0,[R5, #+6]
   \   000000EC   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000F0   0x71A8             STRB     R0,[R5, #+6]
   \   000000F2   0x2002             MOVS     R0,#+2
   \   000000F4   0xE081             B.N      ??f_read_1
   \                     ??f_read_14:
   \   000000F6   0xF110 0x0F01      CMN      R0,#+1
   \   000000FA   0xD105             BNE.N    ??f_read_15
   \   000000FC   0x79A8             LDRB     R0,[R5, #+6]
   \   000000FE   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000102   0x71A8             STRB     R0,[R5, #+6]
   \   00000104   0x2001             MOVS     R0,#+1
   \   00000106   0xE078             B.N      ??f_read_1
   \                     ??f_read_15:
   \   00000108   0x6168             STR      R0,[R5, #+20]
   \                     ??f_read_10:
   \   0000010A   0x6969             LDR      R1,[R5, #+20]
   \   0000010C   0x6828             LDR      R0,[R5, #+0]
   \   0000010E   0x.... 0x....      BL       clust2sect
   \   00000112   0x4681             MOV      R9,R0
   \   00000114   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000118   0xD105             BNE.N    ??f_read_16
   \   0000011A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000011C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000120   0x71A8             STRB     R0,[R5, #+6]
   \   00000122   0x2002             MOVS     R0,#+2
   \   00000124   0xE069             B.N      ??f_read_1
   \                     ??f_read_16:
   \   00000126   0xFA59 0xF988      UXTAB    R9,R9,R8
   \   0000012A   0xEA5F 0x2A56      LSRS     R10,R6,#+9
   \   0000012E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000132   0xD035             BEQ.N    ??f_read_17
   \   00000134   0x6828             LDR      R0,[R5, #+0]
   \   00000136   0x7880             LDRB     R0,[R0, #+2]
   \   00000138   0xFA5A 0xF188      UXTAB    R1,R10,R8
   \   0000013C   0x4288             CMP      R0,R1
   \   0000013E   0xD205             BCS.N    ??f_read_18
   \   00000140   0x6828             LDR      R0,[R5, #+0]
   \   00000142   0x7880             LDRB     R0,[R0, #+2]
   \   00000144   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000148   0xEBB0 0x0A08      SUBS     R10,R0,R8
   \                     ??f_read_18:
   \   0000014C   0x4653             MOV      R3,R10
   \   0000014E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000150   0x464A             MOV      R2,R9
   \   00000152   0x0021             MOVS     R1,R4
   \   00000154   0x6828             LDR      R0,[R5, #+0]
   \   00000156   0x7840             LDRB     R0,[R0, #+1]
   \   00000158   0x.... 0x....      BL       LPLD_Disk_Read
   \   0000015C   0x2800             CMP      R0,#+0
   \   0000015E   0xD005             BEQ.N    ??f_read_19
   \   00000160   0x79A8             LDRB     R0,[R5, #+6]
   \   00000162   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000166   0x71A8             STRB     R0,[R5, #+6]
   \   00000168   0x2001             MOVS     R0,#+1
   \   0000016A   0xE046             B.N      ??f_read_1
   \                     ??f_read_19:
   \   0000016C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000016E   0x0640             LSLS     R0,R0,#+25
   \   00000170   0xD511             BPL.N    ??f_read_20
   \   00000172   0x69A8             LDR      R0,[R5, #+24]
   \   00000174   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   00000178   0x4550             CMP      R0,R10
   \   0000017A   0xD20C             BCS.N    ??f_read_20
   \   0000017C   0xF44F 0x7200      MOV      R2,#+512
   \   00000180   0xF115 0x012C      ADDS     R1,R5,#+44
   \   00000184   0x69A8             LDR      R0,[R5, #+24]
   \   00000186   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   0000018A   0xF44F 0x7300      MOV      R3,#+512
   \   0000018E   0xFB03 0x4000      MLA      R0,R3,R0,R4
   \   00000192   0x.... 0x....      BL       mem_cpy
   \                     ??f_read_20:
   \   00000196   0xF44F 0x7000      MOV      R0,#+512
   \   0000019A   0xFB00 0xF80A      MUL      R8,R0,R10
   \   0000019E   0xE76D             B.N      ??f_read_8
   \                     ??f_read_17:
   \   000001A0   0x69A8             LDR      R0,[R5, #+24]
   \   000001A2   0x4548             CMP      R0,R9
   \   000001A4   0xF43F 0xAF4E      BEQ.W    ??f_read_5
   \   000001A8   0x79A8             LDRB     R0,[R5, #+6]
   \   000001AA   0x0640             LSLS     R0,R0,#+25
   \   000001AC   0xD513             BPL.N    ??f_read_21
   \   000001AE   0x2301             MOVS     R3,#+1
   \   000001B0   0x69AA             LDR      R2,[R5, #+24]
   \   000001B2   0xF115 0x012C      ADDS     R1,R5,#+44
   \   000001B6   0x6828             LDR      R0,[R5, #+0]
   \   000001B8   0x7840             LDRB     R0,[R0, #+1]
   \   000001BA   0x.... 0x....      BL       LPLD_Disk_Write
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xD005             BEQ.N    ??f_read_22
   \   000001C2   0x79A8             LDRB     R0,[R5, #+6]
   \   000001C4   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001C8   0x71A8             STRB     R0,[R5, #+6]
   \   000001CA   0x2001             MOVS     R0,#+1
   \   000001CC   0xE015             B.N      ??f_read_1
   \                     ??f_read_22:
   \   000001CE   0x79A8             LDRB     R0,[R5, #+6]
   \   000001D0   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000001D4   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_read_21:
   \   000001D6   0x2301             MOVS     R3,#+1
   \   000001D8   0x464A             MOV      R2,R9
   \   000001DA   0xF115 0x012C      ADDS     R1,R5,#+44
   \   000001DE   0x6828             LDR      R0,[R5, #+0]
   \   000001E0   0x7840             LDRB     R0,[R0, #+1]
   \   000001E2   0x.... 0x....      BL       LPLD_Disk_Read
   \   000001E6   0x2800             CMP      R0,#+0
   \   000001E8   0xF43F 0xAF2C      BEQ.W    ??f_read_5
   \   000001EC   0x79A8             LDRB     R0,[R5, #+6]
   \   000001EE   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001F2   0x71A8             STRB     R0,[R5, #+6]
   \   000001F4   0x2001             MOVS     R0,#+1
   \   000001F6   0xE000             B.N      ??f_read_1
   2465          #endif
   2466          	}
   2467          
   2468          	LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_read_9:
   \   000001F8   0x2000             MOVS     R0,#+0
   \                     ??f_read_1:
   \   000001FA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2469          }
   2470          
   2471          
   2472          
   2473          
   2474          #if !_FS_READONLY
   2475          /*-----------------------------------------------------------------------*/
   2476          /* Write File                                                            */
   2477          /*-----------------------------------------------------------------------*/
   2478          

   \                                 In section .text, align 2, keep-with-next
   2479          FRESULT f_write (
   2480          	FIL *fp,			/* Pointer to the file object */
   2481          	const void *buff,	/* Pointer to the data to be written */
   2482          	UINT btw,			/* Number of bytes to write */
   2483          	UINT *bw			/* Pointer to number of bytes written */
   2484          )
   2485          {
   \                     f_write:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   2486          	FRESULT res;
   2487          	DWORD clst, sect;
   2488          	UINT wcnt, cc;
   2489          	const BYTE *wbuff = buff;
   \   0000000A   0x000C             MOVS     R4,R1
   2490          	BYTE csect;
   2491          
   2492          
   2493          	*bw = 0;	/* Initialize byte counter */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6038             STR      R0,[R7, #+0]
   2494          
   2495          	res = validate(fp->fs, fp->id);			/* Check validity */
   \   00000010   0x88A9             LDRH     R1,[R5, #+4]
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x.... 0x....      BL       validate
   2496          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??f_write_0
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xE078             B.N      ??f_write_1
   2497          	if (fp->flag & FA__ERROR)				/* Aborted file? */
   \                     ??f_write_0:
   \   00000022   0x79A8             LDRB     R0,[R5, #+6]
   \   00000024   0x0600             LSLS     R0,R0,#+24
   \   00000026   0xD501             BPL.N    ??f_write_2
   2498          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE073             B.N      ??f_write_1
   2499          	if (!(fp->flag & FA_WRITE))				/* Check access mode */
   \                     ??f_write_2:
   \   0000002C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000002E   0x0780             LSLS     R0,R0,#+30
   \   00000030   0xD401             BMI.N    ??f_write_3
   2500          		LEAVE_FF(fp->fs, FR_DENIED);
   \   00000032   0x2007             MOVS     R0,#+7
   \   00000034   0xE06E             B.N      ??f_write_1
   2501          	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
   \                     ??f_write_3:
   \   00000036   0x68E8             LDR      R0,[R5, #+12]
   \   00000038   0x1830             ADDS     R0,R6,R0
   \   0000003A   0x68E9             LDR      R1,[R5, #+12]
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD22D             BCS.N    ??f_write_4
   \   00000040   0x2600             MOVS     R6,#+0
   \   00000042   0xE02B             B.N      ??f_write_4
   2502          
   2503          	for ( ;  btw;							/* Repeat until all data written */
   2504          		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   2505          		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
   2506          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2507          			if (!csect) {					/* On the cluster boundary? */
   2508          				if (fp->fptr == 0) {		/* On the top of the file? */
   2509          					clst = fp->sclust;		/* Follow from the origin */
   2510          					if (clst == 0)			/* When no cluster is allocated, */
   2511          						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   2512          				} else {					/* Middle or end of the file */
   2513          #if _USE_FASTSEEK
   2514          					if (fp->cltbl)
   2515          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2516          					else
   2517          #endif
   2518          						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   2519          				}
   2520          				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   2521          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   2522          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2523          				fp->clust = clst;			/* Update current cluster */
   2524          			}
   2525          #if _FS_TINY
   2526          			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
   2527          				ABORT(fp->fs, FR_DISK_ERR);
   2528          #else
   2529          			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
   2530          				if (LPLD_Disk_Write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2531          					ABORT(fp->fs, FR_DISK_ERR);
   2532          				fp->flag &= ~FA__DIRTY;
   2533          			}
   2534          #endif
   2535          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   2536          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2537          			sect += csect;
   2538          			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
   2539          			if (cc) {						/* Write maximum contiguous sectors directly */
   2540          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   2541          					cc = fp->fs->csize - csect;
   2542          				if (LPLD_Disk_Write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
   2543          					ABORT(fp->fs, FR_DISK_ERR);
   2544          #if _FS_TINY
   2545          				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
   2546          					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   2547          					fp->fs->wflag = 0;
   2548          				}
   2549          #else
   2550          				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   2551          					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   2552          					fp->flag &= ~FA__DIRTY;
   2553          				}
   2554          #endif
   2555          				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
   2556          				continue;
   2557          			}
   2558          #if _FS_TINY
   2559          			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
   2560          				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
   2561          				fp->fs->winsect = sect;
   2562          			}
   2563          #else
   2564          			if (fp->dsect != sect) {		/* Fill sector cache with file data */
   2565          				if (fp->fptr < fp->fsize &&
   2566          					LPLD_Disk_Read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
   2567          						ABORT(fp->fs, FR_DISK_ERR);
   2568          			}
   2569          #endif
   2570          			fp->dsect = sect;
   \                     ??f_write_5:
   \   00000044   0xF8C5 0x9018      STR      R9,[R5, #+24]
   2571          		}
   2572          		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   \                     ??f_write_6:
   \   00000048   0x68A8             LDR      R0,[R5, #+8]
   \   0000004A   0xF44F 0x7100      MOV      R1,#+512
   \   0000004E   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000052   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   00000056   0xF5D2 0x7800      RSBS     R8,R2,#+512
   2573          		if (wcnt > btw) wcnt = btw;
   \   0000005A   0x4546             CMP      R6,R8
   \   0000005C   0xD200             BCS.N    ??f_write_7
   \   0000005E   0x46B0             MOV      R8,R6
   2574          #if _FS_TINY
   2575          		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
   2576          			ABORT(fp->fs, FR_DISK_ERR);
   2577          		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   2578          		fp->fs->wflag = 1;
   2579          #else
   2580          		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   \                     ??f_write_7:
   \   00000060   0x4642             MOV      R2,R8
   \   00000062   0x0021             MOVS     R1,R4
   \   00000064   0x68A8             LDR      R0,[R5, #+8]
   \   00000066   0xF44F 0x7300      MOV      R3,#+512
   \   0000006A   0xFBB0 0xFCF3      UDIV     R12,R0,R3
   \   0000006E   0xFB0C 0x0C13      MLS      R12,R12,R3,R0
   \   00000072   0xEB1C 0x0005      ADDS     R0,R12,R5
   \   00000076   0x302C             ADDS     R0,R0,#+44
   \   00000078   0x.... 0x....      BL       mem_cpy
   2581          		fp->flag |= FA__DIRTY;
   \   0000007C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000007E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000082   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_8:
   \   00000084   0xEB18 0x0404      ADDS     R4,R8,R4
   \   00000088   0x68A8             LDR      R0,[R5, #+8]
   \   0000008A   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000008E   0x60A8             STR      R0,[R5, #+8]
   \   00000090   0x6838             LDR      R0,[R7, #+0]
   \   00000092   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000096   0x6038             STR      R0,[R7, #+0]
   \   00000098   0xEBB6 0x0608      SUBS     R6,R6,R8
   \                     ??f_write_4:
   \   0000009C   0x2E00             CMP      R6,#+0
   \   0000009E   0xD02E             BEQ.N    ??f_write_9
   \   000000A0   0x68A8             LDR      R0,[R5, #+8]
   \   000000A2   0xF44F 0x7100      MOV      R1,#+512
   \   000000A6   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000AA   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000AE   0x2A00             CMP      R2,#+0
   \   000000B0   0xD1CA             BNE.N    ??f_write_6
   \   000000B2   0x68A8             LDR      R0,[R5, #+8]
   \   000000B4   0x0A40             LSRS     R0,R0,#+9
   \   000000B6   0x6829             LDR      R1,[R5, #+0]
   \   000000B8   0x7889             LDRB     R1,[R1, #+2]
   \   000000BA   0x1E49             SUBS     R1,R1,#+1
   \   000000BC   0xEA11 0x0800      ANDS     R8,R1,R0
   \   000000C0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C4   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000C8   0xD138             BNE.N    ??f_write_10
   \   000000CA   0x68A8             LDR      R0,[R5, #+8]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD108             BNE.N    ??f_write_11
   \   000000D0   0x6928             LDR      R0,[R5, #+16]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD111             BNE.N    ??f_write_12
   \   000000D6   0x2100             MOVS     R1,#+0
   \   000000D8   0x6828             LDR      R0,[R5, #+0]
   \   000000DA   0x.... 0x....      BL       create_chain
   \   000000DE   0x6128             STR      R0,[R5, #+16]
   \   000000E0   0xE00B             B.N      ??f_write_12
   \                     ??f_write_11:
   \   000000E2   0x6A68             LDR      R0,[R5, #+36]
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD004             BEQ.N    ??f_write_13
   \   000000E8   0x68A9             LDR      R1,[R5, #+8]
   \   000000EA   0x0028             MOVS     R0,R5
   \   000000EC   0x.... 0x....      BL       clmt_clust
   \   000000F0   0xE003             B.N      ??f_write_12
   \                     ??f_write_13:
   \   000000F2   0x6969             LDR      R1,[R5, #+20]
   \   000000F4   0x6828             LDR      R0,[R5, #+0]
   \   000000F6   0x.... 0x....      BL       create_chain
   \                     ??f_write_12:
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD10C             BNE.N    ??f_write_14
   2582          #endif
   2583          	}
   2584          
   2585          	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   \                     ??f_write_9:
   \   000000FE   0x68E8             LDR      R0,[R5, #+12]
   \   00000100   0x68A9             LDR      R1,[R5, #+8]
   \   00000102   0x4288             CMP      R0,R1
   \   00000104   0xD201             BCS.N    ??f_write_15
   \   00000106   0x68A8             LDR      R0,[R5, #+8]
   \   00000108   0x60E8             STR      R0,[R5, #+12]
   2586          	fp->flag |= FA__WRITTEN;						/* Set file change flag */
   \                     ??f_write_15:
   \   0000010A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000010C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000110   0x71A8             STRB     R0,[R5, #+6]
   2587          
   2588          	LEAVE_FF(fp->fs, FR_OK);
   \   00000112   0x2000             MOVS     R0,#+0
   \                     ??f_write_1:
   \   00000114   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??f_write_14:
   \   00000118   0x2801             CMP      R0,#+1
   \   0000011A   0xD105             BNE.N    ??f_write_16
   \   0000011C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000011E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000122   0x71A8             STRB     R0,[R5, #+6]
   \   00000124   0x2002             MOVS     R0,#+2
   \   00000126   0xE7F5             B.N      ??f_write_1
   \                     ??f_write_16:
   \   00000128   0xF110 0x0F01      CMN      R0,#+1
   \   0000012C   0xD105             BNE.N    ??f_write_17
   \   0000012E   0x79A8             LDRB     R0,[R5, #+6]
   \   00000130   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000134   0x71A8             STRB     R0,[R5, #+6]
   \   00000136   0x2001             MOVS     R0,#+1
   \   00000138   0xE7EC             B.N      ??f_write_1
   \                     ??f_write_17:
   \   0000013A   0x6168             STR      R0,[R5, #+20]
   \                     ??f_write_10:
   \   0000013C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000013E   0x0640             LSLS     R0,R0,#+25
   \   00000140   0xD513             BPL.N    ??f_write_18
   \   00000142   0x2301             MOVS     R3,#+1
   \   00000144   0x69AA             LDR      R2,[R5, #+24]
   \   00000146   0xF115 0x012C      ADDS     R1,R5,#+44
   \   0000014A   0x6828             LDR      R0,[R5, #+0]
   \   0000014C   0x7840             LDRB     R0,[R0, #+1]
   \   0000014E   0x.... 0x....      BL       LPLD_Disk_Write
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD005             BEQ.N    ??f_write_19
   \   00000156   0x79A8             LDRB     R0,[R5, #+6]
   \   00000158   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000015C   0x71A8             STRB     R0,[R5, #+6]
   \   0000015E   0x2001             MOVS     R0,#+1
   \   00000160   0xE7D8             B.N      ??f_write_1
   \                     ??f_write_19:
   \   00000162   0x79A8             LDRB     R0,[R5, #+6]
   \   00000164   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000168   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_18:
   \   0000016A   0x6969             LDR      R1,[R5, #+20]
   \   0000016C   0x6828             LDR      R0,[R5, #+0]
   \   0000016E   0x.... 0x....      BL       clust2sect
   \   00000172   0x4681             MOV      R9,R0
   \   00000174   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000178   0xD105             BNE.N    ??f_write_20
   \   0000017A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000017C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000180   0x71A8             STRB     R0,[R5, #+6]
   \   00000182   0x2002             MOVS     R0,#+2
   \   00000184   0xE7C6             B.N      ??f_write_1
   \                     ??f_write_20:
   \   00000186   0xFA59 0xF988      UXTAB    R9,R9,R8
   \   0000018A   0xEA5F 0x2A56      LSRS     R10,R6,#+9
   \   0000018E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000192   0xD036             BEQ.N    ??f_write_21
   \   00000194   0x6828             LDR      R0,[R5, #+0]
   \   00000196   0x7880             LDRB     R0,[R0, #+2]
   \   00000198   0xFA5A 0xF188      UXTAB    R1,R10,R8
   \   0000019C   0x4288             CMP      R0,R1
   \   0000019E   0xD205             BCS.N    ??f_write_22
   \   000001A0   0x6828             LDR      R0,[R5, #+0]
   \   000001A2   0x7880             LDRB     R0,[R0, #+2]
   \   000001A4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001A8   0xEBB0 0x0A08      SUBS     R10,R0,R8
   \                     ??f_write_22:
   \   000001AC   0x4653             MOV      R3,R10
   \   000001AE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001B0   0x464A             MOV      R2,R9
   \   000001B2   0x0021             MOVS     R1,R4
   \   000001B4   0x6828             LDR      R0,[R5, #+0]
   \   000001B6   0x7840             LDRB     R0,[R0, #+1]
   \   000001B8   0x.... 0x....      BL       LPLD_Disk_Write
   \   000001BC   0x2800             CMP      R0,#+0
   \   000001BE   0xD005             BEQ.N    ??f_write_23
   \   000001C0   0x79A8             LDRB     R0,[R5, #+6]
   \   000001C2   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001C6   0x71A8             STRB     R0,[R5, #+6]
   \   000001C8   0x2001             MOVS     R0,#+1
   \   000001CA   0xE7A3             B.N      ??f_write_1
   \                     ??f_write_23:
   \   000001CC   0x69A8             LDR      R0,[R5, #+24]
   \   000001CE   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   000001D2   0x4550             CMP      R0,R10
   \   000001D4   0xD210             BCS.N    ??f_write_24
   \   000001D6   0xF44F 0x7200      MOV      R2,#+512
   \   000001DA   0x69A8             LDR      R0,[R5, #+24]
   \   000001DC   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   000001E0   0xF44F 0x7100      MOV      R1,#+512
   \   000001E4   0xFB01 0x4100      MLA      R1,R1,R0,R4
   \   000001E8   0xF115 0x002C      ADDS     R0,R5,#+44
   \   000001EC   0x.... 0x....      BL       mem_cpy
   \   000001F0   0x79A8             LDRB     R0,[R5, #+6]
   \   000001F2   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000001F6   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_24:
   \   000001F8   0xF44F 0x7000      MOV      R0,#+512
   \   000001FC   0xFB00 0xF80A      MUL      R8,R0,R10
   \   00000200   0xE740             B.N      ??f_write_8
   \                     ??f_write_21:
   \   00000202   0x69A8             LDR      R0,[R5, #+24]
   \   00000204   0x4548             CMP      R0,R9
   \   00000206   0xF43F 0xAF1D      BEQ.W    ??f_write_5
   \   0000020A   0x68A8             LDR      R0,[R5, #+8]
   \   0000020C   0x68E9             LDR      R1,[R5, #+12]
   \   0000020E   0x4288             CMP      R0,R1
   \   00000210   0xF4BF 0xAF18      BCS.W    ??f_write_5
   \   00000214   0x2301             MOVS     R3,#+1
   \   00000216   0x464A             MOV      R2,R9
   \   00000218   0xF115 0x012C      ADDS     R1,R5,#+44
   \   0000021C   0x6828             LDR      R0,[R5, #+0]
   \   0000021E   0x7840             LDRB     R0,[R0, #+1]
   \   00000220   0x.... 0x....      BL       LPLD_Disk_Read
   \   00000224   0x2800             CMP      R0,#+0
   \   00000226   0xF43F 0xAF0D      BEQ.W    ??f_write_5
   \   0000022A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000022C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000230   0x71A8             STRB     R0,[R5, #+6]
   \   00000232   0x2001             MOVS     R0,#+1
   \   00000234   0xE76E             B.N      ??f_write_1
   2589          }
   2590          
   2591          
   2592          
   2593          
   2594          /*-----------------------------------------------------------------------*/
   2595          /* Synchronize the File Object                                           */
   2596          /*-----------------------------------------------------------------------*/
   2597          

   \                                 In section .text, align 2, keep-with-next
   2598          FRESULT f_sync (
   2599          	FIL *fp		/* Pointer to the file object */
   2600          )
   2601          {
   \                     f_sync:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2602          	FRESULT res;
   2603          	DWORD tim;
   2604          	BYTE *dir;
   2605          
   2606          
   2607          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   \   00000004   0x88A1             LDRH     R1,[R4, #+4]
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       validate
   2608          	if (res == FR_OK) {
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD150             BNE.N    ??f_sync_0
   2609          		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
   \   00000012   0x79A1             LDRB     R1,[R4, #+6]
   \   00000014   0x0689             LSLS     R1,R1,#+26
   \   00000016   0xD54D             BPL.N    ??f_sync_0
   2610          #if !_FS_TINY	/* Write-back dirty buffer */
   2611          			if (fp->flag & FA__DIRTY) {
   \   00000018   0x79A0             LDRB     R0,[R4, #+6]
   \   0000001A   0x0640             LSLS     R0,R0,#+25
   \   0000001C   0xD50F             BPL.N    ??f_sync_1
   2612          				if (LPLD_Disk_Write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   0000001E   0x2301             MOVS     R3,#+1
   \   00000020   0x69A2             LDR      R2,[R4, #+24]
   \   00000022   0xF114 0x012C      ADDS     R1,R4,#+44
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x7840             LDRB     R0,[R0, #+1]
   \   0000002A   0x.... 0x....      BL       LPLD_Disk_Write
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??f_sync_2
   2613          					LEAVE_FF(fp->fs, FR_DISK_ERR);
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE03F             B.N      ??f_sync_3
   2614          				fp->flag &= ~FA__DIRTY;
   \                     ??f_sync_2:
   \   00000036   0x79A0             LDRB     R0,[R4, #+6]
   \   00000038   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000003C   0x71A0             STRB     R0,[R4, #+6]
   2615          			}
   2616          #endif
   2617          			/* Update the directory entry */
   2618          			res = move_window(fp->fs, fp->dir_sect);
   \                     ??f_sync_1:
   \   0000003E   0x69E1             LDR      R1,[R4, #+28]
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      BL       move_window
   2619          			if (res == FR_OK) {
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD133             BNE.N    ??f_sync_0
   2620          				dir = fp->dir_ptr;
   \   0000004C   0x6A25             LDR      R5,[R4, #+32]
   2621          				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   \   0000004E   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000050   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000054   0x72E8             STRB     R0,[R5, #+11]
   2622          				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
   \   00000056   0x68E0             LDR      R0,[R4, #+12]
   \   00000058   0x7728             STRB     R0,[R5, #+28]
   \   0000005A   0x68E0             LDR      R0,[R4, #+12]
   \   0000005C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005E   0x0A00             LSRS     R0,R0,#+8
   \   00000060   0x7768             STRB     R0,[R5, #+29]
   \   00000062   0x68E0             LDR      R0,[R4, #+12]
   \   00000064   0x0C00             LSRS     R0,R0,#+16
   \   00000066   0x77A8             STRB     R0,[R5, #+30]
   \   00000068   0x68E0             LDR      R0,[R4, #+12]
   \   0000006A   0x0E00             LSRS     R0,R0,#+24
   \   0000006C   0x77E8             STRB     R0,[R5, #+31]
   2623          				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
   \   0000006E   0x6920             LDR      R0,[R4, #+16]
   \   00000070   0x76A8             STRB     R0,[R5, #+26]
   \   00000072   0x6920             LDR      R0,[R4, #+16]
   \   00000074   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000076   0x0A00             LSRS     R0,R0,#+8
   \   00000078   0x76E8             STRB     R0,[R5, #+27]
   \   0000007A   0x6920             LDR      R0,[R4, #+16]
   \   0000007C   0x0C00             LSRS     R0,R0,#+16
   \   0000007E   0x7528             STRB     R0,[R5, #+20]
   \   00000080   0x6920             LDR      R0,[R4, #+16]
   \   00000082   0x0C00             LSRS     R0,R0,#+16
   \   00000084   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000086   0x0A00             LSRS     R0,R0,#+8
   \   00000088   0x7568             STRB     R0,[R5, #+21]
   2624          				tim = get_fattime();						/* Update updated time */
   \   0000008A   0x.... 0x....      BL       get_fattime
   2625          				ST_DWORD(dir+DIR_WrtTime, tim);
   \   0000008E   0x75A8             STRB     R0,[R5, #+22]
   \   00000090   0x0001             MOVS     R1,R0
   \   00000092   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000094   0x0A09             LSRS     R1,R1,#+8
   \   00000096   0x75E9             STRB     R1,[R5, #+23]
   \   00000098   0x0C01             LSRS     R1,R0,#+16
   \   0000009A   0x7629             STRB     R1,[R5, #+24]
   \   0000009C   0x0E00             LSRS     R0,R0,#+24
   \   0000009E   0x7668             STRB     R0,[R5, #+25]
   2626          				fp->flag &= ~FA__WRITTEN;
   \   000000A0   0x79A0             LDRB     R0,[R4, #+6]
   \   000000A2   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   000000A6   0x71A0             STRB     R0,[R4, #+6]
   2627          				fp->fs->wflag = 1;
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x2101             MOVS     R1,#+1
   \   000000AC   0x7101             STRB     R1,[R0, #+4]
   2628          				res = sync(fp->fs);
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x.... 0x....      BL       sync
   2629          			}
   2630          		}
   2631          	}
   2632          
   2633          	LEAVE_FF(fp->fs, res);
   \                     ??f_sync_0:
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_sync_3:
   \   000000B6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2634          }
   2635          
   2636          #endif /* !_FS_READONLY */
   2637          
   2638          
   2639          
   2640          
   2641          /*-----------------------------------------------------------------------*/
   2642          /* Close File                                                            */
   2643          /*-----------------------------------------------------------------------*/
   2644          

   \                                 In section .text, align 2, keep-with-next
   2645          FRESULT f_close (
   2646          	FIL *fp		/* Pointer to the file object to be closed */
   2647          )
   2648          {
   \                     f_close:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2649          	FRESULT res;
   2650          
   2651          #if _FS_READONLY
   2652          	FATFS *fs = fp->fs;
   2653          	res = validate(fs, fp->id);
   2654          	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   2655          	LEAVE_FF(fs, res);
   2656          
   2657          #else
   2658          	res = f_sync(fp);		/* Flush cached data */
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       f_sync
   2659          #if _FS_SHARE
   2660          	if (res == FR_OK) {		/* Decrement open counter */
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD102             BNE.N    ??f_close_0
   2661          #if _FS_REENTRANT
   2662          		res = validate(fp->fs, fp->id);
   2663          		if (res == FR_OK) {
   2664          			res = dec_lock(fp->lockid);	
   2665          			unlock_fs(fp->fs, FR_OK);
   2666          		}
   2667          #else
   2668          		res = dec_lock(fp->lockid);
   \   00000010   0x6AA0             LDR      R0,[R4, #+40]
   \   00000012   0x.... 0x....      BL       dec_lock
   2669          #endif
   2670          	}
   2671          #endif
   2672          	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   \                     ??f_close_0:
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE.N    ??f_close_1
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6021             STR      R1,[R4, #+0]
   2673          	return res;
   \                     ??f_close_1:
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   2674          #endif
   2675          }
   2676          
   2677          
   2678          
   2679          
   2680          /*-----------------------------------------------------------------------*/
   2681          /* Current Drive/Directory Handlings                                     */
   2682          /*-----------------------------------------------------------------------*/
   2683          
   2684          #if _FS_RPATH >= 1
   2685          

   \                                 In section .text, align 2, keep-with-next
   2686          FRESULT f_chdrive (
   2687          	BYTE drv		/* Drive number */
   2688          )
   2689          {
   2690          	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   \                     f_chdrive:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD301             BCC.N    ??f_chdrive_0
   \   00000006   0x200B             MOVS     R0,#+11
   \   00000008   0xE002             B.N      ??f_chdrive_1
   2691          
   2692          	CurrVol = drv;
   \                     ??f_chdrive_0:
   \   0000000A   0x....             LDR.N    R1,??DataTable13_1
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
   2693          
   2694          	return FR_OK;
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??f_chdrive_1:
   \   00000010   0x4770             BX       LR               ;; return
   2695          }
   2696          
   2697          
   2698          

   \                                 In section .text, align 2, keep-with-next
   2699          FRESULT f_chdir (
   2700          	const TCHAR *path	/* Pointer to the directory path */
   2701          )
   2702          {
   \                     f_chdir:
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   2703          	FRESULT res;
   2704          	DIR dj;
   2705          	DEF_NAMEBUF;
   2706          
   2707          
   2708          	res = chk_mounted(&path, &dj.fs, 0);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0xA80C             ADD      R0,SP,#+48
   \   0000000A   0x.... 0x....      BL       chk_mounted
   \   0000000E   0x0004             MOVS     R4,R0
   2709          	if (res == FR_OK) {
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD138             BNE.N    ??f_chdir_0
   2710          		INIT_BUF(dj);
   \   00000016   0x2082             MOVS     R0,#+130
   \   00000018   0x.... 0x....      BL       ff_memalloc
   \   0000001C   0x0005             MOVS     R5,R0
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD101             BNE.N    ??f_chdir_1
   \   00000022   0x2011             MOVS     R0,#+17
   \   00000024   0xE032             B.N      ??f_chdir_2
   \                     ??f_chdir_1:
   \   00000026   0x9507             STR      R5,[SP, #+28]
   \   00000028   0xA809             ADD      R0,SP,#+36
   \   0000002A   0x9006             STR      R0,[SP, #+24]
   2711          		res = follow_path(&dj, path);		/* Follow the path */
   \   0000002C   0x990C             LDR      R1,[SP, #+48]
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       follow_path
   \   00000034   0x0004             MOVS     R4,R0
   2712          		FREE_BUF();
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x.... 0x....      BL       ff_memfree
   2713          		if (res == FR_OK) {					/* Follow completed */
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD11E             BNE.N    ??f_chdir_3
   2714          			if (!dj.dir) {
   \   00000042   0x9805             LDR      R0,[SP, #+20]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD103             BNE.N    ??f_chdir_4
   2715          				dj.fs->cdir = dj.sclust;	/* Start directory itself */
   \   00000048   0x9800             LDR      R0,[SP, #+0]
   \   0000004A   0x9902             LDR      R1,[SP, #+8]
   \   0000004C   0x6181             STR      R1,[R0, #+24]
   \   0000004E   0xE017             B.N      ??f_chdir_3
   2716          			} else {
   2717          				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
   \                     ??f_chdir_4:
   \   00000050   0x9805             LDR      R0,[SP, #+20]
   \   00000052   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000054   0x06C0             LSLS     R0,R0,#+27
   \   00000056   0xD512             BPL.N    ??f_chdir_5
   2718          					dj.fs->cdir = LD_CLUST(dj.dir);
   \   00000058   0x9805             LDR      R0,[SP, #+20]
   \   0000005A   0x7D40             LDRB     R0,[R0, #+21]
   \   0000005C   0x9905             LDR      R1,[SP, #+20]
   \   0000005E   0x7D09             LDRB     R1,[R1, #+20]
   \   00000060   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000064   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000066   0x9905             LDR      R1,[SP, #+20]
   \   00000068   0x7EC9             LDRB     R1,[R1, #+27]
   \   0000006A   0x9A05             LDR      R2,[SP, #+20]
   \   0000006C   0x7E92             LDRB     R2,[R2, #+26]
   \   0000006E   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000072   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000074   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000078   0x9900             LDR      R1,[SP, #+0]
   \   0000007A   0x6188             STR      R0,[R1, #+24]
   \   0000007C   0xE000             B.N      ??f_chdir_3
   2719          				else
   2720          					res = FR_NO_PATH;		/* Reached but a file */
   \                     ??f_chdir_5:
   \   0000007E   0x2405             MOVS     R4,#+5
   2721          			}
   2722          		}
   2723          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_chdir_3:
   \   00000080   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000082   0x2C04             CMP      R4,#+4
   \   00000084   0xD100             BNE.N    ??f_chdir_0
   \   00000086   0x2405             MOVS     R4,#+5
   2724          	}
   2725          
   2726          	LEAVE_FF(dj.fs, res);
   \                     ??f_chdir_0:
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_chdir_2:
   \   0000008C   0xB00D             ADD      SP,SP,#+52
   \   0000008E   0xBD30             POP      {R4,R5,PC}       ;; return
   2727          }
   2728          
   2729          
   2730          #if _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   2731          FRESULT f_getcwd (
   2732          	TCHAR *path,	/* Pointer to the directory path */
   2733          	UINT sz_path	/* Size of path */
   2734          )
   2735          {
   \                     f_getcwd:
   \   00000000   0xE92D 0x41F1      PUSH     {R0,R4-R8,LR}
   \   00000004   0xB095             SUB      SP,SP,#+84
   \   00000006   0x000C             MOVS     R4,R1
   2736          	FRESULT res;
   2737          	DIR dj;
   2738          	UINT i, n;
   2739          	DWORD ccl;
   2740          	TCHAR *tp;
   2741          	FILINFO fno;
   2742          	DEF_NAMEBUF;
   2743          
   2744          
   2745          	*path = 0;
   \   00000008   0x9815             LDR      R0,[SP, #+84]
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
   2746          	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0xA815             ADD      R0,SP,#+84
   \   00000014   0x.... 0x....      BL       chk_mounted
   \   00000018   0x0006             MOVS     R6,R0
   2747          	if (res == FR_OK) {
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xF040 0x80A6      BNE.W    ??f_getcwd_0
   2748          		INIT_BUF(dj);
   \   00000022   0x2082             MOVS     R0,#+130
   \   00000024   0x.... 0x....      BL       ff_memalloc
   \   00000028   0x0005             MOVS     R5,R0
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD101             BNE.N    ??f_getcwd_1
   \   0000002E   0x2011             MOVS     R0,#+17
   \   00000030   0xE09F             B.N      ??f_getcwd_2
   \                     ??f_getcwd_1:
   \   00000032   0x9507             STR      R5,[SP, #+28]
   \   00000034   0xA809             ADD      R0,SP,#+36
   \   00000036   0x9006             STR      R0,[SP, #+24]
   2749          		i = sz_path;		/* Bottom of buffer (dir stack base) */
   \   00000038   0x0027             MOVS     R7,R4
   2750          		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x6980             LDR      R0,[R0, #+24]
   \   0000003E   0x9002             STR      R0,[SP, #+8]
   \   00000040   0xE00A             B.N      ??f_getcwd_3
   2751          		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
   2752          			res = dir_sdi(&dj, 1);			/* Get parent dir */
   2753          			if (res != FR_OK) break;
   2754          			res = dir_read(&dj);
   2755          			if (res != FR_OK) break;
   2756          			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
   2757          			res = dir_sdi(&dj, 0);
   2758          			if (res != FR_OK) break;
   2759          			do {							/* Find the entry links to the child dir */
   2760          				res = dir_read(&dj);
   2761          				if (res != FR_OK) break;
   2762          				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
   2763          				res = dir_next(&dj, 0);	
   2764          			} while (res == FR_OK);
   2765          			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
   2766          			if (res != FR_OK) break;
   2767          #if _USE_LFN
   2768          			fno.lfname = path;
   2769          			fno.lfsize = i;
   2770          #endif
   2771          			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
   2772          			tp = fno.fname;
   2773          			if (_USE_LFN && *path) tp = path;
   2774          			for (n = 0; tp[n]; n++) ;
   2775          			if (i < n + 3) {
   2776          				res = FR_NOT_ENOUGH_CORE; break;
   2777          			}
   2778          			while (n) path[--i] = tp[--n];
   \                     ??f_getcwd_4:
   \   00000042   0x1E7F             SUBS     R7,R7,#+1
   \   00000044   0x1E49             SUBS     R1,R1,#+1
   \   00000046   0x9A15             LDR      R2,[SP, #+84]
   \   00000048   0x5C0B             LDRB     R3,[R1, R0]
   \   0000004A   0x54BB             STRB     R3,[R7, R2]
   \                     ??f_getcwd_5:
   \   0000004C   0x2900             CMP      R1,#+0
   \   0000004E   0xD1F8             BNE.N    ??f_getcwd_4
   2779          			path[--i] = '/';
   \   00000050   0x1E7F             SUBS     R7,R7,#+1
   \   00000052   0x9815             LDR      R0,[SP, #+84]
   \   00000054   0x212F             MOVS     R1,#+47
   \   00000056   0x5439             STRB     R1,[R7, R0]
   \                     ??f_getcwd_3:
   \   00000058   0xF8DD 0x8008      LDR      R8,[SP, #+8]
   \   0000005C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000060   0xD067             BEQ.N    ??f_getcwd_6
   \   00000062   0x2101             MOVS     R1,#+1
   \   00000064   0xA800             ADD      R0,SP,#+0
   \   00000066   0x.... 0x....      BL       dir_sdi
   \   0000006A   0x0006             MOVS     R6,R0
   \   0000006C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006E   0x2E00             CMP      R6,#+0
   \   00000070   0xD15F             BNE.N    ??f_getcwd_6
   \                     ??f_getcwd_7:
   \   00000072   0xA800             ADD      R0,SP,#+0
   \   00000074   0x.... 0x....      BL       dir_read
   \   00000078   0x0006             MOVS     R6,R0
   \   0000007A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD158             BNE.N    ??f_getcwd_6
   \                     ??f_getcwd_8:
   \   00000080   0x9805             LDR      R0,[SP, #+20]
   \   00000082   0x7D40             LDRB     R0,[R0, #+21]
   \   00000084   0x9905             LDR      R1,[SP, #+20]
   \   00000086   0x7D09             LDRB     R1,[R1, #+20]
   \   00000088   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000008C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000008E   0x9905             LDR      R1,[SP, #+20]
   \   00000090   0x7EC9             LDRB     R1,[R1, #+27]
   \   00000092   0x9A05             LDR      R2,[SP, #+20]
   \   00000094   0x7E92             LDRB     R2,[R2, #+26]
   \   00000096   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   0000009A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000009C   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   000000A0   0x9002             STR      R0,[SP, #+8]
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0xA800             ADD      R0,SP,#+0
   \   000000A6   0x.... 0x....      BL       dir_sdi
   \   000000AA   0x0006             MOVS     R6,R0
   \   000000AC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AE   0x2E00             CMP      R6,#+0
   \   000000B0   0xD13F             BNE.N    ??f_getcwd_6
   \                     ??f_getcwd_9:
   \   000000B2   0xA800             ADD      R0,SP,#+0
   \   000000B4   0x.... 0x....      BL       dir_read
   \   000000B8   0x0006             MOVS     R6,R0
   \   000000BA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BC   0x2E00             CMP      R6,#+0
   \   000000BE   0xD119             BNE.N    ??f_getcwd_10
   \                     ??f_getcwd_11:
   \   000000C0   0x9805             LDR      R0,[SP, #+20]
   \   000000C2   0x7D40             LDRB     R0,[R0, #+21]
   \   000000C4   0x9905             LDR      R1,[SP, #+20]
   \   000000C6   0x7D09             LDRB     R1,[R1, #+20]
   \   000000C8   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000CC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000CE   0x9905             LDR      R1,[SP, #+20]
   \   000000D0   0x7EC9             LDRB     R1,[R1, #+27]
   \   000000D2   0x9A05             LDR      R2,[SP, #+20]
   \   000000D4   0x7E92             LDRB     R2,[R2, #+26]
   \   000000D6   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   000000DA   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000DC   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   000000E0   0x4580             CMP      R8,R0
   \   000000E2   0xD007             BEQ.N    ??f_getcwd_10
   \                     ??f_getcwd_12:
   \   000000E4   0x2100             MOVS     R1,#+0
   \   000000E6   0xA800             ADD      R0,SP,#+0
   \   000000E8   0x.... 0x....      BL       dir_next
   \   000000EC   0x0006             MOVS     R6,R0
   \   000000EE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000F0   0x2E00             CMP      R6,#+0
   \   000000F2   0xD0DE             BEQ.N    ??f_getcwd_9
   \                     ??f_getcwd_10:
   \   000000F4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000F6   0x2E04             CMP      R6,#+4
   \   000000F8   0xD100             BNE.N    ??f_getcwd_13
   \   000000FA   0x2602             MOVS     R6,#+2
   \                     ??f_getcwd_13:
   \   000000FC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000FE   0x2E00             CMP      R6,#+0
   \   00000100   0xD117             BNE.N    ??f_getcwd_6
   \                     ??f_getcwd_14:
   \   00000102   0x9815             LDR      R0,[SP, #+84]
   \   00000104   0x9012             STR      R0,[SP, #+72]
   \   00000106   0x9713             STR      R7,[SP, #+76]
   \   00000108   0xA90C             ADD      R1,SP,#+48
   \   0000010A   0xA800             ADD      R0,SP,#+0
   \   0000010C   0x.... 0x....      BL       get_fileinfo
   \   00000110   0xF10D 0x0039      ADD      R0,SP,#+57
   \   00000114   0x9915             LDR      R1,[SP, #+84]
   \   00000116   0x7809             LDRB     R1,[R1, #+0]
   \   00000118   0x2900             CMP      R1,#+0
   \   0000011A   0xD000             BEQ.N    ??f_getcwd_15
   \   0000011C   0x9815             LDR      R0,[SP, #+84]
   \                     ??f_getcwd_15:
   \   0000011E   0x2100             MOVS     R1,#+0
   \   00000120   0xE000             B.N      ??f_getcwd_16
   \                     ??f_getcwd_17:
   \   00000122   0x1C49             ADDS     R1,R1,#+1
   \                     ??f_getcwd_16:
   \   00000124   0x5C0A             LDRB     R2,[R1, R0]
   \   00000126   0x2A00             CMP      R2,#+0
   \   00000128   0xD1FB             BNE.N    ??f_getcwd_17
   \   0000012A   0x1CCA             ADDS     R2,R1,#+3
   \   0000012C   0x4297             CMP      R7,R2
   \   0000012E   0xD28D             BCS.N    ??f_getcwd_5
   \   00000130   0x2611             MOVS     R6,#+17
   2780          		}
   2781          		tp = path;
   \                     ??f_getcwd_6:
   \   00000132   0x9815             LDR      R0,[SP, #+84]
   2782          		if (res == FR_OK) {
   \   00000134   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000136   0x2E00             CMP      R6,#+0
   \   00000138   0xD114             BNE.N    ??f_getcwd_18
   2783          			*tp++ = '0' + CurrVol;			/* Put drive number */
   \   0000013A   0x....             LDR.N    R1,??DataTable13_1
   \   0000013C   0x7809             LDRB     R1,[R1, #+0]
   \   0000013E   0x3130             ADDS     R1,R1,#+48
   \   00000140   0x7001             STRB     R1,[R0, #+0]
   \   00000142   0x1C40             ADDS     R0,R0,#+1
   2784          			*tp++ = ':';
   \   00000144   0x213A             MOVS     R1,#+58
   \   00000146   0x7001             STRB     R1,[R0, #+0]
   \   00000148   0x1C40             ADDS     R0,R0,#+1
   2785          			if (i == sz_path) {				/* Root-dir */
   \   0000014A   0x42A7             CMP      R7,R4
   \   0000014C   0xD103             BNE.N    ??f_getcwd_19
   2786          				*tp++ = '/';
   \   0000014E   0x212F             MOVS     R1,#+47
   \   00000150   0x7001             STRB     R1,[R0, #+0]
   \   00000152   0x1C40             ADDS     R0,R0,#+1
   \   00000154   0xE006             B.N      ??f_getcwd_18
   2787          			} else {						/* Sub-dir */
   2788          				do		/* Add stacked path str */
   2789          					*tp++ = path[i++];
   \                     ??f_getcwd_19:
   \   00000156   0x9915             LDR      R1,[SP, #+84]
   \   00000158   0x5C79             LDRB     R1,[R7, R1]
   \   0000015A   0x7001             STRB     R1,[R0, #+0]
   \   0000015C   0x1C7F             ADDS     R7,R7,#+1
   \   0000015E   0x1C40             ADDS     R0,R0,#+1
   2790          				while (i < sz_path);
   \   00000160   0x42A7             CMP      R7,R4
   \   00000162   0xD3F8             BCC.N    ??f_getcwd_19
   2791          			}
   2792          		}
   2793          		*tp = 0;
   \                     ??f_getcwd_18:
   \   00000164   0x2100             MOVS     R1,#+0
   \   00000166   0x7001             STRB     R1,[R0, #+0]
   2794          		FREE_BUF();
   \   00000168   0x0028             MOVS     R0,R5
   \   0000016A   0x.... 0x....      BL       ff_memfree
   2795          	}
   2796          
   2797          	LEAVE_FF(dj.fs, res);
   \                     ??f_getcwd_0:
   \   0000016E   0x0030             MOVS     R0,R6
   \   00000170   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_getcwd_2:
   \   00000172   0xB016             ADD      SP,SP,#+88
   \   00000174   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2798          }
   2799          #endif /* _FS_RPATH >= 2 */
   2800          #endif /* _FS_RPATH >= 1 */
   2801          
   2802          
   2803          
   2804          #if _FS_MINIMIZE <= 2
   2805          /*-----------------------------------------------------------------------*/
   2806          /* Seek File R/W Pointer                                                 */
   2807          /*-----------------------------------------------------------------------*/
   2808          

   \                                 In section .text, align 2, keep-with-next
   2809          FRESULT f_lseek (
   2810          	FIL *fp,		/* Pointer to the file object */
   2811          	DWORD ofs		/* File pointer from top of file */
   2812          )
   2813          {
   \                     f_lseek:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   2814          	FRESULT res;
   2815          
   2816          
   2817          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   \   00000008   0x88A9             LDRH     R1,[R5, #+4]
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x.... 0x....      BL       validate
   \   00000010   0x0004             MOVS     R4,R0
   2818          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD002             BEQ.N    ??f_lseek_0
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xE16E             B.N      ??f_lseek_1
   2819          	if (fp->flag & FA__ERROR)			/* Check abort flag */
   \                     ??f_lseek_0:
   \   0000001E   0x79A8             LDRB     R0,[R5, #+6]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD501             BPL.N    ??f_lseek_2
   2820          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE169             B.N      ??f_lseek_1
   2821          
   2822          #if _USE_FASTSEEK
   2823          	if (fp->cltbl) {	/* Fast seek */
   \                     ??f_lseek_2:
   \   00000028   0x6A68             LDR      R0,[R5, #+36]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xF000 0x809E      BEQ.W    ??f_lseek_3
   2824          		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
   2825          
   2826          		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
   \   00000030   0xF116 0x0F01      CMN      R6,#+1
   \   00000034   0xD142             BNE.N    ??f_lseek_4
   2827          			tbl = fp->cltbl;
   \   00000036   0xF8D5 0xA024      LDR      R10,[R5, #+36]
   2828          			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
   \   0000003A   0xF8DA 0x8000      LDR      R8,[R10, #+0]
   \   0000003E   0xF11A 0x0A04      ADDS     R10,R10,#+4
   \   00000042   0xF05F 0x0902      MOVS     R9,#+2
   2829          			cl = fp->sclust;			/* Top of the chain */
   \   00000046   0x6928             LDR      R0,[R5, #+16]
   2830          			if (cl) {
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD02C             BEQ.N    ??f_lseek_5
   2831          				do {
   2832          					/* Get a fragment */
   2833          					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
   \                     ??f_lseek_6:
   \   0000004C   0x0007             MOVS     R7,R0
   \   0000004E   0x2600             MOVS     R6,#+0
   \   00000050   0xF119 0x0902      ADDS     R9,R9,#+2
   2834          					do {
   2835          						pcl = cl; ncl++;
   \                     ??f_lseek_7:
   \   00000054   0x4683             MOV      R11,R0
   \   00000056   0x1C76             ADDS     R6,R6,#+1
   2836          						cl = get_fat(fp->fs, cl);
   \   00000058   0x0001             MOVS     R1,R0
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0x.... 0x....      BL       get_fat
   2837          						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
   \   00000060   0x2802             CMP      R0,#+2
   \   00000062   0xD205             BCS.N    ??f_lseek_8
   \   00000064   0x79A8             LDRB     R0,[R5, #+6]
   \   00000066   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000006A   0x71A8             STRB     R0,[R5, #+6]
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0xE145             B.N      ??f_lseek_1
   2838          						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_8:
   \   00000070   0xF110 0x0F01      CMN      R0,#+1
   \   00000074   0xD105             BNE.N    ??f_lseek_9
   \   00000076   0x79A8             LDRB     R0,[R5, #+6]
   \   00000078   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000007C   0x71A8             STRB     R0,[R5, #+6]
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xE13C             B.N      ??f_lseek_1
   2839          					} while (cl == pcl + 1);
   \                     ??f_lseek_9:
   \   00000082   0xF11B 0x0101      ADDS     R1,R11,#+1
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD0E4             BEQ.N    ??f_lseek_7
   2840          					if (ulen <= tlen) {		/* Store the length and top of the fragment */
   \   0000008A   0x45C8             CMP      R8,R9
   \   0000008C   0xD307             BCC.N    ??f_lseek_10
   2841          						*tbl++ = ncl; *tbl++ = tcl;
   \   0000008E   0xF8CA 0x6000      STR      R6,[R10, #+0]
   \   00000092   0xF11A 0x0A04      ADDS     R10,R10,#+4
   \   00000096   0xF8CA 0x7000      STR      R7,[R10, #+0]
   \   0000009A   0xF11A 0x0A04      ADDS     R10,R10,#+4
   2842          					}
   2843          				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
   \                     ??f_lseek_10:
   \   0000009E   0x6829             LDR      R1,[R5, #+0]
   \   000000A0   0x69C9             LDR      R1,[R1, #+28]
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xD3D2             BCC.N    ??f_lseek_6
   2844          			}
   2845          			*fp->cltbl = ulen;	/* Number of items used */
   \                     ??f_lseek_5:
   \   000000A6   0x6A68             LDR      R0,[R5, #+36]
   \   000000A8   0xF8C0 0x9000      STR      R9,[R0, #+0]
   2846          			if (ulen <= tlen)
   \   000000AC   0x45C8             CMP      R8,R9
   \   000000AE   0xD303             BCC.N    ??f_lseek_11
   2847          				*tbl = 0;		/* Terminate table */
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   000000B6   0xE11F             B.N      ??f_lseek_12
   2848          			else
   2849          				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
   \                     ??f_lseek_11:
   \   000000B8   0x2411             MOVS     R4,#+17
   \   000000BA   0xE11D             B.N      ??f_lseek_12
   2850          
   2851          		} else {						/* Fast seek */
   2852          			if (ofs > fp->fsize)		/* Clip offset at the file size */
   \                     ??f_lseek_4:
   \   000000BC   0x68E8             LDR      R0,[R5, #+12]
   \   000000BE   0x42B0             CMP      R0,R6
   \   000000C0   0xD200             BCS.N    ??f_lseek_13
   2853          				ofs = fp->fsize;
   \   000000C2   0x68EE             LDR      R6,[R5, #+12]
   2854          			fp->fptr = ofs;				/* Set file pointer */
   \                     ??f_lseek_13:
   \   000000C4   0x60AE             STR      R6,[R5, #+8]
   2855          			if (ofs) {
   \   000000C6   0x2E00             CMP      R6,#+0
   \   000000C8   0xF000 0x8116      BEQ.W    ??f_lseek_12
   2856          				fp->clust = clmt_clust(fp, ofs - 1);
   \   000000CC   0x1E71             SUBS     R1,R6,#+1
   \   000000CE   0x0028             MOVS     R0,R5
   \   000000D0   0x.... 0x....      BL       clmt_clust
   \   000000D4   0x6168             STR      R0,[R5, #+20]
   2857          				dsc = clust2sect(fp->fs, fp->clust);
   \   000000D6   0x6969             LDR      R1,[R5, #+20]
   \   000000D8   0x6828             LDR      R0,[R5, #+0]
   \   000000DA   0x.... 0x....      BL       clust2sect
   \   000000DE   0x0007             MOVS     R7,R0
   2858          				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
   \   000000E0   0x2F00             CMP      R7,#+0
   \   000000E2   0xD105             BNE.N    ??f_lseek_14
   \   000000E4   0x79A8             LDRB     R0,[R5, #+6]
   \   000000E6   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000EA   0x71A8             STRB     R0,[R5, #+6]
   \   000000EC   0x2002             MOVS     R0,#+2
   \   000000EE   0xE105             B.N      ??f_lseek_1
   2859          				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
   \                     ??f_lseek_14:
   \   000000F0   0x1E70             SUBS     R0,R6,#+1
   \   000000F2   0x6829             LDR      R1,[R5, #+0]
   \   000000F4   0x7889             LDRB     R1,[R1, #+2]
   \   000000F6   0x1E49             SUBS     R1,R1,#+1
   \   000000F8   0xEA11 0x2050      ANDS     R0,R1,R0, LSR #+9
   \   000000FC   0x19C7             ADDS     R7,R0,R7
   2860          				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
   \   000000FE   0x68A8             LDR      R0,[R5, #+8]
   \   00000100   0xF44F 0x7100      MOV      R1,#+512
   \   00000104   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000108   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   0000010C   0x2A00             CMP      R2,#+0
   \   0000010E   0xF000 0x80F3      BEQ.W    ??f_lseek_12
   \   00000112   0x69A8             LDR      R0,[R5, #+24]
   \   00000114   0x4287             CMP      R7,R0
   \   00000116   0xF000 0x80EF      BEQ.W    ??f_lseek_12
   2861          #if !_FS_TINY
   2862          #if !_FS_READONLY
   2863          					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   \   0000011A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000011C   0x0640             LSLS     R0,R0,#+25
   \   0000011E   0xD513             BPL.N    ??f_lseek_15
   2864          						if (LPLD_Disk_Write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   00000120   0x2301             MOVS     R3,#+1
   \   00000122   0x69AA             LDR      R2,[R5, #+24]
   \   00000124   0xF115 0x012C      ADDS     R1,R5,#+44
   \   00000128   0x6828             LDR      R0,[R5, #+0]
   \   0000012A   0x7840             LDRB     R0,[R0, #+1]
   \   0000012C   0x.... 0x....      BL       LPLD_Disk_Write
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD005             BEQ.N    ??f_lseek_16
   2865          							ABORT(fp->fs, FR_DISK_ERR);
   \   00000134   0x79A8             LDRB     R0,[R5, #+6]
   \   00000136   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000013A   0x71A8             STRB     R0,[R5, #+6]
   \   0000013C   0x2001             MOVS     R0,#+1
   \   0000013E   0xE0DD             B.N      ??f_lseek_1
   2866          						fp->flag &= ~FA__DIRTY;
   \                     ??f_lseek_16:
   \   00000140   0x79A8             LDRB     R0,[R5, #+6]
   \   00000142   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000146   0x71A8             STRB     R0,[R5, #+6]
   2867          					}
   2868          #endif
   2869          					if (LPLD_Disk_Read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
   \                     ??f_lseek_15:
   \   00000148   0x2301             MOVS     R3,#+1
   \   0000014A   0x003A             MOVS     R2,R7
   \   0000014C   0xF115 0x012C      ADDS     R1,R5,#+44
   \   00000150   0x6828             LDR      R0,[R5, #+0]
   \   00000152   0x7840             LDRB     R0,[R0, #+1]
   \   00000154   0x.... 0x....      BL       LPLD_Disk_Read
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD005             BEQ.N    ??f_lseek_17
   2870          						ABORT(fp->fs, FR_DISK_ERR);
   \   0000015C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000015E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000162   0x71A8             STRB     R0,[R5, #+6]
   \   00000164   0x2001             MOVS     R0,#+1
   \   00000166   0xE0C9             B.N      ??f_lseek_1
   2871          #endif
   2872          					fp->dsect = dsc;
   \                     ??f_lseek_17:
   \   00000168   0x61AF             STR      R7,[R5, #+24]
   \   0000016A   0xE0C5             B.N      ??f_lseek_12
   2873          				}
   2874          			}
   2875          		}
   2876          	} else
   2877          #endif
   2878          
   2879          	/* Normal Seek */
   2880          	{
   2881          		DWORD clst, bcs, nsect, ifptr;
   2882          
   2883          		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   2884          #if !_FS_READONLY
   2885          			 && !(fp->flag & FA_WRITE)
   2886          #endif
   2887          			) ofs = fp->fsize;
   \                     ??f_lseek_3:
   \   0000016C   0x68E8             LDR      R0,[R5, #+12]
   \   0000016E   0x42B0             CMP      R0,R6
   \   00000170   0xD203             BCS.N    ??f_lseek_18
   \   00000172   0x79A8             LDRB     R0,[R5, #+6]
   \   00000174   0x0780             LSLS     R0,R0,#+30
   \   00000176   0xD400             BMI.N    ??f_lseek_18
   \   00000178   0x68EE             LDR      R6,[R5, #+12]
   2888          
   2889          		ifptr = fp->fptr;
   \                     ??f_lseek_18:
   \   0000017A   0x68A8             LDR      R0,[R5, #+8]
   2890          		fp->fptr = nsect = 0;
   \   0000017C   0x2700             MOVS     R7,#+0
   \   0000017E   0x60AF             STR      R7,[R5, #+8]
   2891          		if (ofs) {
   \   00000180   0x2E00             CMP      R6,#+0
   \   00000182   0xD07B             BEQ.N    ??f_lseek_19
   2892          			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   \   00000184   0x6829             LDR      R1,[R5, #+0]
   \   00000186   0x7889             LDRB     R1,[R1, #+2]
   \   00000188   0xF44F 0x7200      MOV      R2,#+512
   \   0000018C   0xFB02 0xF801      MUL      R8,R2,R1
   2893          			if (ifptr > 0 &&
   2894          				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   \   00000190   0x2800             CMP      R0,#+0
   \   00000192   0xD010             BEQ.N    ??f_lseek_20
   \   00000194   0x1E41             SUBS     R1,R0,#+1
   \   00000196   0xFBB1 0xF1F8      UDIV     R1,R1,R8
   \   0000019A   0x1E72             SUBS     R2,R6,#+1
   \   0000019C   0xFBB2 0xF2F8      UDIV     R2,R2,R8
   \   000001A0   0x428A             CMP      R2,R1
   \   000001A2   0xD308             BCC.N    ??f_lseek_20
   2895          				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   \   000001A4   0x1E40             SUBS     R0,R0,#+1
   \   000001A6   0xF1B8 0x0101      SUBS     R1,R8,#+1
   \   000001AA   0x4388             BICS     R0,R0,R1
   \   000001AC   0x60A8             STR      R0,[R5, #+8]
   2896          				ofs -= fp->fptr;
   \   000001AE   0x68A8             LDR      R0,[R5, #+8]
   \   000001B0   0x1A36             SUBS     R6,R6,R0
   2897          				clst = fp->clust;
   \   000001B2   0x6969             LDR      R1,[R5, #+20]
   \   000001B4   0xE01A             B.N      ??f_lseek_21
   2898          			} else {									/* When seek to back cluster, */
   2899          				clst = fp->sclust;						/* start from the first cluster */
   \                     ??f_lseek_20:
   \   000001B6   0x6929             LDR      R1,[R5, #+16]
   2900          #if !_FS_READONLY
   2901          				if (clst == 0) {						/* If no cluster chain, create a new chain */
   \   000001B8   0x2900             CMP      R1,#+0
   \   000001BA   0xD116             BNE.N    ??f_lseek_22
   2902          					clst = create_chain(fp->fs, 0);
   \   000001BC   0x2100             MOVS     R1,#+0
   \   000001BE   0x6828             LDR      R0,[R5, #+0]
   \   000001C0   0x.... 0x....      BL       create_chain
   \   000001C4   0x0001             MOVS     R1,R0
   2903          					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \   000001C6   0x2901             CMP      R1,#+1
   \   000001C8   0xD105             BNE.N    ??f_lseek_23
   \   000001CA   0x79A8             LDRB     R0,[R5, #+6]
   \   000001CC   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001D0   0x71A8             STRB     R0,[R5, #+6]
   \   000001D2   0x2002             MOVS     R0,#+2
   \   000001D4   0xE092             B.N      ??f_lseek_1
   2904          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_23:
   \   000001D6   0xF111 0x0F01      CMN      R1,#+1
   \   000001DA   0xD105             BNE.N    ??f_lseek_24
   \   000001DC   0x79A8             LDRB     R0,[R5, #+6]
   \   000001DE   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001E2   0x71A8             STRB     R0,[R5, #+6]
   \   000001E4   0x2001             MOVS     R0,#+1
   \   000001E6   0xE089             B.N      ??f_lseek_1
   2905          					fp->sclust = clst;
   \                     ??f_lseek_24:
   \   000001E8   0x6129             STR      R1,[R5, #+16]
   2906          				}
   2907          #endif
   2908          				fp->clust = clst;
   \                     ??f_lseek_22:
   \   000001EA   0x6169             STR      R1,[R5, #+20]
   2909          			}
   2910          			if (clst != 0) {
   \                     ??f_lseek_21:
   \   000001EC   0x2900             CMP      R1,#+0
   \   000001EE   0xD107             BNE.N    ??f_lseek_25
   \   000001F0   0xE044             B.N      ??f_lseek_19
   2911          				while (ofs > bcs) {						/* Cluster following loop */
   2912          #if !_FS_READONLY
   2913          					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   2914          						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
   2915          						if (clst == 0) {				/* When disk gets full, clip file size */
   2916          							ofs = bcs; break;
   2917          						}
   2918          					} else
   2919          #endif
   2920          						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   2921          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2922          					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
   2923          					fp->clust = clst;
   \                     ??f_lseek_26:
   \   000001F2   0x6169             STR      R1,[R5, #+20]
   2924          					fp->fptr += bcs;
   \   000001F4   0x68A8             LDR      R0,[R5, #+8]
   \   000001F6   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001FA   0x60A8             STR      R0,[R5, #+8]
   2925          					ofs -= bcs;
   \   000001FC   0xEBB6 0x0608      SUBS     R6,R6,R8
   \                     ??f_lseek_25:
   \   00000200   0x45B0             CMP      R8,R6
   \   00000202   0xD209             BCS.N    ??f_lseek_27
   \   00000204   0x79A8             LDRB     R0,[R5, #+6]
   \   00000206   0x0780             LSLS     R0,R0,#+30
   \   00000208   0xD51D             BPL.N    ??f_lseek_28
   \   0000020A   0x6828             LDR      R0,[R5, #+0]
   \   0000020C   0x.... 0x....      BL       create_chain
   \   00000210   0x0001             MOVS     R1,R0
   \   00000212   0x2900             CMP      R1,#+0
   \   00000214   0xD11B             BNE.N    ??f_lseek_29
   \   00000216   0x4646             MOV      R6,R8
   2926          				}
   2927          				fp->fptr += ofs;
   \                     ??f_lseek_27:
   \   00000218   0x68A8             LDR      R0,[R5, #+8]
   \   0000021A   0x1830             ADDS     R0,R6,R0
   \   0000021C   0x60A8             STR      R0,[R5, #+8]
   2928          				if (ofs % SS(fp->fs)) {
   \   0000021E   0xF44F 0x7000      MOV      R0,#+512
   \   00000222   0xFBB6 0xF2F0      UDIV     R2,R6,R0
   \   00000226   0xFB02 0x6210      MLS      R2,R2,R0,R6
   \   0000022A   0x2A00             CMP      R2,#+0
   \   0000022C   0xD026             BEQ.N    ??f_lseek_19
   2929          					nsect = clust2sect(fp->fs, clst);	/* Current sector */
   \   0000022E   0x6828             LDR      R0,[R5, #+0]
   \   00000230   0x.... 0x....      BL       clust2sect
   \   00000234   0x0007             MOVS     R7,R0
   2930          					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   \   00000236   0x2F00             CMP      R7,#+0
   \   00000238   0xD11E             BNE.N    ??f_lseek_30
   \   0000023A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000023C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000240   0x71A8             STRB     R0,[R5, #+6]
   \   00000242   0x2002             MOVS     R0,#+2
   \   00000244   0xE05A             B.N      ??f_lseek_1
   \                     ??f_lseek_28:
   \   00000246   0x6828             LDR      R0,[R5, #+0]
   \   00000248   0x.... 0x....      BL       get_fat
   \   0000024C   0x0001             MOVS     R1,R0
   \                     ??f_lseek_29:
   \   0000024E   0xF111 0x0F01      CMN      R1,#+1
   \   00000252   0xD105             BNE.N    ??f_lseek_31
   \   00000254   0x79A8             LDRB     R0,[R5, #+6]
   \   00000256   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000025A   0x71A8             STRB     R0,[R5, #+6]
   \   0000025C   0x2001             MOVS     R0,#+1
   \   0000025E   0xE04D             B.N      ??f_lseek_1
   \                     ??f_lseek_31:
   \   00000260   0x2902             CMP      R1,#+2
   \   00000262   0xD303             BCC.N    ??f_lseek_32
   \   00000264   0x6828             LDR      R0,[R5, #+0]
   \   00000266   0x69C0             LDR      R0,[R0, #+28]
   \   00000268   0x4281             CMP      R1,R0
   \   0000026A   0xD3C2             BCC.N    ??f_lseek_26
   \                     ??f_lseek_32:
   \   0000026C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000026E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000272   0x71A8             STRB     R0,[R5, #+6]
   \   00000274   0x2002             MOVS     R0,#+2
   \   00000276   0xE041             B.N      ??f_lseek_1
   2931          					nsect += ofs / SS(fp->fs);
   \                     ??f_lseek_30:
   \   00000278   0xEB17 0x2756      ADDS     R7,R7,R6, LSR #+9
   2932          				}
   2933          			}
   2934          		}
   2935          		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
   \                     ??f_lseek_19:
   \   0000027C   0x68A8             LDR      R0,[R5, #+8]
   \   0000027E   0xF44F 0x7100      MOV      R1,#+512
   \   00000282   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000286   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   0000028A   0x2A00             CMP      R2,#+0
   \   0000028C   0xD02A             BEQ.N    ??f_lseek_33
   \   0000028E   0x69A8             LDR      R0,[R5, #+24]
   \   00000290   0x4287             CMP      R7,R0
   \   00000292   0xD027             BEQ.N    ??f_lseek_33
   2936          #if !_FS_TINY
   2937          #if !_FS_READONLY
   2938          			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
   \   00000294   0x79A8             LDRB     R0,[R5, #+6]
   \   00000296   0x0640             LSLS     R0,R0,#+25
   \   00000298   0xD513             BPL.N    ??f_lseek_34
   2939          				if (LPLD_Disk_Write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   0000029A   0x2301             MOVS     R3,#+1
   \   0000029C   0x69AA             LDR      R2,[R5, #+24]
   \   0000029E   0xF115 0x012C      ADDS     R1,R5,#+44
   \   000002A2   0x6828             LDR      R0,[R5, #+0]
   \   000002A4   0x7840             LDRB     R0,[R0, #+1]
   \   000002A6   0x.... 0x....      BL       LPLD_Disk_Write
   \   000002AA   0x2800             CMP      R0,#+0
   \   000002AC   0xD005             BEQ.N    ??f_lseek_35
   2940          					ABORT(fp->fs, FR_DISK_ERR);
   \   000002AE   0x79A8             LDRB     R0,[R5, #+6]
   \   000002B0   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000002B4   0x71A8             STRB     R0,[R5, #+6]
   \   000002B6   0x2001             MOVS     R0,#+1
   \   000002B8   0xE020             B.N      ??f_lseek_1
   2941          				fp->flag &= ~FA__DIRTY;
   \                     ??f_lseek_35:
   \   000002BA   0x79A8             LDRB     R0,[R5, #+6]
   \   000002BC   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000002C0   0x71A8             STRB     R0,[R5, #+6]
   2942          			}
   2943          #endif
   2944          			if (LPLD_Disk_Read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
   \                     ??f_lseek_34:
   \   000002C2   0x2301             MOVS     R3,#+1
   \   000002C4   0x003A             MOVS     R2,R7
   \   000002C6   0xF115 0x012C      ADDS     R1,R5,#+44
   \   000002CA   0x6828             LDR      R0,[R5, #+0]
   \   000002CC   0x7840             LDRB     R0,[R0, #+1]
   \   000002CE   0x.... 0x....      BL       LPLD_Disk_Read
   \   000002D2   0x2800             CMP      R0,#+0
   \   000002D4   0xD005             BEQ.N    ??f_lseek_36
   2945          				ABORT(fp->fs, FR_DISK_ERR);
   \   000002D6   0x79A8             LDRB     R0,[R5, #+6]
   \   000002D8   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000002DC   0x71A8             STRB     R0,[R5, #+6]
   \   000002DE   0x2001             MOVS     R0,#+1
   \   000002E0   0xE00C             B.N      ??f_lseek_1
   2946          #endif
   2947          			fp->dsect = nsect;
   \                     ??f_lseek_36:
   \   000002E2   0x61AF             STR      R7,[R5, #+24]
   2948          		}
   2949          #if !_FS_READONLY
   2950          		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
   \                     ??f_lseek_33:
   \   000002E4   0x68E8             LDR      R0,[R5, #+12]
   \   000002E6   0x68A9             LDR      R1,[R5, #+8]
   \   000002E8   0x4288             CMP      R0,R1
   \   000002EA   0xD205             BCS.N    ??f_lseek_12
   2951          			fp->fsize = fp->fptr;
   \   000002EC   0x68A8             LDR      R0,[R5, #+8]
   \   000002EE   0x60E8             STR      R0,[R5, #+12]
   2952          			fp->flag |= FA__WRITTEN;
   \   000002F0   0x79A8             LDRB     R0,[R5, #+6]
   \   000002F2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000002F6   0x71A8             STRB     R0,[R5, #+6]
   2953          		}
   2954          #endif
   2955          	}
   2956          
   2957          	LEAVE_FF(fp->fs, res);
   \                     ??f_lseek_12:
   \   000002F8   0x0020             MOVS     R0,R4
   \   000002FA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_lseek_1:
   \   000002FC   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   2958          }
   2959          
   2960          
   2961          
   2962          #if _FS_MINIMIZE <= 1
   2963          /*-----------------------------------------------------------------------*/
   2964          /* Create a Directroy Object                                             */
   2965          /*-----------------------------------------------------------------------*/
   2966          

   \                                 In section .text, align 2, keep-with-next
   2967          FRESULT f_opendir (
   2968          	DIR *dj,			/* Pointer to directory object to create */
   2969          	const TCHAR *path	/* Pointer to the directory path */
   2970          )
   2971          {
   \                     f_opendir:
   \   00000000   0xB572             PUSH     {R1,R4-R6,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   2972          	FRESULT res;
   2973          	DEF_NAMEBUF;
   2974          
   2975          
   2976          	res = chk_mounted(&path, &dj->fs, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0021             MOVS     R1,R4
   \   0000000A   0xA803             ADD      R0,SP,#+12
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0005             MOVS     R5,R0
   2977          	if (res == FR_OK) {
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD13E             BNE.N    ??f_opendir_0
   2978          		INIT_BUF(*dj);
   \   00000018   0x2082             MOVS     R0,#+130
   \   0000001A   0x.... 0x....      BL       ff_memalloc
   \   0000001E   0x0006             MOVS     R6,R0
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD101             BNE.N    ??f_opendir_1
   \   00000024   0x2011             MOVS     R0,#+17
   \   00000026   0xE038             B.N      ??f_opendir_2
   \                     ??f_opendir_1:
   \   00000028   0x61E6             STR      R6,[R4, #+28]
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x61A0             STR      R0,[R4, #+24]
   2979          		res = follow_path(dj, path);			/* Follow the path to the directory */
   \   0000002E   0x9903             LDR      R1,[SP, #+12]
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       follow_path
   \   00000036   0x0005             MOVS     R5,R0
   2980          		FREE_BUF();
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0x.... 0x....      BL       ff_memfree
   2981          		if (res == FR_OK) {						/* Follow completed */
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD124             BNE.N    ??f_opendir_3
   2982          			if (dj->dir) {						/* It is not the root dir */
   \   00000044   0x6960             LDR      R0,[R4, #+20]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD016             BEQ.N    ??f_opendir_4
   2983          				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
   \   0000004A   0x6960             LDR      R0,[R4, #+20]
   \   0000004C   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000004E   0x06C0             LSLS     R0,R0,#+27
   \   00000050   0xD511             BPL.N    ??f_opendir_5
   2984          					dj->sclust = LD_CLUST(dj->dir);
   \   00000052   0x6960             LDR      R0,[R4, #+20]
   \   00000054   0x7D40             LDRB     R0,[R0, #+21]
   \   00000056   0x6961             LDR      R1,[R4, #+20]
   \   00000058   0x7D09             LDRB     R1,[R1, #+20]
   \   0000005A   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000005E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000060   0x6961             LDR      R1,[R4, #+20]
   \   00000062   0x7EC9             LDRB     R1,[R1, #+27]
   \   00000064   0x6962             LDR      R2,[R4, #+20]
   \   00000066   0x7E92             LDRB     R2,[R2, #+26]
   \   00000068   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   0000006C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000006E   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000072   0x60A0             STR      R0,[R4, #+8]
   \   00000074   0xE000             B.N      ??f_opendir_4
   2985          				} else {						/* The object is not a directory */
   2986          					res = FR_NO_PATH;
   \                     ??f_opendir_5:
   \   00000076   0x2505             MOVS     R5,#+5
   2987          				}
   2988          			}
   2989          			if (res == FR_OK) {
   \                     ??f_opendir_4:
   \   00000078   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007A   0x2D00             CMP      R5,#+0
   \   0000007C   0xD107             BNE.N    ??f_opendir_3
   2990          				dj->id = dj->fs->id;
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x88C0             LDRH     R0,[R0, #+6]
   \   00000082   0x80A0             STRH     R0,[R4, #+4]
   2991          				res = dir_sdi(dj, 0);			/* Rewind dir */
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       dir_sdi
   \   0000008C   0x0005             MOVS     R5,R0
   2992          			}
   2993          		}
   2994          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_opendir_3:
   \   0000008E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000090   0x2D04             CMP      R5,#+4
   \   00000092   0xD100             BNE.N    ??f_opendir_0
   \   00000094   0x2505             MOVS     R5,#+5
   2995          	}
   2996          
   2997          	LEAVE_FF(dj->fs, res);
   \                     ??f_opendir_0:
   \   00000096   0x0028             MOVS     R0,R5
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_opendir_2:
   \   0000009A   0xB004             ADD      SP,SP,#+16
   \   0000009C   0xBD70             POP      {R4-R6,PC}       ;; return
   2998          }
   2999          
   3000          
   3001          
   3002          
   3003          /*-----------------------------------------------------------------------*/
   3004          /* Read Directory Entry in Sequense                                      */
   3005          /*-----------------------------------------------------------------------*/
   3006          

   \                                 In section .text, align 2, keep-with-next
   3007          FRESULT f_readdir (
   3008          	DIR *dj,			/* Pointer to the open directory object */
   3009          	FILINFO *fno		/* Pointer to file information to return */
   3010          )
   3011          {
   \                     f_readdir:
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3012          	FRESULT res;
   3013          	DEF_NAMEBUF;
   3014          
   3015          
   3016          	res = validate(dj->fs, dj->id);			/* Check validity of the object */
   \   00000006   0x88A1             LDRH     R1,[R4, #+4]
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       validate
   \   0000000E   0x0006             MOVS     R6,R0
   3017          	if (res == FR_OK) {
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD131             BNE.N    ??f_readdir_0
   3018          		if (!fno) {
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD105             BNE.N    ??f_readdir_1
   3019          			res = dir_sdi(dj, 0);			/* Rewind the directory object */
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       dir_sdi
   \   00000022   0x0006             MOVS     R6,R0
   \   00000024   0xE029             B.N      ??f_readdir_0
   3020          		} else {
   3021          			INIT_BUF(*dj);
   \                     ??f_readdir_1:
   \   00000026   0x2082             MOVS     R0,#+130
   \   00000028   0x.... 0x....      BL       ff_memalloc
   \   0000002C   0x0007             MOVS     R7,R0
   \   0000002E   0x2F00             CMP      R7,#+0
   \   00000030   0xD101             BNE.N    ??f_readdir_2
   \   00000032   0x2011             MOVS     R0,#+17
   \   00000034   0xE023             B.N      ??f_readdir_3
   \                     ??f_readdir_2:
   \   00000036   0x61E7             STR      R7,[R4, #+28]
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x61A0             STR      R0,[R4, #+24]
   3022          			res = dir_read(dj);				/* Read an directory item */
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       dir_read
   \   00000042   0x0006             MOVS     R6,R0
   3023          			if (res == FR_NO_FILE) {		/* Reached end of dir */
   \   00000044   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000046   0x2E04             CMP      R6,#+4
   \   00000048   0xD102             BNE.N    ??f_readdir_4
   3024          				dj->sect = 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6120             STR      R0,[R4, #+16]
   3025          				res = FR_OK;
   \   0000004E   0x2600             MOVS     R6,#+0
   3026          			}
   3027          			if (res == FR_OK) {				/* A valid entry is found */
   \                     ??f_readdir_4:
   \   00000050   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD10E             BNE.N    ??f_readdir_5
   3028          				get_fileinfo(dj, fno);		/* Get the object information */
   \   00000056   0x0029             MOVS     R1,R5
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       get_fileinfo
   3029          				res = dir_next(dj, 0);		/* Increment index for next */
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       dir_next
   \   00000066   0x0006             MOVS     R6,R0
   3030          				if (res == FR_NO_FILE) {
   \   00000068   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006A   0x2E04             CMP      R6,#+4
   \   0000006C   0xD102             BNE.N    ??f_readdir_5
   3031          					dj->sect = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x6120             STR      R0,[R4, #+16]
   3032          					res = FR_OK;
   \   00000072   0x2600             MOVS     R6,#+0
   3033          				}
   3034          			}
   3035          			FREE_BUF();
   \                     ??f_readdir_5:
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0x.... 0x....      BL       ff_memfree
   3036          		}
   3037          	}
   3038          
   3039          	LEAVE_FF(dj->fs, res);
   \                     ??f_readdir_0:
   \   0000007A   0x0030             MOVS     R0,R6
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_readdir_3:
   \   0000007E   0xBDFE             POP      {R1-R7,PC}       ;; return
   3040          }
   3041          
   3042          
   3043          
   3044          #if _FS_MINIMIZE == 0
   3045          /*-----------------------------------------------------------------------*/
   3046          /* Get File Status                                                       */
   3047          /*-----------------------------------------------------------------------*/
   3048          

   \                                 In section .text, align 2, keep-with-next
   3049          FRESULT f_stat (
   3050          	const TCHAR *path,	/* Pointer to the file path */
   3051          	FILINFO *fno		/* Pointer to file information to return */
   3052          )
   3053          {
   \                     f_stat:
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x000C             MOVS     R4,R1
   3054          	FRESULT res;
   3055          	DIR dj;
   3056          	DEF_NAMEBUF;
   3057          
   3058          
   3059          	res = chk_mounted(&path, &dj.fs, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xA903             ADD      R1,SP,#+12
   \   0000000A   0xA80D             ADD      R0,SP,#+52
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0005             MOVS     R5,R0
   3060          	if (res == FR_OK) {
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD11E             BNE.N    ??f_stat_0
   3061          		INIT_BUF(dj);
   \   00000018   0x2082             MOVS     R0,#+130
   \   0000001A   0x.... 0x....      BL       ff_memalloc
   \   0000001E   0x0006             MOVS     R6,R0
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD101             BNE.N    ??f_stat_1
   \   00000024   0x2011             MOVS     R0,#+17
   \   00000026   0xE018             B.N      ??f_stat_2
   \                     ??f_stat_1:
   \   00000028   0x960A             STR      R6,[SP, #+40]
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x9009             STR      R0,[SP, #+36]
   3062          		res = follow_path(&dj, path);	/* Follow the file path */
   \   0000002E   0x990D             LDR      R1,[SP, #+52]
   \   00000030   0xA803             ADD      R0,SP,#+12
   \   00000032   0x.... 0x....      BL       follow_path
   \   00000036   0x0005             MOVS     R5,R0
   3063          		if (res == FR_OK) {				/* Follow completed */
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD108             BNE.N    ??f_stat_3
   3064          			if (dj.dir)		/* Found an object */
   \   0000003E   0x9808             LDR      R0,[SP, #+32]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD004             BEQ.N    ??f_stat_4
   3065          				get_fileinfo(&dj, fno);
   \   00000044   0x0021             MOVS     R1,R4
   \   00000046   0xA803             ADD      R0,SP,#+12
   \   00000048   0x.... 0x....      BL       get_fileinfo
   \   0000004C   0xE000             B.N      ??f_stat_3
   3066          			else			/* It is root dir */
   3067          				res = FR_INVALID_NAME;
   \                     ??f_stat_4:
   \   0000004E   0x2506             MOVS     R5,#+6
   3068          		}
   3069          		FREE_BUF();
   \                     ??f_stat_3:
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0x.... 0x....      BL       ff_memfree
   3070          	}
   3071          
   3072          	LEAVE_FF(dj.fs, res);
   \                     ??f_stat_0:
   \   00000056   0x0028             MOVS     R0,R5
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_stat_2:
   \   0000005A   0xB00E             ADD      SP,SP,#+56
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
   3073          }
   3074          
   3075          
   3076          
   3077          #if !_FS_READONLY
   3078          /*-----------------------------------------------------------------------*/
   3079          /* Get Number of Free Clusters                                           */
   3080          /*-----------------------------------------------------------------------*/
   3081          

   \                                 In section .text, align 2, keep-with-next
   3082          FRESULT f_getfree (
   3083          	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
   3084          	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
   3085          	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
   3086          )
   3087          {
   \                     f_getfree:
   \   00000000   0xE92D 0x47F1      PUSH     {R0,R4-R10,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   3088          	FRESULT res;
   3089          	DWORD n, clst, sect, stat;
   3090          	UINT i;
   3091          	BYTE fat, *p;
   3092          
   3093          
   3094          	/* Get drive number */
   3095          	res = chk_mounted(&path, fatfs, 0);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0031             MOVS     R1,R6
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       chk_mounted
   \   00000014   0x4680             MOV      R8,R0
   3096          	if (res == FR_OK) {
   \   00000016   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001E   0xD171             BNE.N    ??f_getfree_0
   3097          		/* If free_clust is valid, return it without full cluster scan */
   3098          		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
   \   00000020   0x6830             LDR      R0,[R6, #+0]
   \   00000022   0x69C0             LDR      R0,[R0, #+28]
   \   00000024   0x1E80             SUBS     R0,R0,#+2
   \   00000026   0x6831             LDR      R1,[R6, #+0]
   \   00000028   0x6909             LDR      R1,[R1, #+16]
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD303             BCC.N    ??f_getfree_1
   3099          			*nclst = (*fatfs)->free_clust;
   \   0000002E   0x6830             LDR      R0,[R6, #+0]
   \   00000030   0x6900             LDR      R0,[R0, #+16]
   \   00000032   0x6028             STR      R0,[R5, #+0]
   \   00000034   0xE066             B.N      ??f_getfree_0
   3100          		} else {
   3101          			/* Get number of free clusters */
   3102          			fat = (*fatfs)->fs_type;
   \                     ??f_getfree_1:
   \   00000036   0x6830             LDR      R0,[R6, #+0]
   \   00000038   0x7807             LDRB     R7,[R0, #+0]
   3103          			n = 0;
   \   0000003A   0xF05F 0x0900      MOVS     R9,#+0
   3104          			if (fat == FS_FAT12) {
   \   0000003E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000040   0x2F01             CMP      R7,#+1
   \   00000042   0xD119             BNE.N    ??f_getfree_2
   3105          				clst = 2;
   \   00000044   0x2402             MOVS     R4,#+2
   3106          				do {
   3107          					stat = get_fat(*fatfs, clst);
   \                     ??f_getfree_3:
   \   00000046   0x0021             MOVS     R1,R4
   \   00000048   0x6830             LDR      R0,[R6, #+0]
   \   0000004A   0x.... 0x....      BL       get_fat
   3108          					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   \   0000004E   0xF110 0x0F01      CMN      R0,#+1
   \   00000052   0xD102             BNE.N    ??f_getfree_4
   \   00000054   0xF05F 0x0801      MOVS     R8,#+1
   \   00000058   0xE049             B.N      ??f_getfree_5
   3109          					if (stat == 1) { res = FR_INT_ERR; break; }
   \                     ??f_getfree_4:
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD102             BNE.N    ??f_getfree_6
   \   0000005E   0xF05F 0x0802      MOVS     R8,#+2
   \   00000062   0xE044             B.N      ??f_getfree_5
   3110          					if (stat == 0) n++;
   \                     ??f_getfree_6:
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD101             BNE.N    ??f_getfree_7
   \   00000068   0xF119 0x0901      ADDS     R9,R9,#+1
   3111          				} while (++clst < (*fatfs)->n_fatent);
   \                     ??f_getfree_7:
   \   0000006C   0x1C64             ADDS     R4,R4,#+1
   \   0000006E   0x6830             LDR      R0,[R6, #+0]
   \   00000070   0x69C0             LDR      R0,[R0, #+28]
   \   00000072   0x4284             CMP      R4,R0
   \   00000074   0xD3E7             BCC.N    ??f_getfree_3
   \   00000076   0xE03A             B.N      ??f_getfree_5
   3112          			} else {
   3113          				clst = (*fatfs)->n_fatent;
   \                     ??f_getfree_2:
   \   00000078   0x6830             LDR      R0,[R6, #+0]
   \   0000007A   0x69C4             LDR      R4,[R0, #+28]
   3114          				sect = (*fatfs)->fatbase;
   \   0000007C   0x6830             LDR      R0,[R6, #+0]
   \   0000007E   0xF8D0 0xA024      LDR      R10,[R0, #+36]
   3115          				i = 0; p = 0;
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x2000             MOVS     R0,#+0
   3116          				do {
   3117          					if (!i) {
   \                     ??f_getfree_8:
   \   00000086   0x2900             CMP      R1,#+0
   \   00000088   0xD10F             BNE.N    ??f_getfree_9
   3118          						res = move_window(*fatfs, sect++);
   \   0000008A   0x4651             MOV      R1,R10
   \   0000008C   0x6830             LDR      R0,[R6, #+0]
   \   0000008E   0x.... 0x....      BL       move_window
   \   00000092   0x4680             MOV      R8,R0
   \   00000094   0xF11A 0x0A01      ADDS     R10,R10,#+1
   3119          						if (res != FR_OK) break;
   \   00000098   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009C   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000A0   0xD125             BNE.N    ??f_getfree_5
   3120          						p = (*fatfs)->win;
   \                     ??f_getfree_10:
   \   000000A2   0x6830             LDR      R0,[R6, #+0]
   \   000000A4   0x3034             ADDS     R0,R0,#+52
   3121          						i = SS(*fatfs);
   \   000000A6   0xF44F 0x7100      MOV      R1,#+512
   3122          					}
   3123          					if (fat == FS_FAT16) {
   \                     ??f_getfree_9:
   \   000000AA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000AC   0x2F02             CMP      R7,#+2
   \   000000AE   0xD10B             BNE.N    ??f_getfree_11
   3124          						if (LD_WORD(p) == 0) n++;
   \   000000B0   0x7842             LDRB     R2,[R0, #+1]
   \   000000B2   0x7803             LDRB     R3,[R0, #+0]
   \   000000B4   0xEA53 0x2202      ORRS     R2,R3,R2, LSL #+8
   \   000000B8   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000BA   0x2A00             CMP      R2,#+0
   \   000000BC   0xD101             BNE.N    ??f_getfree_12
   \   000000BE   0xF119 0x0901      ADDS     R9,R9,#+1
   3125          						p += 2; i -= 2;
   \                     ??f_getfree_12:
   \   000000C2   0x1C80             ADDS     R0,R0,#+2
   \   000000C4   0x1E89             SUBS     R1,R1,#+2
   \   000000C6   0xE00F             B.N      ??f_getfree_13
   3126          					} else {
   3127          						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
   \                     ??f_getfree_11:
   \   000000C8   0x78C2             LDRB     R2,[R0, #+3]
   \   000000CA   0x7883             LDRB     R3,[R0, #+2]
   \   000000CC   0x041B             LSLS     R3,R3,#+16
   \   000000CE   0xEA53 0x6202      ORRS     R2,R3,R2, LSL #+24
   \   000000D2   0x7843             LDRB     R3,[R0, #+1]
   \   000000D4   0xEA52 0x2203      ORRS     R2,R2,R3, LSL #+8
   \   000000D8   0x7803             LDRB     R3,[R0, #+0]
   \   000000DA   0x431A             ORRS     R2,R3,R2
   \   000000DC   0x0112             LSLS     R2,R2,#+4
   \   000000DE   0xD101             BNE.N    ??f_getfree_14
   \   000000E0   0xF119 0x0901      ADDS     R9,R9,#+1
   3128          						p += 4; i -= 4;
   \                     ??f_getfree_14:
   \   000000E4   0x1D00             ADDS     R0,R0,#+4
   \   000000E6   0x1F09             SUBS     R1,R1,#+4
   3129          					}
   3130          				} while (--clst);
   \                     ??f_getfree_13:
   \   000000E8   0x1E64             SUBS     R4,R4,#+1
   \   000000EA   0x2C00             CMP      R4,#+0
   \   000000EC   0xD1CB             BNE.N    ??f_getfree_8
   3131          			}
   3132          			(*fatfs)->free_clust = n;
   \                     ??f_getfree_5:
   \   000000EE   0x6830             LDR      R0,[R6, #+0]
   \   000000F0   0xF8C0 0x9010      STR      R9,[R0, #+16]
   3133          			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
   \   000000F4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F6   0x2F03             CMP      R7,#+3
   \   000000F8   0xD102             BNE.N    ??f_getfree_15
   \   000000FA   0x6830             LDR      R0,[R6, #+0]
   \   000000FC   0x2101             MOVS     R1,#+1
   \   000000FE   0x7141             STRB     R1,[R0, #+5]
   3134          			*nclst = n;
   \                     ??f_getfree_15:
   \   00000100   0xF8C5 0x9000      STR      R9,[R5, #+0]
   3135          		}
   3136          	}
   3137          	LEAVE_FF(*fatfs, res);
   \                     ??f_getfree_0:
   \   00000104   0x4640             MOV      R0,R8
   \   00000106   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000108   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   3138          }
   3139          
   3140          
   3141          
   3142          
   3143          /*-----------------------------------------------------------------------*/
   3144          /* Truncate File                                                         */
   3145          /*-----------------------------------------------------------------------*/
   3146          

   \                                 In section .text, align 2, keep-with-next
   3147          FRESULT f_truncate (
   3148          	FIL *fp		/* Pointer to the file object */
   3149          )
   3150          {
   \                     f_truncate:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3151          	FRESULT res;
   3152          	DWORD ncl;
   3153          
   3154          
   3155          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   \   00000004   0x88A1             LDRH     R1,[R4, #+4]
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       validate
   3156          	if (res == FR_OK) {
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD108             BNE.N    ??f_truncate_0
   3157          		if (fp->flag & FA__ERROR) {			/* Check abort flag */
   \   00000012   0x79A1             LDRB     R1,[R4, #+6]
   \   00000014   0x0609             LSLS     R1,R1,#+24
   \   00000016   0xD501             BPL.N    ??f_truncate_1
   3158          			res = FR_INT_ERR;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xE003             B.N      ??f_truncate_0
   3159          		} else {
   3160          			if (!(fp->flag & FA_WRITE))		/* Check access mode */
   \                     ??f_truncate_1:
   \   0000001C   0x79A1             LDRB     R1,[R4, #+6]
   \   0000001E   0x0789             LSLS     R1,R1,#+30
   \   00000020   0xD400             BMI.N    ??f_truncate_0
   3161          				res = FR_DENIED;
   \   00000022   0x2007             MOVS     R0,#+7
   3162          		}
   3163          	}
   3164          	if (res == FR_OK) {
   \                     ??f_truncate_0:
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD13B             BNE.N    ??f_truncate_2
   3165          		if (fp->fsize > fp->fptr) {
   \   0000002A   0x68A1             LDR      R1,[R4, #+8]
   \   0000002C   0x68E2             LDR      R2,[R4, #+12]
   \   0000002E   0x4291             CMP      R1,R2
   \   00000030   0xD230             BCS.N    ??f_truncate_3
   3166          			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
   \   00000032   0x68A0             LDR      R0,[R4, #+8]
   \   00000034   0x60E0             STR      R0,[R4, #+12]
   3167          			fp->flag |= FA__WRITTEN;
   \   00000036   0x79A0             LDRB     R0,[R4, #+6]
   \   00000038   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000003C   0x71A0             STRB     R0,[R4, #+6]
   3168          			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD106             BNE.N    ??f_truncate_4
   3169          				res = remove_chain(fp->fs, fp->sclust);
   \   00000044   0x6921             LDR      R1,[R4, #+16]
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       remove_chain
   3170          				fp->sclust = 0;
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x6121             STR      R1,[R4, #+16]
   \   00000050   0xE020             B.N      ??f_truncate_3
   3171          			} else {				/* When truncate a part of the file, remove remaining clusters */
   3172          				ncl = get_fat(fp->fs, fp->clust);
   \                     ??f_truncate_4:
   \   00000052   0x6961             LDR      R1,[R4, #+20]
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       get_fat
   \   0000005A   0x0005             MOVS     R5,R0
   3173          				res = FR_OK;
   \   0000005C   0x2000             MOVS     R0,#+0
   3174          				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \   0000005E   0xF115 0x0F01      CMN      R5,#+1
   \   00000062   0xD100             BNE.N    ??f_truncate_5
   \   00000064   0x2001             MOVS     R0,#+1
   3175          				if (ncl == 1) res = FR_INT_ERR;
   \                     ??f_truncate_5:
   \   00000066   0x2D01             CMP      R5,#+1
   \   00000068   0xD100             BNE.N    ??f_truncate_6
   \   0000006A   0x2002             MOVS     R0,#+2
   3176          				if (res == FR_OK && ncl < fp->fs->n_fatent) {
   \                     ??f_truncate_6:
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD110             BNE.N    ??f_truncate_3
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x69C9             LDR      R1,[R1, #+28]
   \   00000076   0x428D             CMP      R5,R1
   \   00000078   0xD20C             BCS.N    ??f_truncate_3
   3177          					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
   \   0000007A   0xF07F 0x4270      MVNS     R2,#-268435456
   \   0000007E   0x6961             LDR      R1,[R4, #+20]
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x.... 0x....      BL       put_fat
   3178          					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD103             BNE.N    ??f_truncate_3
   \   0000008C   0x0029             MOVS     R1,R5
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x.... 0x....      BL       remove_chain
   3179          				}
   3180          			}
   3181          		}
   3182          		if (res != FR_OK) fp->flag |= FA__ERROR;
   \                     ??f_truncate_3:
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD003             BEQ.N    ??f_truncate_2
   \   0000009A   0x79A1             LDRB     R1,[R4, #+6]
   \   0000009C   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   000000A0   0x71A1             STRB     R1,[R4, #+6]
   3183          	}
   3184          
   3185          	LEAVE_FF(fp->fs, res);
   \                     ??f_truncate_2:
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3186          }
   3187          
   3188          
   3189          
   3190          
   3191          /*-----------------------------------------------------------------------*/
   3192          /* Delete a File or Directory                                            */
   3193          /*-----------------------------------------------------------------------*/
   3194          

   \                                 In section .text, align 2, keep-with-next
   3195          FRESULT f_unlink (
   3196          	const TCHAR *path		/* Pointer to the file or directory path */
   3197          )
   3198          {
   \                     f_unlink:
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB095             SUB      SP,SP,#+84
   3199          	FRESULT res;
   3200          	DIR dj, sdj;
   3201          	BYTE *dir;
   3202          	DWORD dclst;
   3203          	DEF_NAMEBUF;
   3204          
   3205          
   3206          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0xA815             ADD      R0,SP,#+84
   \   0000000A   0x.... 0x....      BL       chk_mounted
   \   0000000E   0x0005             MOVS     R5,R0
   3207          	if (res == FR_OK) {
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD17A             BNE.N    ??f_unlink_0
   3208          		INIT_BUF(dj);
   \   00000016   0x2082             MOVS     R0,#+130
   \   00000018   0x.... 0x....      BL       ff_memalloc
   \   0000001C   0x0004             MOVS     R4,R0
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD101             BNE.N    ??f_unlink_1
   \   00000022   0x2011             MOVS     R0,#+17
   \   00000024   0xE074             B.N      ??f_unlink_2
   \                     ??f_unlink_1:
   \   00000026   0x9407             STR      R4,[SP, #+28]
   \   00000028   0xA809             ADD      R0,SP,#+36
   \   0000002A   0x9006             STR      R0,[SP, #+24]
   3209          		res = follow_path(&dj, path);		/* Follow the file path */
   \   0000002C   0x9915             LDR      R1,[SP, #+84]
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       follow_path
   \   00000034   0x0005             MOVS     R5,R0
   3210          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD104             BNE.N    ??f_unlink_3
   \   0000003C   0x9806             LDR      R0,[SP, #+24]
   \   0000003E   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000040   0x0680             LSLS     R0,R0,#+26
   \   00000042   0xD500             BPL.N    ??f_unlink_3
   3211          			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
   \   00000044   0x2506             MOVS     R5,#+6
   3212          #if _FS_SHARE
   3213          		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
   \                     ??f_unlink_3:
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD104             BNE.N    ??f_unlink_4
   \   0000004C   0x2102             MOVS     R1,#+2
   \   0000004E   0xA800             ADD      R0,SP,#+0
   \   00000050   0x.... 0x....      BL       chk_lock
   \   00000054   0x0005             MOVS     R5,R0
   3214          #endif
   3215          		if (res == FR_OK) {					/* The object is accessible */
   \                     ??f_unlink_4:
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x2D00             CMP      R5,#+0
   \   0000005A   0xD154             BNE.N    ??f_unlink_5
   3216          			dir = dj.dir;
   \   0000005C   0x9805             LDR      R0,[SP, #+20]
   3217          			if (!dir) {
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD101             BNE.N    ??f_unlink_6
   3218          				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
   \   00000062   0x2506             MOVS     R5,#+6
   \   00000064   0xE003             B.N      ??f_unlink_7
   3219          			} else {
   3220          				if (dir[DIR_Attr] & AM_RDO)
   \                     ??f_unlink_6:
   \   00000066   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000068   0x07C9             LSLS     R1,R1,#+31
   \   0000006A   0xD500             BPL.N    ??f_unlink_7
   3221          					res = FR_DENIED;		/* Cannot remove R/O object */
   \   0000006C   0x2507             MOVS     R5,#+7
   3222          			}
   3223          			dclst = LD_CLUST(dir);
   \                     ??f_unlink_7:
   \   0000006E   0x7D41             LDRB     R1,[R0, #+21]
   \   00000070   0x7D02             LDRB     R2,[R0, #+20]
   \   00000072   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000076   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000078   0x7EC2             LDRB     R2,[R0, #+27]
   \   0000007A   0x7E83             LDRB     R3,[R0, #+26]
   \   0000007C   0xEA53 0x2202      ORRS     R2,R3,R2, LSL #+8
   \   00000080   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000082   0xEA52 0x4601      ORRS     R6,R2,R1, LSL #+16
   3224          			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
   \   00000086   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000088   0x2D00             CMP      R5,#+0
   \   0000008A   0xD124             BNE.N    ??f_unlink_8
   \   0000008C   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000008E   0x06C0             LSLS     R0,R0,#+27
   \   00000090   0xD521             BPL.N    ??f_unlink_8
   3225          				if (dclst < 2) {
   \   00000092   0x2E02             CMP      R6,#+2
   \   00000094   0xD201             BCS.N    ??f_unlink_9
   3226          					res = FR_INT_ERR;
   \   00000096   0x2502             MOVS     R5,#+2
   \   00000098   0xE01D             B.N      ??f_unlink_8
   3227          				} else {
   3228          					mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
   \                     ??f_unlink_9:
   \   0000009A   0x2224             MOVS     R2,#+36
   \   0000009C   0xA900             ADD      R1,SP,#+0
   \   0000009E   0xA80C             ADD      R0,SP,#+48
   \   000000A0   0x.... 0x....      BL       mem_cpy
   3229          					sdj.sclust = dclst;
   \   000000A4   0x960E             STR      R6,[SP, #+56]
   3230          					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
   \   000000A6   0x2102             MOVS     R1,#+2
   \   000000A8   0xA80C             ADD      R0,SP,#+48
   \   000000AA   0x.... 0x....      BL       dir_sdi
   \   000000AE   0x0005             MOVS     R5,R0
   3231          					if (res == FR_OK) {
   \   000000B0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B2   0x2D00             CMP      R5,#+0
   \   000000B4   0xD10F             BNE.N    ??f_unlink_8
   3232          						res = dir_read(&sdj);
   \   000000B6   0xA80C             ADD      R0,SP,#+48
   \   000000B8   0x.... 0x....      BL       dir_read
   \   000000BC   0x0005             MOVS     R5,R0
   3233          						if (res == FR_OK			/* Not empty dir */
   3234          #if _FS_RPATH
   3235          						|| dclst == sdj.fs->cdir	/* Current dir */
   3236          #endif
   3237          						) res = FR_DENIED;
   \   000000BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C0   0x2D00             CMP      R5,#+0
   \   000000C2   0xD003             BEQ.N    ??f_unlink_10
   \   000000C4   0x980C             LDR      R0,[SP, #+48]
   \   000000C6   0x6980             LDR      R0,[R0, #+24]
   \   000000C8   0x4286             CMP      R6,R0
   \   000000CA   0xD100             BNE.N    ??f_unlink_11
   \                     ??f_unlink_10:
   \   000000CC   0x2507             MOVS     R5,#+7
   3238          						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
   \                     ??f_unlink_11:
   \   000000CE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D0   0x2D04             CMP      R5,#+4
   \   000000D2   0xD100             BNE.N    ??f_unlink_8
   \   000000D4   0x2500             MOVS     R5,#+0
   3239          					}
   3240          				}
   3241          			}
   3242          			if (res == FR_OK) {
   \                     ??f_unlink_8:
   \   000000D6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D8   0x2D00             CMP      R5,#+0
   \   000000DA   0xD114             BNE.N    ??f_unlink_5
   3243          				res = dir_remove(&dj);		/* Remove the directory entry */
   \   000000DC   0xA800             ADD      R0,SP,#+0
   \   000000DE   0x.... 0x....      BL       dir_remove
   \   000000E2   0x0005             MOVS     R5,R0
   3244          				if (res == FR_OK) {
   \   000000E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E6   0x2D00             CMP      R5,#+0
   \   000000E8   0xD10D             BNE.N    ??f_unlink_5
   3245          					if (dclst)				/* Remove the cluster chain if exist */
   \   000000EA   0x2E00             CMP      R6,#+0
   \   000000EC   0xD004             BEQ.N    ??f_unlink_12
   3246          						res = remove_chain(dj.fs, dclst);
   \   000000EE   0x0031             MOVS     R1,R6
   \   000000F0   0x9800             LDR      R0,[SP, #+0]
   \   000000F2   0x.... 0x....      BL       remove_chain
   \   000000F6   0x0005             MOVS     R5,R0
   3247          					if (res == FR_OK) res = sync(dj.fs);
   \                     ??f_unlink_12:
   \   000000F8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FA   0x2D00             CMP      R5,#+0
   \   000000FC   0xD103             BNE.N    ??f_unlink_5
   \   000000FE   0x9800             LDR      R0,[SP, #+0]
   \   00000100   0x.... 0x....      BL       sync
   \   00000104   0x0005             MOVS     R5,R0
   3248          				}
   3249          			}
   3250          		}
   3251          		FREE_BUF();
   \                     ??f_unlink_5:
   \   00000106   0x0020             MOVS     R0,R4
   \   00000108   0x.... 0x....      BL       ff_memfree
   3252          	}
   3253          	LEAVE_FF(dj.fs, res);
   \                     ??f_unlink_0:
   \   0000010C   0x0028             MOVS     R0,R5
   \   0000010E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_unlink_2:
   \   00000110   0xB016             ADD      SP,SP,#+88
   \   00000112   0xBD70             POP      {R4-R6,PC}       ;; return
   3254          }
   3255          
   3256          
   3257          
   3258          
   3259          /*-----------------------------------------------------------------------*/
   3260          /* Create a Directory                                                    */
   3261          /*-----------------------------------------------------------------------*/
   3262          

   \                                 In section .text, align 2, keep-with-next
   3263          FRESULT f_mkdir (
   3264          	const TCHAR *path		/* Pointer to the directory path */
   3265          )
   3266          {
   \                     f_mkdir:
   \   00000000   0xE92D 0x47F1      PUSH     {R0,R4-R10,LR}
   \   00000004   0xB08D             SUB      SP,SP,#+52
   3267          	FRESULT res;
   3268          	DIR dj;
   3269          	BYTE *dir, n;
   3270          	DWORD dsc, dcl, pcl, tim = get_fattime();
   \   00000006   0x.... 0x....      BL       get_fattime
   \   0000000A   0x0004             MOVS     R4,R0
   3271          	DEF_NAMEBUF;
   3272          
   3273          
   3274          	res = chk_mounted(&path, &dj.fs, 1);
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0xA80D             ADD      R0,SP,#+52
   \   00000012   0x.... 0x....      BL       chk_mounted
   \   00000016   0x0006             MOVS     R6,R0
   3275          	if (res == FR_OK) {
   \   00000018   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xF040 0x80ED      BNE.W    ??f_mkdir_0
   3276          		INIT_BUF(dj);
   \   00000020   0x2082             MOVS     R0,#+130
   \   00000022   0x.... 0x....      BL       ff_memalloc
   \   00000026   0x0005             MOVS     R5,R0
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD101             BNE.N    ??f_mkdir_1
   \   0000002C   0x2011             MOVS     R0,#+17
   \   0000002E   0xE0E6             B.N      ??f_mkdir_2
   \                     ??f_mkdir_1:
   \   00000030   0x9507             STR      R5,[SP, #+28]
   \   00000032   0xA809             ADD      R0,SP,#+36
   \   00000034   0x9006             STR      R0,[SP, #+24]
   3277          		res = follow_path(&dj, path);			/* Follow the file path */
   \   00000036   0x990D             LDR      R1,[SP, #+52]
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x.... 0x....      BL       follow_path
   \   0000003E   0x0006             MOVS     R6,R0
   3278          		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD100             BNE.N    ??f_mkdir_3
   \   00000046   0x2608             MOVS     R6,#+8
   3279          		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
   \                     ??f_mkdir_3:
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0x2E04             CMP      R6,#+4
   \   0000004C   0xD104             BNE.N    ??f_mkdir_4
   \   0000004E   0x9806             LDR      R0,[SP, #+24]
   \   00000050   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000052   0x0680             LSLS     R0,R0,#+26
   \   00000054   0xD500             BPL.N    ??f_mkdir_4
   3280          			res = FR_INVALID_NAME;
   \   00000056   0x2606             MOVS     R6,#+6
   3281          		if (res == FR_NO_FILE) {				/* Can create a new directory */
   \                     ??f_mkdir_4:
   \   00000058   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005A   0x2E04             CMP      R6,#+4
   \   0000005C   0xF040 0x80CA      BNE.W    ??f_mkdir_5
   3282          			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x.... 0x....      BL       create_chain
   \   00000068   0x0007             MOVS     R7,R0
   3283          			res = FR_OK;
   \   0000006A   0x2600             MOVS     R6,#+0
   3284          			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
   \   0000006C   0x2F00             CMP      R7,#+0
   \   0000006E   0xD100             BNE.N    ??f_mkdir_6
   \   00000070   0x2607             MOVS     R6,#+7
   3285          			if (dcl == 1) res = FR_INT_ERR;
   \                     ??f_mkdir_6:
   \   00000072   0x2F01             CMP      R7,#+1
   \   00000074   0xD100             BNE.N    ??f_mkdir_7
   \   00000076   0x2602             MOVS     R6,#+2
   3286          			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \                     ??f_mkdir_7:
   \   00000078   0xF117 0x0F01      CMN      R7,#+1
   \   0000007C   0xD100             BNE.N    ??f_mkdir_8
   \   0000007E   0x2601             MOVS     R6,#+1
   3287          			if (res == FR_OK)					/* Flush FAT */
   \                     ??f_mkdir_8:
   \   00000080   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000082   0x2E00             CMP      R6,#+0
   \   00000084   0xD104             BNE.N    ??f_mkdir_9
   3288          				res = move_window(dj.fs, 0);
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x9800             LDR      R0,[SP, #+0]
   \   0000008A   0x.... 0x....      BL       move_window
   \   0000008E   0x0006             MOVS     R6,R0
   3289          			if (res == FR_OK) {					/* Initialize the new directory table */
   \                     ??f_mkdir_9:
   \   00000090   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000092   0x2E00             CMP      R6,#+0
   \   00000094   0xD177             BNE.N    ??f_mkdir_10
   3290          				dsc = clust2sect(dj.fs, dcl);
   \   00000096   0x0039             MOVS     R1,R7
   \   00000098   0x9800             LDR      R0,[SP, #+0]
   \   0000009A   0x.... 0x....      BL       clust2sect
   \   0000009E   0x4680             MOV      R8,R0
   3291          				dir = dj.fs->win;
   \   000000A0   0x9800             LDR      R0,[SP, #+0]
   \   000000A2   0xF110 0x0934      ADDS     R9,R0,#+52
   3292          				mem_set(dir, 0, SS(dj.fs));
   \   000000A6   0xF44F 0x7200      MOV      R2,#+512
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x4648             MOV      R0,R9
   \   000000AE   0x.... 0x....      BL       mem_set
   3293          				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
   \   000000B2   0x220B             MOVS     R2,#+11
   \   000000B4   0x2120             MOVS     R1,#+32
   \   000000B6   0x4648             MOV      R0,R9
   \   000000B8   0x.... 0x....      BL       mem_set
   3294          				dir[DIR_Name] = '.';
   \   000000BC   0x202E             MOVS     R0,#+46
   \   000000BE   0xF889 0x0000      STRB     R0,[R9, #+0]
   3295          				dir[DIR_Attr] = AM_DIR;
   \   000000C2   0x2010             MOVS     R0,#+16
   \   000000C4   0xF889 0x000B      STRB     R0,[R9, #+11]
   3296          				ST_DWORD(dir+DIR_WrtTime, tim);
   \   000000C8   0xF889 0x4016      STRB     R4,[R9, #+22]
   \   000000CC   0x0020             MOVS     R0,R4
   \   000000CE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D0   0x0A00             LSRS     R0,R0,#+8
   \   000000D2   0xF889 0x0017      STRB     R0,[R9, #+23]
   \   000000D6   0x0C20             LSRS     R0,R4,#+16
   \   000000D8   0xF889 0x0018      STRB     R0,[R9, #+24]
   \   000000DC   0x0E20             LSRS     R0,R4,#+24
   \   000000DE   0xF889 0x0019      STRB     R0,[R9, #+25]
   3297          				ST_CLUST(dir, dcl);
   \   000000E2   0xF889 0x701A      STRB     R7,[R9, #+26]
   \   000000E6   0x0038             MOVS     R0,R7
   \   000000E8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000EA   0x0A00             LSRS     R0,R0,#+8
   \   000000EC   0xF889 0x001B      STRB     R0,[R9, #+27]
   \   000000F0   0x0C38             LSRS     R0,R7,#+16
   \   000000F2   0xF889 0x0014      STRB     R0,[R9, #+20]
   \   000000F6   0x0C38             LSRS     R0,R7,#+16
   \   000000F8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000FA   0x0A00             LSRS     R0,R0,#+8
   \   000000FC   0xF889 0x0015      STRB     R0,[R9, #+21]
   3298          				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
   \   00000100   0x2220             MOVS     R2,#+32
   \   00000102   0x4649             MOV      R1,R9
   \   00000104   0xF119 0x0020      ADDS     R0,R9,#+32
   \   00000108   0x.... 0x....      BL       mem_cpy
   3299          				dir[33] = '.'; pcl = dj.sclust;
   \   0000010C   0x202E             MOVS     R0,#+46
   \   0000010E   0xF889 0x0021      STRB     R0,[R9, #+33]
   \   00000112   0x9802             LDR      R0,[SP, #+8]
   3300          				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
   \   00000114   0x9900             LDR      R1,[SP, #+0]
   \   00000116   0x7809             LDRB     R1,[R1, #+0]
   \   00000118   0x2903             CMP      R1,#+3
   \   0000011A   0xD104             BNE.N    ??f_mkdir_11
   \   0000011C   0x9900             LDR      R1,[SP, #+0]
   \   0000011E   0x6A89             LDR      R1,[R1, #+40]
   \   00000120   0x4288             CMP      R0,R1
   \   00000122   0xD100             BNE.N    ??f_mkdir_11
   3301          					pcl = 0;
   \   00000124   0x2000             MOVS     R0,#+0
   3302          				ST_CLUST(dir+SZ_DIR, pcl);
   \                     ??f_mkdir_11:
   \   00000126   0xF889 0x003A      STRB     R0,[R9, #+58]
   \   0000012A   0x0001             MOVS     R1,R0
   \   0000012C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000012E   0x0A09             LSRS     R1,R1,#+8
   \   00000130   0xF889 0x103B      STRB     R1,[R9, #+59]
   \   00000134   0x0C01             LSRS     R1,R0,#+16
   \   00000136   0xF889 0x1034      STRB     R1,[R9, #+52]
   \   0000013A   0x0C00             LSRS     R0,R0,#+16
   \   0000013C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000013E   0x0A00             LSRS     R0,R0,#+8
   \   00000140   0xF889 0x0035      STRB     R0,[R9, #+53]
   3303          				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   \   00000144   0x9800             LDR      R0,[SP, #+0]
   \   00000146   0xF890 0xA002      LDRB     R10,[R0, #+2]
   \   0000014A   0xE007             B.N      ??f_mkdir_12
   3304          					dj.fs->winsect = dsc++;
   3305          					dj.fs->wflag = 1;
   3306          					res = move_window(dj.fs, 0);
   3307          					if (res != FR_OK) break;
   3308          					mem_set(dir, 0, SS(dj.fs));
   \                     ??f_mkdir_13:
   \   0000014C   0xF44F 0x7200      MOV      R2,#+512
   \   00000150   0x2100             MOVS     R1,#+0
   \   00000152   0x4648             MOV      R0,R9
   \   00000154   0x.... 0x....      BL       mem_set
   \   00000158   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \                     ??f_mkdir_12:
   \   0000015C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000160   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000164   0xD00F             BEQ.N    ??f_mkdir_10
   \   00000166   0x9800             LDR      R0,[SP, #+0]
   \   00000168   0xF8C0 0x8030      STR      R8,[R0, #+48]
   \   0000016C   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000170   0x9800             LDR      R0,[SP, #+0]
   \   00000172   0x2101             MOVS     R1,#+1
   \   00000174   0x7101             STRB     R1,[R0, #+4]
   \   00000176   0x2100             MOVS     R1,#+0
   \   00000178   0x9800             LDR      R0,[SP, #+0]
   \   0000017A   0x.... 0x....      BL       move_window
   \   0000017E   0x0006             MOVS     R6,R0
   \   00000180   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000182   0x2E00             CMP      R6,#+0
   \   00000184   0xD0E2             BEQ.N    ??f_mkdir_13
   3309          				}
   3310          			}
   3311          			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
   \                     ??f_mkdir_10:
   \   00000186   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000188   0x2E00             CMP      R6,#+0
   \   0000018A   0xD103             BNE.N    ??f_mkdir_14
   \   0000018C   0xA800             ADD      R0,SP,#+0
   \   0000018E   0x.... 0x....      BL       dir_register
   \   00000192   0x0006             MOVS     R6,R0
   3312          			if (res != FR_OK) {
   \                     ??f_mkdir_14:
   \   00000194   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000196   0x2E00             CMP      R6,#+0
   \   00000198   0xD004             BEQ.N    ??f_mkdir_15
   3313          				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
   \   0000019A   0x0039             MOVS     R1,R7
   \   0000019C   0x9800             LDR      R0,[SP, #+0]
   \   0000019E   0x.... 0x....      BL       remove_chain
   \   000001A2   0xE027             B.N      ??f_mkdir_5
   3314          			} else {
   3315          				dir = dj.dir;
   \                     ??f_mkdir_15:
   \   000001A4   0xF8DD 0x9014      LDR      R9,[SP, #+20]
   3316          				dir[DIR_Attr] = AM_DIR;				/* Attribute */
   \   000001A8   0x2010             MOVS     R0,#+16
   \   000001AA   0xF889 0x000B      STRB     R0,[R9, #+11]
   3317          				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
   \   000001AE   0xF889 0x4016      STRB     R4,[R9, #+22]
   \   000001B2   0x0020             MOVS     R0,R4
   \   000001B4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001B6   0x0A00             LSRS     R0,R0,#+8
   \   000001B8   0xF889 0x0017      STRB     R0,[R9, #+23]
   \   000001BC   0x0C20             LSRS     R0,R4,#+16
   \   000001BE   0xF889 0x0018      STRB     R0,[R9, #+24]
   \   000001C2   0x0E20             LSRS     R0,R4,#+24
   \   000001C4   0xF889 0x0019      STRB     R0,[R9, #+25]
   3318          				ST_CLUST(dir, dcl);					/* Table start cluster */
   \   000001C8   0xF889 0x701A      STRB     R7,[R9, #+26]
   \   000001CC   0x0038             MOVS     R0,R7
   \   000001CE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001D0   0x0A00             LSRS     R0,R0,#+8
   \   000001D2   0xF889 0x001B      STRB     R0,[R9, #+27]
   \   000001D6   0x0C38             LSRS     R0,R7,#+16
   \   000001D8   0xF889 0x0014      STRB     R0,[R9, #+20]
   \   000001DC   0x0C38             LSRS     R0,R7,#+16
   \   000001DE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001E0   0x0A00             LSRS     R0,R0,#+8
   \   000001E2   0xF889 0x0015      STRB     R0,[R9, #+21]
   3319          				dj.fs->wflag = 1;
   \   000001E6   0x9800             LDR      R0,[SP, #+0]
   \   000001E8   0x2101             MOVS     R1,#+1
   \   000001EA   0x7101             STRB     R1,[R0, #+4]
   3320          				res = sync(dj.fs);
   \   000001EC   0x9800             LDR      R0,[SP, #+0]
   \   000001EE   0x.... 0x....      BL       sync
   \   000001F2   0x0006             MOVS     R6,R0
   3321          			}
   3322          		}
   3323          		FREE_BUF();
   \                     ??f_mkdir_5:
   \   000001F4   0x0028             MOVS     R0,R5
   \   000001F6   0x.... 0x....      BL       ff_memfree
   3324          	}
   3325          
   3326          	LEAVE_FF(dj.fs, res);
   \                     ??f_mkdir_0:
   \   000001FA   0x0030             MOVS     R0,R6
   \   000001FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_mkdir_2:
   \   000001FE   0xB00E             ADD      SP,SP,#+56
   \   00000200   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   3327          }
   3328          
   3329          
   3330          
   3331          
   3332          /*-----------------------------------------------------------------------*/
   3333          /* Change Attribute                                                      */
   3334          /*-----------------------------------------------------------------------*/
   3335          

   \                                 In section .text, align 2, keep-with-next
   3336          FRESULT f_chmod (
   3337          	const TCHAR *path,	/* Pointer to the file path */
   3338          	BYTE value,			/* Attribute bits */
   3339          	BYTE mask			/* Attribute mask to change */
   3340          )
   3341          {
   \                     f_chmod:
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
   3342          	FRESULT res;
   3343          	DIR dj;
   3344          	BYTE *dir;
   3345          	DEF_NAMEBUF;
   3346          
   3347          
   3348          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0xA80C             ADD      R0,SP,#+48
   \   0000000E   0x.... 0x....      BL       chk_mounted
   \   00000012   0x0006             MOVS     R6,R0
   3349          	if (res == FR_OK) {
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD131             BNE.N    ??f_chmod_0
   3350          		INIT_BUF(dj);
   \   0000001A   0x2082             MOVS     R0,#+130
   \   0000001C   0x.... 0x....      BL       ff_memalloc
   \   00000020   0x0007             MOVS     R7,R0
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xD101             BNE.N    ??f_chmod_1
   \   00000026   0x2011             MOVS     R0,#+17
   \   00000028   0xE02B             B.N      ??f_chmod_2
   \                     ??f_chmod_1:
   \   0000002A   0x9707             STR      R7,[SP, #+28]
   \   0000002C   0xA809             ADD      R0,SP,#+36
   \   0000002E   0x9006             STR      R0,[SP, #+24]
   3351          		res = follow_path(&dj, path);		/* Follow the file path */
   \   00000030   0x990C             LDR      R1,[SP, #+48]
   \   00000032   0xA800             ADD      R0,SP,#+0
   \   00000034   0x.... 0x....      BL       follow_path
   \   00000038   0x0006             MOVS     R6,R0
   3352          		FREE_BUF();
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       ff_memfree
   3353          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD104             BNE.N    ??f_chmod_3
   \   00000046   0x9806             LDR      R0,[SP, #+24]
   \   00000048   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000004A   0x0680             LSLS     R0,R0,#+26
   \   0000004C   0xD500             BPL.N    ??f_chmod_3
   3354          			res = FR_INVALID_NAME;
   \   0000004E   0x2606             MOVS     R6,#+6
   3355          		if (res == FR_OK) {
   \                     ??f_chmod_3:
   \   00000050   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD113             BNE.N    ??f_chmod_0
   3356          			dir = dj.dir;
   \   00000056   0x9805             LDR      R0,[SP, #+20]
   3357          			if (!dir) {						/* Is it a root directory? */
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD101             BNE.N    ??f_chmod_4
   3358          				res = FR_INVALID_NAME;
   \   0000005C   0x2606             MOVS     R6,#+6
   \   0000005E   0xE00E             B.N      ??f_chmod_0
   3359          			} else {						/* File or sub directory */
   3360          				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   \                     ??f_chmod_4:
   \   00000060   0xF015 0x0527      ANDS     R5,R5,#0x27
   3361          				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   \   00000064   0xEA15 0x0104      ANDS     R1,R5,R4
   \   00000068   0x7AC2             LDRB     R2,[R0, #+11]
   \   0000006A   0x43AA             BICS     R2,R2,R5
   \   0000006C   0x4311             ORRS     R1,R2,R1
   \   0000006E   0x72C1             STRB     R1,[R0, #+11]
   3362          				dj.fs->wflag = 1;
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0x2101             MOVS     R1,#+1
   \   00000074   0x7101             STRB     R1,[R0, #+4]
   3363          				res = sync(dj.fs);
   \   00000076   0x9800             LDR      R0,[SP, #+0]
   \   00000078   0x.... 0x....      BL       sync
   \   0000007C   0x0006             MOVS     R6,R0
   3364          			}
   3365          		}
   3366          	}
   3367          
   3368          	LEAVE_FF(dj.fs, res);
   \                     ??f_chmod_0:
   \   0000007E   0x0030             MOVS     R0,R6
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_chmod_2:
   \   00000082   0xB00D             ADD      SP,SP,#+52
   \   00000084   0xBDF0             POP      {R4-R7,PC}       ;; return
   3369          }
   3370          
   3371          
   3372          
   3373          
   3374          /*-----------------------------------------------------------------------*/
   3375          /* Change Timestamp                                                      */
   3376          /*-----------------------------------------------------------------------*/
   3377          

   \                                 In section .text, align 2, keep-with-next
   3378          FRESULT f_utime (
   3379          	const TCHAR *path,	/* Pointer to the file/directory name */
   3380          	const FILINFO *fno	/* Pointer to the time stamp to be set */
   3381          )
   3382          {
   \                     f_utime:
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x000C             MOVS     R4,R1
   3383          	FRESULT res;
   3384          	DIR dj;
   3385          	BYTE *dir;
   3386          	DEF_NAMEBUF;
   3387          
   3388          
   3389          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0xA80D             ADD      R0,SP,#+52
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0005             MOVS     R5,R0
   3390          	if (res == FR_OK) {
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD135             BNE.N    ??f_utime_0
   3391          		INIT_BUF(dj);
   \   00000018   0x2082             MOVS     R0,#+130
   \   0000001A   0x.... 0x....      BL       ff_memalloc
   \   0000001E   0x0006             MOVS     R6,R0
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD101             BNE.N    ??f_utime_1
   \   00000024   0x2011             MOVS     R0,#+17
   \   00000026   0xE02F             B.N      ??f_utime_2
   \                     ??f_utime_1:
   \   00000028   0x9607             STR      R6,[SP, #+28]
   \   0000002A   0xA809             ADD      R0,SP,#+36
   \   0000002C   0x9006             STR      R0,[SP, #+24]
   3392          		res = follow_path(&dj, path);	/* Follow the file path */
   \   0000002E   0x990D             LDR      R1,[SP, #+52]
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0x.... 0x....      BL       follow_path
   \   00000036   0x0005             MOVS     R5,R0
   3393          		FREE_BUF();
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0x.... 0x....      BL       ff_memfree
   3394          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD104             BNE.N    ??f_utime_3
   \   00000044   0x9806             LDR      R0,[SP, #+24]
   \   00000046   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000048   0x0680             LSLS     R0,R0,#+26
   \   0000004A   0xD500             BPL.N    ??f_utime_3
   3395          			res = FR_INVALID_NAME;
   \   0000004C   0x2506             MOVS     R5,#+6
   3396          		if (res == FR_OK) {
   \                     ??f_utime_3:
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD117             BNE.N    ??f_utime_0
   3397          			dir = dj.dir;
   \   00000054   0x9805             LDR      R0,[SP, #+20]
   3398          			if (!dir) {					/* Root directory */
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD101             BNE.N    ??f_utime_4
   3399          				res = FR_INVALID_NAME;
   \   0000005A   0x2506             MOVS     R5,#+6
   \   0000005C   0xE012             B.N      ??f_utime_0
   3400          			} else {					/* File or sub-directory */
   3401          				ST_WORD(dir+DIR_WrtTime, fno->ftime);
   \                     ??f_utime_4:
   \   0000005E   0x88E1             LDRH     R1,[R4, #+6]
   \   00000060   0x7581             STRB     R1,[R0, #+22]
   \   00000062   0x88E1             LDRH     R1,[R4, #+6]
   \   00000064   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000066   0x0A09             LSRS     R1,R1,#+8
   \   00000068   0x75C1             STRB     R1,[R0, #+23]
   3402          				ST_WORD(dir+DIR_WrtDate, fno->fdate);
   \   0000006A   0x88A1             LDRH     R1,[R4, #+4]
   \   0000006C   0x7601             STRB     R1,[R0, #+24]
   \   0000006E   0x88A1             LDRH     R1,[R4, #+4]
   \   00000070   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000072   0x0A09             LSRS     R1,R1,#+8
   \   00000074   0x7641             STRB     R1,[R0, #+25]
   3403          				dj.fs->wflag = 1;
   \   00000076   0x9800             LDR      R0,[SP, #+0]
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0x7101             STRB     R1,[R0, #+4]
   3404          				res = sync(dj.fs);
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   \   0000007E   0x.... 0x....      BL       sync
   \   00000082   0x0005             MOVS     R5,R0
   3405          			}
   3406          		}
   3407          	}
   3408          
   3409          	LEAVE_FF(dj.fs, res);
   \                     ??f_utime_0:
   \   00000084   0x0028             MOVS     R0,R5
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_utime_2:
   \   00000088   0xB00E             ADD      SP,SP,#+56
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
   3410          }
   3411          
   3412          
   3413          
   3414          
   3415          /*-----------------------------------------------------------------------*/
   3416          /* Rename File/Directory                                                 */
   3417          /*-----------------------------------------------------------------------*/
   3418          

   \                                 In section .text, align 2, keep-with-next
   3419          FRESULT f_rename (
   3420          	const TCHAR *path_old,	/* Pointer to the old name */
   3421          	const TCHAR *path_new	/* Pointer to the new name */
   3422          )
   3423          {
   \                     f_rename:
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB09B             SUB      SP,SP,#+108
   \   00000004   0x000C             MOVS     R4,R1
   3424          	FRESULT res;
   3425          	DIR djo, djn;
   3426          	BYTE buf[21], *dir;
   3427          	DWORD dw;
   3428          	DEF_NAMEBUF;
   3429          
   3430          
   3431          	res = chk_mounted(&path_old, &djo.fs, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA909             ADD      R1,SP,#+36
   \   0000000A   0xA81B             ADD      R0,SP,#+108
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0006             MOVS     R6,R0
   3432          	if (res == FR_OK) {
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xF040 0x80AD      BNE.W    ??f_rename_0
   3433          		djn.fs = djo.fs;
   \   0000001A   0x9809             LDR      R0,[SP, #+36]
   \   0000001C   0x9000             STR      R0,[SP, #+0]
   3434          		INIT_BUF(djo);
   \   0000001E   0x2082             MOVS     R0,#+130
   \   00000020   0x.... 0x....      BL       ff_memalloc
   \   00000024   0x0005             MOVS     R5,R0
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD101             BNE.N    ??f_rename_1
   \   0000002A   0x2011             MOVS     R0,#+17
   \   0000002C   0xE0A4             B.N      ??f_rename_2
   \                     ??f_rename_1:
   \   0000002E   0x9510             STR      R5,[SP, #+64]
   \   00000030   0xA812             ADD      R0,SP,#+72
   \   00000032   0x900F             STR      R0,[SP, #+60]
   3435          		res = follow_path(&djo, path_old);		/* Check old object */
   \   00000034   0x991B             LDR      R1,[SP, #+108]
   \   00000036   0xA809             ADD      R0,SP,#+36
   \   00000038   0x.... 0x....      BL       follow_path
   \   0000003C   0x0006             MOVS     R6,R0
   3436          		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
   \   0000003E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0xD104             BNE.N    ??f_rename_3
   \   00000044   0x980F             LDR      R0,[SP, #+60]
   \   00000046   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000048   0x0680             LSLS     R0,R0,#+26
   \   0000004A   0xD500             BPL.N    ??f_rename_3
   3437          			res = FR_INVALID_NAME;
   \   0000004C   0x2606             MOVS     R6,#+6
   3438          #if _FS_SHARE
   3439          		if (res == FR_OK) res = chk_lock(&djo, 2);
   \                     ??f_rename_3:
   \   0000004E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD104             BNE.N    ??f_rename_4
   \   00000054   0x2102             MOVS     R1,#+2
   \   00000056   0xA809             ADD      R0,SP,#+36
   \   00000058   0x.... 0x....      BL       chk_lock
   \   0000005C   0x0006             MOVS     R6,R0
   3440          #endif
   3441          		if (res == FR_OK) {						/* Old object is found */
   \                     ??f_rename_4:
   \   0000005E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000060   0x2E00             CMP      R6,#+0
   \   00000062   0xF040 0x8084      BNE.W    ??f_rename_5
   3442          			if (!djo.dir) {						/* Is root dir? */
   \   00000066   0x980E             LDR      R0,[SP, #+56]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD101             BNE.N    ??f_rename_6
   3443          				res = FR_NO_FILE;
   \   0000006C   0x2604             MOVS     R6,#+4
   \   0000006E   0xE07E             B.N      ??f_rename_5
   3444          			} else {
   3445          				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
   \                     ??f_rename_6:
   \   00000070   0x2215             MOVS     R2,#+21
   \   00000072   0x980E             LDR      R0,[SP, #+56]
   \   00000074   0xF110 0x010B      ADDS     R1,R0,#+11
   \   00000078   0xA815             ADD      R0,SP,#+84
   \   0000007A   0x.... 0x....      BL       mem_cpy
   3446          				mem_cpy(&djn, &djo, sizeof(DIR));		/* Check new object */
   \   0000007E   0x2224             MOVS     R2,#+36
   \   00000080   0xA909             ADD      R1,SP,#+36
   \   00000082   0xA800             ADD      R0,SP,#+0
   \   00000084   0x.... 0x....      BL       mem_cpy
   3447          				res = follow_path(&djn, path_new);
   \   00000088   0x0021             MOVS     R1,R4
   \   0000008A   0xA800             ADD      R0,SP,#+0
   \   0000008C   0x.... 0x....      BL       follow_path
   \   00000090   0x0006             MOVS     R6,R0
   3448          				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
   \   00000092   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000094   0x2E00             CMP      R6,#+0
   \   00000096   0xD100             BNE.N    ??f_rename_7
   \   00000098   0x2608             MOVS     R6,#+8
   3449          				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
   \                     ??f_rename_7:
   \   0000009A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009C   0x2E04             CMP      R6,#+4
   \   0000009E   0xD166             BNE.N    ??f_rename_5
   3450          /* Start critical section that any interruption or error can cause cross-link */
   3451          					res = dir_register(&djn);			/* Register the new entry */
   \   000000A0   0xA800             ADD      R0,SP,#+0
   \   000000A2   0x.... 0x....      BL       dir_register
   \   000000A6   0x0006             MOVS     R6,R0
   3452          					if (res == FR_OK) {
   \   000000A8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AA   0x2E00             CMP      R6,#+0
   \   000000AC   0xD15F             BNE.N    ??f_rename_5
   3453          						dir = djn.dir;					/* Copy object information except for name */
   \   000000AE   0x9C05             LDR      R4,[SP, #+20]
   3454          						mem_cpy(dir+13, buf+2, 19);
   \   000000B0   0x2213             MOVS     R2,#+19
   \   000000B2   0xF10D 0x0156      ADD      R1,SP,#+86
   \   000000B6   0xF114 0x000D      ADDS     R0,R4,#+13
   \   000000BA   0x.... 0x....      BL       mem_cpy
   3455          						dir[DIR_Attr] = buf[0] | AM_ARC;
   \   000000BE   0xF89D 0x0054      LDRB     R0,[SP, #+84]
   \   000000C2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000C6   0x72E0             STRB     R0,[R4, #+11]
   3456          						djo.fs->wflag = 1;
   \   000000C8   0x9809             LDR      R0,[SP, #+36]
   \   000000CA   0x2101             MOVS     R1,#+1
   \   000000CC   0x7101             STRB     R1,[R0, #+4]
   3457          						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
   \   000000CE   0x980B             LDR      R0,[SP, #+44]
   \   000000D0   0x9902             LDR      R1,[SP, #+8]
   \   000000D2   0x4288             CMP      R0,R1
   \   000000D4   0xD03D             BEQ.N    ??f_rename_8
   \   000000D6   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000D8   0x06C0             LSLS     R0,R0,#+27
   \   000000DA   0xD53A             BPL.N    ??f_rename_8
   3458          							dw = clust2sect(djn.fs, LD_CLUST(dir));
   \   000000DC   0x7D60             LDRB     R0,[R4, #+21]
   \   000000DE   0x7D21             LDRB     R1,[R4, #+20]
   \   000000E0   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000E4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E6   0x7EE1             LDRB     R1,[R4, #+27]
   \   000000E8   0x7EA2             LDRB     R2,[R4, #+26]
   \   000000EA   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   000000EE   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000F0   0xEA51 0x4100      ORRS     R1,R1,R0, LSL #+16
   \   000000F4   0x9800             LDR      R0,[SP, #+0]
   \   000000F6   0x.... 0x....      BL       clust2sect
   3459          							if (!dw) {
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD101             BNE.N    ??f_rename_9
   3460          								res = FR_INT_ERR;
   \   000000FE   0x2602             MOVS     R6,#+2
   \   00000100   0xE027             B.N      ??f_rename_8
   3461          							} else {
   3462          								res = move_window(djn.fs, dw);
   \                     ??f_rename_9:
   \   00000102   0x0001             MOVS     R1,R0
   \   00000104   0x9800             LDR      R0,[SP, #+0]
   \   00000106   0x.... 0x....      BL       move_window
   \   0000010A   0x0006             MOVS     R6,R0
   3463          								dir = djn.fs->win+SZ_DIR;	/* .. entry */
   \   0000010C   0x9800             LDR      R0,[SP, #+0]
   \   0000010E   0xF110 0x0454      ADDS     R4,R0,#+84
   3464          								if (res == FR_OK && dir[1] == '.') {
   \   00000112   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000114   0x2E00             CMP      R6,#+0
   \   00000116   0xD11C             BNE.N    ??f_rename_8
   \   00000118   0x7860             LDRB     R0,[R4, #+1]
   \   0000011A   0x282E             CMP      R0,#+46
   \   0000011C   0xD119             BNE.N    ??f_rename_8
   3465          									dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
   \   0000011E   0x9800             LDR      R0,[SP, #+0]
   \   00000120   0x7800             LDRB     R0,[R0, #+0]
   \   00000122   0x2803             CMP      R0,#+3
   \   00000124   0xD106             BNE.N    ??f_rename_10
   \   00000126   0x9802             LDR      R0,[SP, #+8]
   \   00000128   0x9900             LDR      R1,[SP, #+0]
   \   0000012A   0x6A89             LDR      R1,[R1, #+40]
   \   0000012C   0x4288             CMP      R0,R1
   \   0000012E   0xD101             BNE.N    ??f_rename_10
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0xE000             B.N      ??f_rename_11
   \                     ??f_rename_10:
   \   00000134   0x9802             LDR      R0,[SP, #+8]
   3466          									ST_CLUST(dir, dw);
   \                     ??f_rename_11:
   \   00000136   0x76A0             STRB     R0,[R4, #+26]
   \   00000138   0x0001             MOVS     R1,R0
   \   0000013A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000013C   0x0A09             LSRS     R1,R1,#+8
   \   0000013E   0x76E1             STRB     R1,[R4, #+27]
   \   00000140   0x0C01             LSRS     R1,R0,#+16
   \   00000142   0x7521             STRB     R1,[R4, #+20]
   \   00000144   0x0C00             LSRS     R0,R0,#+16
   \   00000146   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000148   0x0A00             LSRS     R0,R0,#+8
   \   0000014A   0x7560             STRB     R0,[R4, #+21]
   3467          									djn.fs->wflag = 1;
   \   0000014C   0x9800             LDR      R0,[SP, #+0]
   \   0000014E   0x2101             MOVS     R1,#+1
   \   00000150   0x7101             STRB     R1,[R0, #+4]
   3468          								}
   3469          							}
   3470          						}
   3471          						if (res == FR_OK) {
   \                     ??f_rename_8:
   \   00000152   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000154   0x2E00             CMP      R6,#+0
   \   00000156   0xD10A             BNE.N    ??f_rename_5
   3472          							res = dir_remove(&djo);		/* Remove old entry */
   \   00000158   0xA809             ADD      R0,SP,#+36
   \   0000015A   0x.... 0x....      BL       dir_remove
   \   0000015E   0x0006             MOVS     R6,R0
   3473          							if (res == FR_OK)
   \   00000160   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000162   0x2E00             CMP      R6,#+0
   \   00000164   0xD103             BNE.N    ??f_rename_5
   3474          								res = sync(djo.fs);
   \   00000166   0x9809             LDR      R0,[SP, #+36]
   \   00000168   0x.... 0x....      BL       sync
   \   0000016C   0x0006             MOVS     R6,R0
   3475          						}
   3476          					}
   3477          /* End critical section */
   3478          				}
   3479          			}
   3480          		}
   3481          		FREE_BUF();
   \                     ??f_rename_5:
   \   0000016E   0x0028             MOVS     R0,R5
   \   00000170   0x.... 0x....      BL       ff_memfree
   3482          	}
   3483          	LEAVE_FF(djo.fs, res);
   \                     ??f_rename_0:
   \   00000174   0x0030             MOVS     R0,R6
   \   00000176   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_rename_2:
   \   00000178   0xB01C             ADD      SP,SP,#+112
   \   0000017A   0xBD70             POP      {R4-R6,PC}       ;; return
   3484          }
   3485          
   3486          #endif /* !_FS_READONLY */
   3487          #endif /* _FS_MINIMIZE == 0 */
   3488          #endif /* _FS_MINIMIZE <= 1 */
   3489          #endif /* _FS_MINIMIZE <= 2 */
   3490          
   3491          
   3492          
   3493          /*-----------------------------------------------------------------------*/
   3494          /* Forward data to the stream directly (available on only tiny cfg)      */
   3495          /*-----------------------------------------------------------------------*/
   3496          #if _USE_FORWARD && _FS_TINY
   3497          
   3498          FRESULT f_forward (
   3499          	FIL *fp, 						/* Pointer to the file object */
   3500          	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
   3501          	UINT btr,						/* Number of bytes to forward */
   3502          	UINT *bf						/* Pointer to number of bytes forwarded */
   3503          )
   3504          {
   3505          	FRESULT res;
   3506          	DWORD remain, clst, sect;
   3507          	UINT rcnt;
   3508          	BYTE csect;
   3509          
   3510          
   3511          	*bf = 0;	/* Initialize byte counter */
   3512          
   3513          	res = validate(fp->fs, fp->id);					/* Check validity of the object */
   3514          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   3515          	if (fp->flag & FA__ERROR)						/* Check error flag */
   3516          		LEAVE_FF(fp->fs, FR_INT_ERR);
   3517          	if (!(fp->flag & FA_READ))						/* Check access mode */
   3518          		LEAVE_FF(fp->fs, FR_DENIED);
   3519          
   3520          	remain = fp->fsize - fp->fptr;
   3521          	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
   3522          
   3523          	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
   3524          		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
   3525          		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   3526          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   3527          			if (!csect) {							/* On the cluster boundary? */
   3528          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   3529          					fp->sclust : get_fat(fp->fs, fp->clust);
   3530          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   3531          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3532          				fp->clust = clst;					/* Update current cluster */
   3533          			}
   3534          		}
   3535          		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
   3536          		if (!sect) ABORT(fp->fs, FR_INT_ERR);
   3537          		sect += csect;
   3538          		if (move_window(fp->fs, sect))				/* Move sector window */
   3539          			ABORT(fp->fs, FR_DISK_ERR);
   3540          		fp->dsect = sect;
   3541          		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
   3542          		if (rcnt > btr) rcnt = btr;
   3543          		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
   3544          		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
   3545          	}
   3546          
   3547          	LEAVE_FF(fp->fs, FR_OK);
   3548          }
   3549          #endif /* _USE_FORWARD */
   3550          
   3551          
   3552          
   3553          #if _USE_MKFS && !_FS_READONLY
   3554          /*-----------------------------------------------------------------------*/
   3555          /* Create File System on the Drive                                       */
   3556          /*-----------------------------------------------------------------------*/
   3557          #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
   3558          #define N_FATS		1		/* Number of FAT copies (1 or 2) */
   3559          
   3560          

   \                                 In section .text, align 2, keep-with-next
   3561          FRESULT f_mkfs (
   3562          	BYTE drv,		/* Logical drive number */
   3563          	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
   3564          	UINT au			/* Allocation unit size [bytes] */
   3565          )
   3566          {
   \                     f_mkfs:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x468B             MOV      R11,R1
   \   00000008   0x0014             MOVS     R4,R2
   3567          	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
   3568          	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
   3569          	BYTE fmt, md, sys, *tbl, pdrv, part;
   3570          	DWORD n_clst, vs, n, wsect;
   3571          	UINT i;
   3572          	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
   3573          	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
   3574          	FATFS *fs;
   3575          	DSTATUS stat;
   3576          
   3577          
   3578          	/* Check mounted drive and clear work area */
   3579          	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD301             BCC.N    ??f_mkfs_0
   \   00000010   0x200B             MOVS     R0,#+11
   \   00000012   0xE352             B.N      ??f_mkfs_1
   3580          	if (sfd > 1) return FR_INVALID_PARAMETER;
   \                     ??f_mkfs_0:
   \   00000014   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000018   0xF1BB 0x0F02      CMP      R11,#+2
   \   0000001C   0xD301             BCC.N    ??f_mkfs_2
   \   0000001E   0x2013             MOVS     R0,#+19
   \   00000020   0xE34B             B.N      ??f_mkfs_1
   3581          	if (au & (au - 1)) return FR_INVALID_PARAMETER;
   \                     ??f_mkfs_2:
   \   00000022   0x1E61             SUBS     R1,R4,#+1
   \   00000024   0x420C             TST      R4,R1
   \   00000026   0xD001             BEQ.N    ??f_mkfs_3
   \   00000028   0x2013             MOVS     R0,#+19
   \   0000002A   0xE346             B.N      ??f_mkfs_1
   3582          	fs = FatFs[drv];
   \                     ??f_mkfs_3:
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000032   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000036   0x9103             STR      R1,[SP, #+12]
   3583          	if (!fs) return FR_NOT_ENABLED;
   \   00000038   0x9903             LDR      R1,[SP, #+12]
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xD101             BNE.N    ??f_mkfs_4
   \   0000003E   0x200C             MOVS     R0,#+12
   \   00000040   0xE33B             B.N      ??f_mkfs_1
   3584          	fs->fs_type = 0;
   \                     ??f_mkfs_4:
   \   00000042   0x9903             LDR      R1,[SP, #+12]
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x700A             STRB     R2,[R1, #+0]
   3585          	pdrv = LD2PD(drv);	/* Physical drive */
   \   00000048   0xF88D 0x0008      STRB     R0,[SP, #+8]
   3586          	part = LD2PT(drv);	/* Partition (0:auto detect, 1-4:get from partition table)*/
   \   0000004C   0x2500             MOVS     R5,#+0
   3587          
   3588          	/* Get disk statics */
   3589          	stat = LPLD_Disk_Initialize(pdrv);
   \   0000004E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000052   0x.... 0x....      BL       LPLD_Disk_Initialize
   3590          	if (stat & STA_NOINIT) return FR_NOT_READY;
   \   00000056   0x07C1             LSLS     R1,R0,#+31
   \   00000058   0xD501             BPL.N    ??f_mkfs_5
   \   0000005A   0x2003             MOVS     R0,#+3
   \   0000005C   0xE32D             B.N      ??f_mkfs_1
   3591          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   \                     ??f_mkfs_5:
   \   0000005E   0x0740             LSLS     R0,R0,#+29
   \   00000060   0xD501             BPL.N    ??f_mkfs_6
   \   00000062   0x200A             MOVS     R0,#+10
   \   00000064   0xE329             B.N      ??f_mkfs_1
   3592          #if _MAX_SS != 512					/* Get disk sector size */
   3593          	if (LPLD_Disk_IOC(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
   3594          		return FR_DISK_ERR;
   3595          #endif
   3596          	if (_MULTI_PARTITION && part) {
   3597          		/* Get partition information from partition table in the MBR */
   3598          		if (LPLD_Disk_Read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   3599          		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
   3600          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   3601          		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
   3602          		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
   3603          		n_vol = LD_DWORD(tbl+12);	/* Volume size */
   3604          	} else {
   3605          		/* Create a partition in this function */
   3606          		if (LPLD_Disk_IOC(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
   \                     ??f_mkfs_6:
   \   00000066   0xAA01             ADD      R2,SP,#+4
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000006E   0x.... 0x....      BL       LPLD_Disk_IOC
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD102             BNE.N    ??f_mkfs_7
   \   00000076   0x9801             LDR      R0,[SP, #+4]
   \   00000078   0x2880             CMP      R0,#+128
   \   0000007A   0xD201             BCS.N    ??f_mkfs_8
   3607          			return FR_DISK_ERR;
   \                     ??f_mkfs_7:
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xE31C             B.N      ??f_mkfs_1
   3608          		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
   \                     ??f_mkfs_8:
   \   00000080   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000084   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000088   0xD001             BEQ.N    ??f_mkfs_9
   \   0000008A   0x2700             MOVS     R7,#+0
   \   0000008C   0xE000             B.N      ??f_mkfs_10
   \                     ??f_mkfs_9:
   \   0000008E   0x273F             MOVS     R7,#+63
   3609          		n_vol -= b_vol;				/* Volume size */
   \                     ??f_mkfs_10:
   \   00000090   0x9801             LDR      R0,[SP, #+4]
   \   00000092   0x1BC0             SUBS     R0,R0,R7
   \   00000094   0x9001             STR      R0,[SP, #+4]
   3610          	}
   3611          
   3612          	if (!au) {				/* AU auto selection */
   \   00000096   0x2C00             CMP      R4,#+0
   \   00000098   0xD113             BNE.N    ??f_mkfs_11
   3613          		vs = n_vol / (2000 / (SS(fs) / 512));
   \   0000009A   0x9801             LDR      R0,[SP, #+4]
   \   0000009C   0xF44F 0x61FA      MOV      R1,#+2000
   \   000000A0   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   3614          		for (i = 0; vs < vst[i]; i++) ;
   \   000000A4   0xF05F 0x0A00      MOVS     R10,#+0
   \   000000A8   0xE001             B.N      ??f_mkfs_12
   \                     ??f_mkfs_13:
   \   000000AA   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??f_mkfs_12:
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   000000B2   0xF831 0x101A      LDRH     R1,[R1, R10, LSL #+1]
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xD3F7             BCC.N    ??f_mkfs_13
   3615          		au = cst[i];
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000000BE   0xF830 0x401A      LDRH     R4,[R0, R10, LSL #+1]
   3616          	}
   3617          	au /= SS(fs);		/* Number of sectors per cluster */
   \                     ??f_mkfs_11:
   \   000000C2   0x0A64             LSRS     R4,R4,#+9
   3618          	if (au == 0) au = 1;
   \   000000C4   0x2C00             CMP      R4,#+0
   \   000000C6   0xD100             BNE.N    ??f_mkfs_14
   \   000000C8   0x2401             MOVS     R4,#+1
   3619          	if (au > 128) au = 128;
   \                     ??f_mkfs_14:
   \   000000CA   0x2C81             CMP      R4,#+129
   \   000000CC   0xD300             BCC.N    ??f_mkfs_15
   \   000000CE   0x2480             MOVS     R4,#+128
   3620          
   3621          	/* Pre-compute number of clusters and FAT syb-type */
   3622          	n_clst = n_vol / au;
   \                     ??f_mkfs_15:
   \   000000D0   0x9801             LDR      R0,[SP, #+4]
   \   000000D2   0xFBB0 0xF6F4      UDIV     R6,R0,R4
   3623          	fmt = FS_FAT12;
   \   000000D6   0x2501             MOVS     R5,#+1
   3624          	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
   \   000000D8   0xF640 0x70F6      MOVW     R0,#+4086
   \   000000DC   0x4286             CMP      R6,R0
   \   000000DE   0xD300             BCC.N    ??f_mkfs_16
   \   000000E0   0x2502             MOVS     R5,#+2
   3625          	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
   \                     ??f_mkfs_16:
   \   000000E2   0xF64F 0x70F6      MOVW     R0,#+65526
   \   000000E6   0x4286             CMP      R6,R0
   \   000000E8   0xD300             BCC.N    ??f_mkfs_17
   \   000000EA   0x2503             MOVS     R5,#+3
   3626          
   3627          	/* Determine offset and size of FAT structure */
   3628          	if (fmt == FS_FAT32) {
   \                     ??f_mkfs_17:
   \   000000EC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000EE   0x2D03             CMP      R5,#+3
   \   000000F0   0xD109             BNE.N    ??f_mkfs_18
   3629          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   \   000000F2   0x00B0             LSLS     R0,R6,#+2
   \   000000F4   0xF200 0x2007      ADDW     R0,R0,#+519
   \   000000F8   0xEA5F 0x2950      LSRS     R9,R0,#+9
   3630          		n_rsv = 32;
   \   000000FC   0xF05F 0x0820      MOVS     R8,#+32
   3631          		n_dir = 0;
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x9004             STR      R0,[SP, #+16]
   \   00000104   0xE015             B.N      ??f_mkfs_19
   3632          	} else {
   3633          		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
   \                     ??f_mkfs_18:
   \   00000106   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000108   0x2D01             CMP      R5,#+1
   \   0000010A   0xD107             BNE.N    ??f_mkfs_20
   \   0000010C   0x2003             MOVS     R0,#+3
   \   0000010E   0xFB00 0xF006      MUL      R0,R0,R6
   \   00000112   0x1C40             ADDS     R0,R0,#+1
   \   00000114   0x0840             LSRS     R0,R0,#+1
   \   00000116   0xF110 0x0903      ADDS     R9,R0,#+3
   \   0000011A   0xE002             B.N      ??f_mkfs_21
   \                     ??f_mkfs_20:
   \   0000011C   0x0070             LSLS     R0,R6,#+1
   \   0000011E   0xF110 0x0904      ADDS     R9,R0,#+4
   3634          		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
   \                     ??f_mkfs_21:
   \   00000122   0xF209 0x10FF      ADDW     R0,R9,#+511
   \   00000126   0xEA5F 0x2950      LSRS     R9,R0,#+9
   3635          		n_rsv = 1;
   \   0000012A   0xF05F 0x0801      MOVS     R8,#+1
   3636          		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
   \   0000012E   0x2020             MOVS     R0,#+32
   \   00000130   0x9004             STR      R0,[SP, #+16]
   3637          	}
   3638          	b_fat = b_vol + n_rsv;				/* FAT area start sector */
   \                     ??f_mkfs_19:
   \   00000132   0xEB18 0x0007      ADDS     R0,R8,R7
   \   00000136   0x9005             STR      R0,[SP, #+20]
   3639          	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
   \   00000138   0x9805             LDR      R0,[SP, #+20]
   \   0000013A   0xEB19 0x0000      ADDS     R0,R9,R0
   3640          	b_data = b_dir + n_dir;				/* Data area start sector */
   \   0000013E   0x9904             LDR      R1,[SP, #+16]
   \   00000140   0x180E             ADDS     R6,R1,R0
   3641          	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
   \   00000142   0x9801             LDR      R0,[SP, #+4]
   \   00000144   0x19A1             ADDS     R1,R4,R6
   \   00000146   0x1BC9             SUBS     R1,R1,R7
   \   00000148   0x4288             CMP      R0,R1
   \   0000014A   0xD201             BCS.N    ??f_mkfs_22
   \   0000014C   0x200E             MOVS     R0,#+14
   \   0000014E   0xE2B4             B.N      ??f_mkfs_1
   3642          
   3643          	/* Align data start sector to erase block boundary (for flash memory media) */
   3644          	if (LPLD_Disk_IOC(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
   \                     ??f_mkfs_22:
   \   00000150   0xAA00             ADD      R2,SP,#+0
   \   00000152   0x2103             MOVS     R1,#+3
   \   00000154   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000158   0x.... 0x....      BL       LPLD_Disk_IOC
   \   0000015C   0x2800             CMP      R0,#+0
   \   0000015E   0xD106             BNE.N    ??f_mkfs_23
   \   00000160   0x9800             LDR      R0,[SP, #+0]
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD003             BEQ.N    ??f_mkfs_23
   \   00000166   0x9800             LDR      R0,[SP, #+0]
   \   00000168   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000016C   0xD901             BLS.N    ??f_mkfs_24
   \                     ??f_mkfs_23:
   \   0000016E   0x2001             MOVS     R0,#+1
   \   00000170   0x9000             STR      R0,[SP, #+0]
   3645          	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
   \                     ??f_mkfs_24:
   \   00000172   0x9800             LDR      R0,[SP, #+0]
   \   00000174   0x1980             ADDS     R0,R0,R6
   \   00000176   0x1E40             SUBS     R0,R0,#+1
   \   00000178   0x9900             LDR      R1,[SP, #+0]
   \   0000017A   0x1E49             SUBS     R1,R1,#+1
   \   0000017C   0x4388             BICS     R0,R0,R1
   \   0000017E   0x9000             STR      R0,[SP, #+0]
   3646          	n = (n - b_data) / N_FATS;
   \   00000180   0x9800             LDR      R0,[SP, #+0]
   \   00000182   0x1B80             SUBS     R0,R0,R6
   \   00000184   0x2101             MOVS     R1,#+1
   \   00000186   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000018A   0x9000             STR      R0,[SP, #+0]
   3647          	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
   \   0000018C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000018E   0x2D03             CMP      R5,#+3
   \   00000190   0xD107             BNE.N    ??f_mkfs_25
   3648          		n_rsv += n;
   \   00000192   0x9800             LDR      R0,[SP, #+0]
   \   00000194   0xEB10 0x0808      ADDS     R8,R0,R8
   3649          		b_fat += n;
   \   00000198   0x9805             LDR      R0,[SP, #+20]
   \   0000019A   0x9900             LDR      R1,[SP, #+0]
   \   0000019C   0x1808             ADDS     R0,R1,R0
   \   0000019E   0x9005             STR      R0,[SP, #+20]
   \   000001A0   0xE002             B.N      ??f_mkfs_26
   3650          	} else {					/* FAT12/16: Expand FAT size */
   3651          		n_fat += n;
   \                     ??f_mkfs_25:
   \   000001A2   0x9800             LDR      R0,[SP, #+0]
   \   000001A4   0xEB10 0x0909      ADDS     R9,R0,R9
   3652          	}
   3653          
   3654          	/* Determine number of clusters and final check of validity of the FAT sub-type */
   3655          	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
   \                     ??f_mkfs_26:
   \   000001A8   0x9801             LDR      R0,[SP, #+4]
   \   000001AA   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000001AE   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   000001B2   0x9904             LDR      R1,[SP, #+16]
   \   000001B4   0x1A40             SUBS     R0,R0,R1
   \   000001B6   0xFBB0 0xF6F4      UDIV     R6,R0,R4
   3656          	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
   3657          		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
   \   000001BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001BC   0x2D02             CMP      R5,#+2
   \   000001BE   0xD103             BNE.N    ??f_mkfs_27
   \   000001C0   0xF640 0x70F6      MOVW     R0,#+4086
   \   000001C4   0x4286             CMP      R6,R0
   \   000001C6   0xD306             BCC.N    ??f_mkfs_28
   \                     ??f_mkfs_27:
   \   000001C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001CA   0x2D03             CMP      R5,#+3
   \   000001CC   0xD105             BNE.N    ??f_mkfs_29
   \   000001CE   0xF64F 0x70F6      MOVW     R0,#+65526
   \   000001D2   0x4286             CMP      R6,R0
   \   000001D4   0xD201             BCS.N    ??f_mkfs_29
   3658          		return FR_MKFS_ABORTED;
   \                     ??f_mkfs_28:
   \   000001D6   0x200E             MOVS     R0,#+14
   \   000001D8   0xE26F             B.N      ??f_mkfs_1
   3659          
   3660          	switch (fmt) {	/* Determine system ID for partition table */
   \                     ??f_mkfs_29:
   \   000001DA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001DC   0x0028             MOVS     R0,R5
   \   000001DE   0x2801             CMP      R0,#+1
   \   000001E0   0xD002             BEQ.N    ??f_mkfs_30
   \   000001E2   0x2802             CMP      R0,#+2
   \   000001E4   0xD003             BEQ.N    ??f_mkfs_31
   \   000001E6   0xE00C             B.N      ??f_mkfs_32
   3661          	case FS_FAT12:	sys = 0x01; break;
   \                     ??f_mkfs_30:
   \   000001E8   0xF05F 0x0A01      MOVS     R10,#+1
   \   000001EC   0xE00B             B.N      ??f_mkfs_33
   3662          	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
   \                     ??f_mkfs_31:
   \   000001EE   0x9801             LDR      R0,[SP, #+4]
   \   000001F0   0xF5B0 0x3F80      CMP      R0,#+65536
   \   000001F4   0xD202             BCS.N    ??f_mkfs_34
   \   000001F6   0xF05F 0x0A04      MOVS     R10,#+4
   \   000001FA   0xE001             B.N      ??f_mkfs_35
   \                     ??f_mkfs_34:
   \   000001FC   0xF05F 0x0A06      MOVS     R10,#+6
   \                     ??f_mkfs_35:
   \   00000200   0xE001             B.N      ??f_mkfs_33
   3663          	default: 		sys = 0x0C;
   \                     ??f_mkfs_32:
   \   00000202   0xF05F 0x0A0C      MOVS     R10,#+12
   3664          	}
   3665          
   3666          	if (_MULTI_PARTITION && part) {
   3667          		/* Update system ID in the partition table */
   3668          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   3669          		tbl[4] = sys;
   3670          		if (LPLD_Disk_Write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   3671          		md = 0xF8;
   3672          	} else {
   3673          		if (sfd) {	/* No patition table (SFD) */
   \                     ??f_mkfs_33:
   \   00000206   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000020A   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000020E   0xD003             BEQ.N    ??f_mkfs_36
   3674          			md = 0xF0;
   \   00000210   0x20F0             MOVS     R0,#+240
   \   00000212   0xF88D 0x0009      STRB     R0,[SP, #+9]
   \   00000216   0xE05D             B.N      ??f_mkfs_37
   3675          		} else {	/* Create partition table (FDISK) */
   3676          			mem_set(fs->win, 0, SS(fs));
   \                     ??f_mkfs_36:
   \   00000218   0xF44F 0x7200      MOV      R2,#+512
   \   0000021C   0x2100             MOVS     R1,#+0
   \   0000021E   0x9803             LDR      R0,[SP, #+12]
   \   00000220   0x3034             ADDS     R0,R0,#+52
   \   00000222   0x.... 0x....      BL       mem_set
   3677          			tbl = fs->win+MBR_Table;	/* Create partiton table for single partition in the drive */
   \   00000226   0x9803             LDR      R0,[SP, #+12]
   \   00000228   0xF200 0x1BF2      ADDW     R11,R0,#+498
   3678          			tbl[1] = 1;						/* Partition start head */
   \   0000022C   0x2001             MOVS     R0,#+1
   \   0000022E   0xF88B 0x0001      STRB     R0,[R11, #+1]
   3679          			tbl[2] = 1;						/* Partition start sector */
   \   00000232   0x2001             MOVS     R0,#+1
   \   00000234   0xF88B 0x0002      STRB     R0,[R11, #+2]
   3680          			tbl[3] = 0;						/* Partition start cylinder */
   \   00000238   0x2000             MOVS     R0,#+0
   \   0000023A   0xF88B 0x0003      STRB     R0,[R11, #+3]
   3681          			tbl[4] = sys;					/* System type */
   \   0000023E   0xF88B 0xA004      STRB     R10,[R11, #+4]
   3682          			tbl[5] = 254;					/* Partition end head */
   \   00000242   0x20FE             MOVS     R0,#+254
   \   00000244   0xF88B 0x0005      STRB     R0,[R11, #+5]
   3683          			n = (b_vol + n_vol) / 63 / 255;
   \   00000248   0x9801             LDR      R0,[SP, #+4]
   \   0000024A   0x19C0             ADDS     R0,R0,R7
   \   0000024C   0x213F             MOVS     R1,#+63
   \   0000024E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000252   0x21FF             MOVS     R1,#+255
   \   00000254   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000258   0x9000             STR      R0,[SP, #+0]
   3684          			tbl[6] = (BYTE)((n >> 2) | 63);	/* Partiiton end sector */
   \   0000025A   0x9800             LDR      R0,[SP, #+0]
   \   0000025C   0x0880             LSRS     R0,R0,#+2
   \   0000025E   0xF050 0x003F      ORRS     R0,R0,#0x3F
   \   00000262   0xF88B 0x0006      STRB     R0,[R11, #+6]
   3685          			tbl[7] = (BYTE)n;				/* End cylinder */
   \   00000266   0x9800             LDR      R0,[SP, #+0]
   \   00000268   0xF88B 0x0007      STRB     R0,[R11, #+7]
   3686          			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
   \   0000026C   0x203F             MOVS     R0,#+63
   \   0000026E   0xF88B 0x0008      STRB     R0,[R11, #+8]
   \   00000272   0x2000             MOVS     R0,#+0
   \   00000274   0xF88B 0x0009      STRB     R0,[R11, #+9]
   \   00000278   0x2000             MOVS     R0,#+0
   \   0000027A   0xF88B 0x000A      STRB     R0,[R11, #+10]
   \   0000027E   0x2000             MOVS     R0,#+0
   \   00000280   0xF88B 0x000B      STRB     R0,[R11, #+11]
   3687          			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
   \   00000284   0x9801             LDR      R0,[SP, #+4]
   \   00000286   0xF88B 0x000C      STRB     R0,[R11, #+12]
   \   0000028A   0x9801             LDR      R0,[SP, #+4]
   \   0000028C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000028E   0x0A00             LSRS     R0,R0,#+8
   \   00000290   0xF88B 0x000D      STRB     R0,[R11, #+13]
   \   00000294   0x9801             LDR      R0,[SP, #+4]
   \   00000296   0x0C00             LSRS     R0,R0,#+16
   \   00000298   0xF88B 0x000E      STRB     R0,[R11, #+14]
   \   0000029C   0x9801             LDR      R0,[SP, #+4]
   \   0000029E   0x0E00             LSRS     R0,R0,#+24
   \   000002A0   0xF88B 0x000F      STRB     R0,[R11, #+15]
   3688          			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
   \   000002A4   0x9803             LDR      R0,[SP, #+12]
   \   000002A6   0x2155             MOVS     R1,#+85
   \   000002A8   0xF880 0x1232      STRB     R1,[R0, #+562]
   \   000002AC   0x9803             LDR      R0,[SP, #+12]
   \   000002AE   0x21AA             MOVS     R1,#+170
   \   000002B0   0xF880 0x1233      STRB     R1,[R0, #+563]
   3689          			if (LPLD_Disk_Write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
   \   000002B4   0x2301             MOVS     R3,#+1
   \   000002B6   0x2200             MOVS     R2,#+0
   \   000002B8   0x9803             LDR      R0,[SP, #+12]
   \   000002BA   0xF110 0x0134      ADDS     R1,R0,#+52
   \   000002BE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000002C2   0x.... 0x....      BL       LPLD_Disk_Write
   \   000002C6   0x2800             CMP      R0,#+0
   \   000002C8   0xD001             BEQ.N    ??f_mkfs_38
   3690          				return FR_DISK_ERR;
   \   000002CA   0x2001             MOVS     R0,#+1
   \   000002CC   0xE1F5             B.N      ??f_mkfs_1
   3691          			md = 0xF8;
   \                     ??f_mkfs_38:
   \   000002CE   0x20F8             MOVS     R0,#+248
   \   000002D0   0xF88D 0x0009      STRB     R0,[SP, #+9]
   3692          		}
   3693          	}
   3694          
   3695          	/* Create BPB in the VBR */
   3696          	tbl = fs->win;							/* Clear sector */
   \                     ??f_mkfs_37:
   \   000002D4   0x9803             LDR      R0,[SP, #+12]
   \   000002D6   0xF110 0x0B34      ADDS     R11,R0,#+52
   3697          	mem_set(tbl, 0, SS(fs));
   \   000002DA   0xF44F 0x7200      MOV      R2,#+512
   \   000002DE   0x2100             MOVS     R1,#+0
   \   000002E0   0x4658             MOV      R0,R11
   \   000002E2   0x.... 0x....      BL       mem_set
   3698          	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
   \   000002E6   0x220B             MOVS     R2,#+11
   \   000002E8   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   000002EC   0x4658             MOV      R0,R11
   \   000002EE   0x.... 0x....      BL       mem_cpy
   3699          	i = SS(fs);								/* Sector size */
   \   000002F2   0xF44F 0x7A00      MOV      R10,#+512
   3700          	ST_WORD(tbl+BPB_BytsPerSec, i);
   \   000002F6   0xF88B 0xA00B      STRB     R10,[R11, #+11]
   \   000002FA   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000002FE   0xEA5F 0x201A      LSRS     R0,R10,#+8
   \   00000302   0xF88B 0x000C      STRB     R0,[R11, #+12]
   3701          	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
   \   00000306   0xF88B 0x400D      STRB     R4,[R11, #+13]
   3702          	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
   \   0000030A   0xF88B 0x800E      STRB     R8,[R11, #+14]
   \   0000030E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000312   0xEA5F 0x2018      LSRS     R0,R8,#+8
   \   00000316   0xF88B 0x000F      STRB     R0,[R11, #+15]
   3703          	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
   \   0000031A   0x2001             MOVS     R0,#+1
   \   0000031C   0xF88B 0x0010      STRB     R0,[R11, #+16]
   3704          	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
   \   00000320   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000322   0x2D03             CMP      R5,#+3
   \   00000324   0xD102             BNE.N    ??f_mkfs_39
   \   00000326   0xF05F 0x0A00      MOVS     R10,#+0
   \   0000032A   0xE001             B.N      ??f_mkfs_40
   \                     ??f_mkfs_39:
   \   0000032C   0xF44F 0x7A00      MOV      R10,#+512
   3705          	ST_WORD(tbl+BPB_RootEntCnt, i);
   \                     ??f_mkfs_40:
   \   00000330   0xF88B 0xA011      STRB     R10,[R11, #+17]
   \   00000334   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000338   0xEA5F 0x201A      LSRS     R0,R10,#+8
   \   0000033C   0xF88B 0x0012      STRB     R0,[R11, #+18]
   3706          	if (n_vol < 0x10000) {					/* Number of total sectors */
   \   00000340   0x9801             LDR      R0,[SP, #+4]
   \   00000342   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000346   0xD208             BCS.N    ??f_mkfs_41
   3707          		ST_WORD(tbl+BPB_TotSec16, n_vol);
   \   00000348   0x9801             LDR      R0,[SP, #+4]
   \   0000034A   0xF88B 0x0013      STRB     R0,[R11, #+19]
   \   0000034E   0x9801             LDR      R0,[SP, #+4]
   \   00000350   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000352   0x0A00             LSRS     R0,R0,#+8
   \   00000354   0xF88B 0x0014      STRB     R0,[R11, #+20]
   \   00000358   0xE00F             B.N      ??f_mkfs_42
   3708          	} else {
   3709          		ST_DWORD(tbl+BPB_TotSec32, n_vol);
   \                     ??f_mkfs_41:
   \   0000035A   0x9801             LDR      R0,[SP, #+4]
   \   0000035C   0xF88B 0x0020      STRB     R0,[R11, #+32]
   \   00000360   0x9801             LDR      R0,[SP, #+4]
   \   00000362   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000364   0x0A00             LSRS     R0,R0,#+8
   \   00000366   0xF88B 0x0021      STRB     R0,[R11, #+33]
   \   0000036A   0x9801             LDR      R0,[SP, #+4]
   \   0000036C   0x0C00             LSRS     R0,R0,#+16
   \   0000036E   0xF88B 0x0022      STRB     R0,[R11, #+34]
   \   00000372   0x9801             LDR      R0,[SP, #+4]
   \   00000374   0x0E00             LSRS     R0,R0,#+24
   \   00000376   0xF88B 0x0023      STRB     R0,[R11, #+35]
   3710          	}
   3711          	tbl[BPB_Media] = md;					/* Media descriptor */
   \                     ??f_mkfs_42:
   \   0000037A   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   0000037E   0xF88B 0x0015      STRB     R0,[R11, #+21]
   3712          	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
   \   00000382   0x203F             MOVS     R0,#+63
   \   00000384   0xF88B 0x0018      STRB     R0,[R11, #+24]
   \   00000388   0x2000             MOVS     R0,#+0
   \   0000038A   0xF88B 0x0019      STRB     R0,[R11, #+25]
   3713          	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
   \   0000038E   0x20FF             MOVS     R0,#+255
   \   00000390   0xF88B 0x001A      STRB     R0,[R11, #+26]
   \   00000394   0x2000             MOVS     R0,#+0
   \   00000396   0xF88B 0x001B      STRB     R0,[R11, #+27]
   3714          	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
   \   0000039A   0xF88B 0x701C      STRB     R7,[R11, #+28]
   \   0000039E   0x0038             MOVS     R0,R7
   \   000003A0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000003A2   0x0A00             LSRS     R0,R0,#+8
   \   000003A4   0xF88B 0x001D      STRB     R0,[R11, #+29]
   \   000003A8   0x0C38             LSRS     R0,R7,#+16
   \   000003AA   0xF88B 0x001E      STRB     R0,[R11, #+30]
   \   000003AE   0x0E38             LSRS     R0,R7,#+24
   \   000003B0   0xF88B 0x001F      STRB     R0,[R11, #+31]
   3715          	n = get_fattime();						/* Use current time as VSN */
   \   000003B4   0x.... 0x....      BL       get_fattime
   \   000003B8   0x9000             STR      R0,[SP, #+0]
   3716          	if (fmt == FS_FAT32) {
   \   000003BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003BC   0x2D03             CMP      R5,#+3
   \   000003BE   0xD143             BNE.N    ??f_mkfs_43
   3717          		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
   \   000003C0   0x9800             LDR      R0,[SP, #+0]
   \   000003C2   0xF88B 0x0043      STRB     R0,[R11, #+67]
   \   000003C6   0x9800             LDR      R0,[SP, #+0]
   \   000003C8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000003CA   0x0A00             LSRS     R0,R0,#+8
   \   000003CC   0xF88B 0x0044      STRB     R0,[R11, #+68]
   \   000003D0   0x9800             LDR      R0,[SP, #+0]
   \   000003D2   0x0C00             LSRS     R0,R0,#+16
   \   000003D4   0xF88B 0x0045      STRB     R0,[R11, #+69]
   \   000003D8   0x9800             LDR      R0,[SP, #+0]
   \   000003DA   0x0E00             LSRS     R0,R0,#+24
   \   000003DC   0xF88B 0x0046      STRB     R0,[R11, #+70]
   3718          		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
   \   000003E0   0xF88B 0x9024      STRB     R9,[R11, #+36]
   \   000003E4   0x4648             MOV      R0,R9
   \   000003E6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000003E8   0x0A00             LSRS     R0,R0,#+8
   \   000003EA   0xF88B 0x0025      STRB     R0,[R11, #+37]
   \   000003EE   0xEA5F 0x4019      LSRS     R0,R9,#+16
   \   000003F2   0xF88B 0x0026      STRB     R0,[R11, #+38]
   \   000003F6   0xEA5F 0x6019      LSRS     R0,R9,#+24
   \   000003FA   0xF88B 0x0027      STRB     R0,[R11, #+39]
   3719          		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
   \   000003FE   0x2002             MOVS     R0,#+2
   \   00000400   0xF88B 0x002C      STRB     R0,[R11, #+44]
   \   00000404   0x2000             MOVS     R0,#+0
   \   00000406   0xF88B 0x002D      STRB     R0,[R11, #+45]
   \   0000040A   0x2000             MOVS     R0,#+0
   \   0000040C   0xF88B 0x002E      STRB     R0,[R11, #+46]
   \   00000410   0x2000             MOVS     R0,#+0
   \   00000412   0xF88B 0x002F      STRB     R0,[R11, #+47]
   3720          		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
   \   00000416   0x2001             MOVS     R0,#+1
   \   00000418   0xF88B 0x0030      STRB     R0,[R11, #+48]
   \   0000041C   0x2000             MOVS     R0,#+0
   \   0000041E   0xF88B 0x0031      STRB     R0,[R11, #+49]
   3721          		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
   \   00000422   0x2006             MOVS     R0,#+6
   \   00000424   0xF88B 0x0032      STRB     R0,[R11, #+50]
   \   00000428   0x2000             MOVS     R0,#+0
   \   0000042A   0xF88B 0x0033      STRB     R0,[R11, #+51]
   3722          		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
   \   0000042E   0x2080             MOVS     R0,#+128
   \   00000430   0xF88B 0x0040      STRB     R0,[R11, #+64]
   3723          		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
   \   00000434   0x2029             MOVS     R0,#+41
   \   00000436   0xF88B 0x0042      STRB     R0,[R11, #+66]
   3724          		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
   \   0000043A   0x2213             MOVS     R2,#+19
   \   0000043C   0x....             LDR.N    R1,??DataTable14_4
   \   0000043E   0xF11B 0x0047      ADDS     R0,R11,#+71
   \   00000442   0x.... 0x....      BL       mem_cpy
   \   00000446   0xE022             B.N      ??f_mkfs_44
   3725          	} else {
   3726          		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
   \                     ??f_mkfs_43:
   \   00000448   0x9800             LDR      R0,[SP, #+0]
   \   0000044A   0xF88B 0x0027      STRB     R0,[R11, #+39]
   \   0000044E   0x9800             LDR      R0,[SP, #+0]
   \   00000450   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000452   0x0A00             LSRS     R0,R0,#+8
   \   00000454   0xF88B 0x0028      STRB     R0,[R11, #+40]
   \   00000458   0x9800             LDR      R0,[SP, #+0]
   \   0000045A   0x0C00             LSRS     R0,R0,#+16
   \   0000045C   0xF88B 0x0029      STRB     R0,[R11, #+41]
   \   00000460   0x9800             LDR      R0,[SP, #+0]
   \   00000462   0x0E00             LSRS     R0,R0,#+24
   \   00000464   0xF88B 0x002A      STRB     R0,[R11, #+42]
   3727          		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
   \   00000468   0xF88B 0x9016      STRB     R9,[R11, #+22]
   \   0000046C   0x4648             MOV      R0,R9
   \   0000046E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000470   0x0A00             LSRS     R0,R0,#+8
   \   00000472   0xF88B 0x0017      STRB     R0,[R11, #+23]
   3728          		tbl[BS_DrvNum] = 0x80;				/* Drive number */
   \   00000476   0x2080             MOVS     R0,#+128
   \   00000478   0xF88B 0x0024      STRB     R0,[R11, #+36]
   3729          		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
   \   0000047C   0x2029             MOVS     R0,#+41
   \   0000047E   0xF88B 0x0026      STRB     R0,[R11, #+38]
   3730          		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
   \   00000482   0x2213             MOVS     R2,#+19
   \   00000484   0x....             LDR.N    R1,??DataTable14_5
   \   00000486   0xF11B 0x002B      ADDS     R0,R11,#+43
   \   0000048A   0x.... 0x....      BL       mem_cpy
   3731          	}
   3732          	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
   \                     ??f_mkfs_44:
   \   0000048E   0x2055             MOVS     R0,#+85
   \   00000490   0xF88B 0x01FE      STRB     R0,[R11, #+510]
   \   00000494   0x20AA             MOVS     R0,#+170
   \   00000496   0xF88B 0x01FF      STRB     R0,[R11, #+511]
   3733          	if (LPLD_Disk_Write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
   \   0000049A   0x2301             MOVS     R3,#+1
   \   0000049C   0x003A             MOVS     R2,R7
   \   0000049E   0x4659             MOV      R1,R11
   \   000004A0   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000004A4   0x.... 0x....      BL       LPLD_Disk_Write
   \   000004A8   0x2800             CMP      R0,#+0
   \   000004AA   0xD001             BEQ.N    ??f_mkfs_45
   3734          		return FR_DISK_ERR;
   \   000004AC   0x2001             MOVS     R0,#+1
   \   000004AE   0xE104             B.N      ??f_mkfs_1
   3735          	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
   \                     ??f_mkfs_45:
   \   000004B0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004B2   0x2D03             CMP      R5,#+3
   \   000004B4   0xD106             BNE.N    ??f_mkfs_46
   3736          		LPLD_Disk_Write(pdrv, tbl, b_vol + 6, 1);
   \   000004B6   0x2301             MOVS     R3,#+1
   \   000004B8   0x1DBA             ADDS     R2,R7,#+6
   \   000004BA   0x4659             MOV      R1,R11
   \   000004BC   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000004C0   0x.... 0x....      BL       LPLD_Disk_Write
   3737          
   3738          	/* Initialize FAT area */
   3739          	wsect = b_fat;
   \                     ??f_mkfs_46:
   \   000004C4   0xF8DD 0x8014      LDR      R8,[SP, #+20]
   3740          	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
   \   000004C8   0xF05F 0x0A00      MOVS     R10,#+0
   \   000004CC   0xE001             B.N      ??f_mkfs_47
   \                     ??f_mkfs_48:
   \   000004CE   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??f_mkfs_47:
   \   000004D2   0xF1BA 0x0F00      CMP      R10,#+0
   \   000004D6   0xD17D             BNE.N    ??f_mkfs_49
   3741          		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
   \   000004D8   0xF44F 0x7200      MOV      R2,#+512
   \   000004DC   0x2100             MOVS     R1,#+0
   \   000004DE   0x4658             MOV      R0,R11
   \   000004E0   0x.... 0x....      BL       mem_set
   3742          		n = md;								/* Media descriptor byte */
   \   000004E4   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   000004E8   0x9000             STR      R0,[SP, #+0]
   3743          		if (fmt != FS_FAT32) {
   \   000004EA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004EC   0x2D03             CMP      R5,#+3
   \   000004EE   0xD01A             BEQ.N    ??f_mkfs_50
   3744          			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   \   000004F0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004F2   0x2D01             CMP      R5,#+1
   \   000004F4   0xD101             BNE.N    ??f_mkfs_51
   \   000004F6   0x....             LDR.N    R0,??DataTable14_6  ;; 0xffff00
   \   000004F8   0xE001             B.N      ??f_mkfs_52
   \                     ??f_mkfs_51:
   \   000004FA   0xF07F 0x00FF      MVNS     R0,#+255
   \                     ??f_mkfs_52:
   \   000004FE   0x9900             LDR      R1,[SP, #+0]
   \   00000500   0x4308             ORRS     R0,R0,R1
   \   00000502   0x9000             STR      R0,[SP, #+0]
   3745          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
   \   00000504   0x9800             LDR      R0,[SP, #+0]
   \   00000506   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   0000050A   0x9800             LDR      R0,[SP, #+0]
   \   0000050C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000050E   0x0A00             LSRS     R0,R0,#+8
   \   00000510   0xF88B 0x0001      STRB     R0,[R11, #+1]
   \   00000514   0x9800             LDR      R0,[SP, #+0]
   \   00000516   0x0C00             LSRS     R0,R0,#+16
   \   00000518   0xF88B 0x0002      STRB     R0,[R11, #+2]
   \   0000051C   0x9800             LDR      R0,[SP, #+0]
   \   0000051E   0x0E00             LSRS     R0,R0,#+24
   \   00000520   0xF88B 0x0003      STRB     R0,[R11, #+3]
   \   00000524   0xE02B             B.N      ??f_mkfs_53
   3746          		} else {
   3747          			n |= 0xFFFFFF00;
   \                     ??f_mkfs_50:
   \   00000526   0x9800             LDR      R0,[SP, #+0]
   \   00000528   0xF070 0x00FF      ORNS     R0,R0,#+255
   \   0000052C   0x9000             STR      R0,[SP, #+0]
   3748          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
   \   0000052E   0x9800             LDR      R0,[SP, #+0]
   \   00000530   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000534   0x9800             LDR      R0,[SP, #+0]
   \   00000536   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000538   0x0A00             LSRS     R0,R0,#+8
   \   0000053A   0xF88B 0x0001      STRB     R0,[R11, #+1]
   \   0000053E   0x9800             LDR      R0,[SP, #+0]
   \   00000540   0x0C00             LSRS     R0,R0,#+16
   \   00000542   0xF88B 0x0002      STRB     R0,[R11, #+2]
   \   00000546   0x9800             LDR      R0,[SP, #+0]
   \   00000548   0x0E00             LSRS     R0,R0,#+24
   \   0000054A   0xF88B 0x0003      STRB     R0,[R11, #+3]
   3749          			ST_DWORD(tbl+4, 0xFFFFFFFF);
   \   0000054E   0x20FF             MOVS     R0,#+255
   \   00000550   0xF88B 0x0004      STRB     R0,[R11, #+4]
   \   00000554   0x20FF             MOVS     R0,#+255
   \   00000556   0xF88B 0x0005      STRB     R0,[R11, #+5]
   \   0000055A   0x20FF             MOVS     R0,#+255
   \   0000055C   0xF88B 0x0006      STRB     R0,[R11, #+6]
   \   00000560   0x20FF             MOVS     R0,#+255
   \   00000562   0xF88B 0x0007      STRB     R0,[R11, #+7]
   3750          			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
   \   00000566   0x20FF             MOVS     R0,#+255
   \   00000568   0xF88B 0x0008      STRB     R0,[R11, #+8]
   \   0000056C   0x20FF             MOVS     R0,#+255
   \   0000056E   0xF88B 0x0009      STRB     R0,[R11, #+9]
   \   00000572   0x20FF             MOVS     R0,#+255
   \   00000574   0xF88B 0x000A      STRB     R0,[R11, #+10]
   \   00000578   0x200F             MOVS     R0,#+15
   \   0000057A   0xF88B 0x000B      STRB     R0,[R11, #+11]
   3751          		}
   3752          		if (LPLD_Disk_Write(pdrv, tbl, wsect++, 1) != RES_OK)
   \                     ??f_mkfs_53:
   \   0000057E   0x2301             MOVS     R3,#+1
   \   00000580   0x4642             MOV      R2,R8
   \   00000582   0x4659             MOV      R1,R11
   \   00000584   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000588   0x.... 0x....      BL       LPLD_Disk_Write
   \   0000058C   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000590   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000592   0x2800             CMP      R0,#+0
   \   00000594   0xD001             BEQ.N    ??f_mkfs_54
   3753          			return FR_DISK_ERR;
   \   00000596   0x2001             MOVS     R0,#+1
   \   00000598   0xE08F             B.N      ??f_mkfs_1
   3754          		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
   \                     ??f_mkfs_54:
   \   0000059A   0xF44F 0x7200      MOV      R2,#+512
   \   0000059E   0x2100             MOVS     R1,#+0
   \   000005A0   0x4658             MOV      R0,R11
   \   000005A2   0x.... 0x....      BL       mem_set
   3755          		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
   \   000005A6   0x2001             MOVS     R0,#+1
   \   000005A8   0x9000             STR      R0,[SP, #+0]
   \   000005AA   0xE002             B.N      ??f_mkfs_55
   \                     ??f_mkfs_56:
   \   000005AC   0x9800             LDR      R0,[SP, #+0]
   \   000005AE   0x1C40             ADDS     R0,R0,#+1
   \   000005B0   0x9000             STR      R0,[SP, #+0]
   \                     ??f_mkfs_55:
   \   000005B2   0x9800             LDR      R0,[SP, #+0]
   \   000005B4   0x4548             CMP      R0,R9
   \   000005B6   0xD28A             BCS.N    ??f_mkfs_48
   3756          			if (LPLD_Disk_Write(pdrv, tbl, wsect++, 1) != RES_OK)
   \   000005B8   0x2301             MOVS     R3,#+1
   \   000005BA   0x4642             MOV      R2,R8
   \   000005BC   0x4659             MOV      R1,R11
   \   000005BE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000005C2   0x.... 0x....      BL       LPLD_Disk_Write
   \   000005C6   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000005CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005CC   0x2800             CMP      R0,#+0
   \   000005CE   0xD0ED             BEQ.N    ??f_mkfs_56
   3757          				return FR_DISK_ERR;
   \   000005D0   0x2001             MOVS     R0,#+1
   \   000005D2   0xE072             B.N      ??f_mkfs_1
   3758          		}
   3759          	}
   3760          
   3761          	/* Initialize root directory */
   3762          	i = (fmt == FS_FAT32) ? au : n_dir;
   \                     ??f_mkfs_49:
   \   000005D4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005D6   0x2D03             CMP      R5,#+3
   \   000005D8   0xD101             BNE.N    ??f_mkfs_57
   \   000005DA   0x46A2             MOV      R10,R4
   \   000005DC   0xE001             B.N      ??f_mkfs_58
   \                     ??f_mkfs_57:
   \   000005DE   0xF8DD 0xA010      LDR      R10,[SP, #+16]
   3763          	do {
   3764          		if (LPLD_Disk_Write(pdrv, tbl, wsect++, 1) != RES_OK)
   \                     ??f_mkfs_58:
   \   000005E2   0x2301             MOVS     R3,#+1
   \   000005E4   0x4642             MOV      R2,R8
   \   000005E6   0x4659             MOV      R1,R11
   \   000005E8   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000005EC   0x.... 0x....      BL       LPLD_Disk_Write
   \   000005F0   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000005F4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005F6   0x2800             CMP      R0,#+0
   \   000005F8   0xD001             BEQ.N    ??f_mkfs_59
   3765          			return FR_DISK_ERR;
   \   000005FA   0x2001             MOVS     R0,#+1
   \   000005FC   0xE05D             B.N      ??f_mkfs_1
   3766          	} while (--i);
   \                     ??f_mkfs_59:
   \   000005FE   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000602   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000606   0xD1EC             BNE.N    ??f_mkfs_58
   3767          
   3768          #if _USE_ERASE	/* Erase data area if needed */
   3769          	{
   3770          		DWORD eb[2];
   3771          
   3772          		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
   3773          		LPLD_Disk_IOC(pdrv, CTRL_ERASE_SECTOR, eb);
   3774          	}
   3775          #endif
   3776          
   3777          	/* Create FSInfo if needed */
   3778          	if (fmt == FS_FAT32) {
   \   00000608   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000060A   0x2D03             CMP      R5,#+3
   \   0000060C   0xD149             BNE.N    ??f_mkfs_60
   3779          		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
   \   0000060E   0x2052             MOVS     R0,#+82
   \   00000610   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000614   0x2052             MOVS     R0,#+82
   \   00000616   0xF88B 0x0001      STRB     R0,[R11, #+1]
   \   0000061A   0x2061             MOVS     R0,#+97
   \   0000061C   0xF88B 0x0002      STRB     R0,[R11, #+2]
   \   00000620   0x2041             MOVS     R0,#+65
   \   00000622   0xF88B 0x0003      STRB     R0,[R11, #+3]
   3780          		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
   \   00000626   0x2072             MOVS     R0,#+114
   \   00000628   0xF88B 0x01E4      STRB     R0,[R11, #+484]
   \   0000062C   0x2072             MOVS     R0,#+114
   \   0000062E   0xF88B 0x01E5      STRB     R0,[R11, #+485]
   \   00000632   0x2041             MOVS     R0,#+65
   \   00000634   0xF88B 0x01E6      STRB     R0,[R11, #+486]
   \   00000638   0x2061             MOVS     R0,#+97
   \   0000063A   0xF88B 0x01E7      STRB     R0,[R11, #+487]
   3781          		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
   \   0000063E   0x0030             MOVS     R0,R6
   \   00000640   0x1E40             SUBS     R0,R0,#+1
   \   00000642   0xF88B 0x01E8      STRB     R0,[R11, #+488]
   \   00000646   0x0030             MOVS     R0,R6
   \   00000648   0x1E40             SUBS     R0,R0,#+1
   \   0000064A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000064C   0x0A00             LSRS     R0,R0,#+8
   \   0000064E   0xF88B 0x01E9      STRB     R0,[R11, #+489]
   \   00000652   0x1E70             SUBS     R0,R6,#+1
   \   00000654   0x0C00             LSRS     R0,R0,#+16
   \   00000656   0xF88B 0x01EA      STRB     R0,[R11, #+490]
   \   0000065A   0x1E70             SUBS     R0,R6,#+1
   \   0000065C   0x0E00             LSRS     R0,R0,#+24
   \   0000065E   0xF88B 0x01EB      STRB     R0,[R11, #+491]
   3782          		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
   \   00000662   0x2002             MOVS     R0,#+2
   \   00000664   0xF88B 0x01EC      STRB     R0,[R11, #+492]
   \   00000668   0x2000             MOVS     R0,#+0
   \   0000066A   0xF88B 0x01ED      STRB     R0,[R11, #+493]
   \   0000066E   0x2000             MOVS     R0,#+0
   \   00000670   0xF88B 0x01EE      STRB     R0,[R11, #+494]
   \   00000674   0x2000             MOVS     R0,#+0
   \   00000676   0xF88B 0x01EF      STRB     R0,[R11, #+495]
   3783          		ST_WORD(tbl+BS_55AA, 0xAA55);
   \   0000067A   0x2055             MOVS     R0,#+85
   \   0000067C   0xF88B 0x01FE      STRB     R0,[R11, #+510]
   \   00000680   0x20AA             MOVS     R0,#+170
   \   00000682   0xF88B 0x01FF      STRB     R0,[R11, #+511]
   3784          		LPLD_Disk_Write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
   \   00000686   0x2301             MOVS     R3,#+1
   \   00000688   0x1C7A             ADDS     R2,R7,#+1
   \   0000068A   0x4659             MOV      R1,R11
   \   0000068C   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000690   0x.... 0x....      BL       LPLD_Disk_Write
   3785          		LPLD_Disk_Write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
   \   00000694   0x2301             MOVS     R3,#+1
   \   00000696   0x1DFA             ADDS     R2,R7,#+7
   \   00000698   0x4659             MOV      R1,R11
   \   0000069A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000069E   0x.... 0x....      BL       LPLD_Disk_Write
   3786          	}
   3787          
   3788          	return (LPLD_Disk_IOC(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
   \                     ??f_mkfs_60:
   \   000006A2   0x2200             MOVS     R2,#+0
   \   000006A4   0x2100             MOVS     R1,#+0
   \   000006A6   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000006AA   0x.... 0x....      BL       LPLD_Disk_IOC
   \   000006AE   0x2800             CMP      R0,#+0
   \   000006B0   0xD101             BNE.N    ??f_mkfs_61
   \   000006B2   0x2000             MOVS     R0,#+0
   \   000006B4   0xE000             B.N      ??f_mkfs_62
   \                     ??f_mkfs_61:
   \   000006B6   0x2001             MOVS     R0,#+1
   \                     ??f_mkfs_62:
   \   000006B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_mkfs_1:
   \   000006BA   0xB007             ADD      SP,SP,#+28
   \   000006BC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   3789          }

   \                                 In section .rodata, align 4
   \                     ??vst:
   \   00000000   0x0400 0x0200      DC16 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 0
   \              0x0100 0x0080
   \              0x0040 0x0020
   \              0x0010 0x0008
   \              0x0004 0x0002
   \              0x0000       
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ??cst:
   \   00000000   0x8000 0x4000      DC16 32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512
   \              0x2000 0x1000
   \              0x0800 0x4000
   \              0x2000 0x1000
   \              0x0800 0x0400
   \              0x0200       
   \   00000016   0x00 0x00          DC8 0, 0
   3790          
   3791          
   3792          #if _MULTI_PARTITION == 2
   3793          /*-----------------------------------------------------------------------*/
   3794          /* Divide Physical Drive                                                 */
   3795          /*-----------------------------------------------------------------------*/
   3796          
   3797          FRESULT f_fdisk (
   3798          	BYTE pdrv,			/* Physical drive number */
   3799          	const DWORD szt[],	/* Pointer to the size table for each partitions */
   3800          	void* work			/* Pointer to the working buffer */
   3801          )
   3802          {
   3803          	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
   3804          	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
   3805          	DSTATUS stat;
   3806          	DWORD sz_disk, sz_part, s_part;
   3807          
   3808          
   3809          	stat = LPLD_Disk_Initialize(pdrv);
   3810          	if (stat & STA_NOINIT) return FR_NOT_READY;
   3811          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   3812          	if (LPLD_Disk_IOC(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
   3813          
   3814          	/* Determine CHS in the table regardless of the drive geometry */
   3815          	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
   3816          	if (n == 256) n--;
   3817          	e_hd = n - 1;
   3818          	sz_cyl = 63 * n;
   3819          	tot_cyl = sz_disk / sz_cyl;
   3820          
   3821          	/* Create partition table */
   3822          	mem_set(buf, 0, _MAX_SS);
   3823          	p = buf + MBR_Table; b_cyl = 0;
   3824          	for (i = 0; i < 4; i++, p += SZ_PTE) {
   3825          		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
   3826          		if (!p_cyl) continue;
   3827          		s_part = (DWORD)sz_cyl * b_cyl;
   3828          		sz_part = (DWORD)sz_cyl * p_cyl;
   3829          		if (i == 0) {	/* Exclude first track of cylinder 0 */
   3830          			s_hd = 1;
   3831          			s_part += 63; sz_part -= 63;
   3832          		} else {
   3833          			s_hd = 0;
   3834          		}
   3835          		e_cyl = b_cyl + p_cyl - 1;
   3836          		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
   3837          
   3838          		/* Set partition table */
   3839          		p[1] = s_hd;						/* Start head */
   3840          		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
   3841          		p[3] = (BYTE)b_cyl;					/* Start cylinder */
   3842          		p[4] = 0x06;						/* System type (temporary setting) */
   3843          		p[5] = e_hd;						/* End head */
   3844          		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
   3845          		p[7] = (BYTE)e_cyl;					/* End cylinder */
   3846          		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
   3847          		ST_DWORD(p + 12, sz_part);			/* Partition size */
   3848          
   3849          		/* Next partition */
   3850          		b_cyl += p_cyl;
   3851          	}
   3852          	ST_WORD(p, 0xAA55);
   3853          
   3854          	/* Write it to the MBR */
   3855          	return (LPLD_Disk_Write(pdrv, buf, 0, 1) || LPLD_Disk_IOC(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
   3856          }
   3857          
   3858          
   3859          #endif /* _MULTI_PARTITION == 2 */
   3860          #endif /* _USE_MKFS && !_FS_READONLY */
   3861          
   3862          
   3863          
   3864          
   3865          #if _USE_STRFUNC
   3866          /*-----------------------------------------------------------------------*/
   3867          /* Get a string from the file                                            */
   3868          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3869          TCHAR* f_gets (
   3870          	TCHAR* buff,	/* Pointer to the string buffer to read */
   3871          	int len,		/* Size of string buffer (characters) */
   3872          	FIL* fil		/* Pointer to the file object */
   3873          )
   3874          {
   \                     f_gets:
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x4690             MOV      R8,R2
   3875          	int n = 0;
   \   0000000A   0x2500             MOVS     R5,#+0
   3876          	TCHAR c, *p = buff;
   \   0000000C   0x0026             MOVS     R6,R4
   \   0000000E   0xE7FF             B.N      ??f_gets_0
   3877          	BYTE s[2];
   3878          	UINT rc;
   3879          
   3880          
   3881          	while (n < len - 1) {			/* Read bytes until buffer gets filled */
   3882          		f_read(fil, s, 1, &rc);
   3883          		if (rc != 1) break;			/* Break on EOF or error */
   3884          		c = s[0];
   3885          #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
   3886          		if (c >= 0x80) {
   3887          			if (c < 0xC0) continue;	/* Skip stray trailer */
   3888          			if (c < 0xE0) {			/* Two-byte sequense */
   3889          				f_read(fil, s, 1, &rc);
   3890          				if (rc != 1) break;
   3891          				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
   3892          				if (c < 0x80) c = '?';
   3893          			} else {
   3894          				if (c < 0xF0) {		/* Three-byte sequense */
   3895          					f_read(fil, s, 2, &rc);
   3896          					if (rc != 2) break;
   3897          					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
   3898          					if (c < 0x800) c = '?';
   3899          				} else {			/* Reject four-byte sequense */
   3900          					c = '?';
   3901          				}
   3902          			}
   3903          		}
   3904          #endif
   3905          #if _USE_STRFUNC >= 2
   3906          		if (c == '\r') continue;	/* Strip '\r' */
   \                     ??f_gets_1:
   \                     ??f_gets_0:
   \   00000010   0x1E78             SUBS     R0,R7,#+1
   \   00000012   0x4285             CMP      R5,R0
   \   00000014   0xDA13             BGE.N    ??f_gets_2
   \   00000016   0xAB00             ADD      R3,SP,#+0
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0xA901             ADD      R1,SP,#+4
   \   0000001C   0x4640             MOV      R0,R8
   \   0000001E   0x.... 0x....      BL       f_read
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD10A             BNE.N    ??f_gets_2
   \                     ??f_gets_3:
   \   00000028   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x280D             CMP      R0,#+13
   \   00000030   0xD0EE             BEQ.N    ??f_gets_1
   3907          #endif
   3908          		*p++ = c;
   \   00000032   0x7030             STRB     R0,[R6, #+0]
   \   00000034   0x1C76             ADDS     R6,R6,#+1
   3909          		n++;
   \   00000036   0x1C6D             ADDS     R5,R5,#+1
   3910          		if (c == '\n') break;		/* Break on EOL */
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x280A             CMP      R0,#+10
   \   0000003C   0xD1E8             BNE.N    ??f_gets_0
   3911          	}
   3912          	*p = 0;
   \                     ??f_gets_2:
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7030             STRB     R0,[R6, #+0]
   3913          	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD100             BNE.N    ??f_gets_4
   \                     ??f_gets_5:
   \   00000046   0x2400             MOVS     R4,#+0
   \                     ??f_gets_4:
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3914          }
   3915          
   3916          
   3917          
   3918          #if !_FS_READONLY
   3919          #include <stdarg.h>
   3920          /*-----------------------------------------------------------------------*/
   3921          /* Put a character to the file                                           */
   3922          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3923          int f_putc (
   3924          	TCHAR c,	/* A character to be output */
   3925          	FIL* fil	/* Pointer to the file object */
   3926          )
   3927          {
   \                     f_putc:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   3928          	UINT bw, btw;
   3929          	BYTE s[3];
   3930          
   3931          
   3932          #if _USE_STRFUNC >= 2
   3933          	if (c == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C0A             CMP      R4,#+10
   \   0000000C   0xD103             BNE.N    ??f_putc_0
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0x200D             MOVS     R0,#+13
   \   00000012   0xF7FF 0xFFF5      BL       f_putc
   3934          #endif
   3935          
   3936          #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
   3937          	if (c < 0x80) {			/* 7-bit */
   3938          		s[0] = (BYTE)c;
   3939          		btw = 1;
   3940          	} else {
   3941          		if (c < 0x800) {	/* 11-bit */
   3942          			s[0] = (BYTE)(0xC0 | (c >> 6));
   3943          			s[1] = (BYTE)(0x80 | (c & 0x3F));
   3944          			btw = 2;
   3945          		} else {			/* 16-bit */
   3946          			s[0] = (BYTE)(0xE0 | (c >> 12));
   3947          			s[1] = (BYTE)(0x80 | ((c >> 6) & 0x3F));
   3948          			s[2] = (BYTE)(0x80 | (c & 0x3F));
   3949          			btw = 3;
   3950          		}
   3951          	}
   3952          #else				/* Write the character without conversion */
   3953          	s[0] = (BYTE)c;
   \                     ??f_putc_0:
   \   00000016   0xF88D 0x4000      STRB     R4,[SP, #+0]
   3954          	btw = 1;
   \   0000001A   0x2401             MOVS     R4,#+1
   3955          #endif
   3956          	f_write(fil, s, btw, &bw);		/* Write the char to the file */
   \   0000001C   0xAB01             ADD      R3,SP,#+4
   \   0000001E   0x0022             MOVS     R2,R4
   \   00000020   0xA900             ADD      R1,SP,#+0
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x.... 0x....      BL       f_write
   3957          	return (bw == btw) ? 1 : EOF;	/* Return the result */
   \   00000028   0x9801             LDR      R0,[SP, #+4]
   \   0000002A   0x42A0             CMP      R0,R4
   \   0000002C   0xD101             BNE.N    ??f_putc_1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE001             B.N      ??f_putc_2
   \                     ??f_putc_1:
   \   00000032   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??f_putc_2:
   \   00000036   0xBD3E             POP      {R1-R5,PC}       ;; return
   3958          }
   3959          
   3960          
   3961          
   3962          
   3963          /*-----------------------------------------------------------------------*/
   3964          /* Put a string to the file                                              */
   3965          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3966          int f_puts (
   3967          	const TCHAR* str,	/* Pointer to the string to be output */
   3968          	FIL* fil			/* Pointer to the file object */
   3969          )
   3970          {
   \                     f_puts:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3971          	int n;
   3972          
   3973          
   3974          	for (n = 0; *str; str++, n++) {
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE001             B.N      ??f_puts_0
   \                     ??f_puts_1:
   \   0000000A   0x1C64             ADDS     R4,R4,#+1
   \   0000000C   0x1C76             ADDS     R6,R6,#+1
   \                     ??f_puts_0:
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD009             BEQ.N    ??f_puts_2
   3975          		if (f_putc(*str, fil) == EOF) return EOF;
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       f_putc
   \   0000001C   0xF110 0x0F01      CMN      R0,#+1
   \   00000020   0xD1F3             BNE.N    ??f_puts_1
   \   00000022   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000026   0xE000             B.N      ??f_puts_3
   3976          	}
   3977          	return n;
   \                     ??f_puts_2:
   \   00000028   0x0030             MOVS     R0,R6
   \                     ??f_puts_3:
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
   3978          }
   3979          
   3980          
   3981          
   3982          
   3983          /*-----------------------------------------------------------------------*/
   3984          /* Put a formatted string to the file                                    */
   3985          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3986          int f_printf (
   3987          	FIL* fil,			/* Pointer to the file object */
   3988          	const TCHAR* str,	/* Pointer to the format string */
   3989          	...					/* Optional arguments... */
   3990          )
   3991          {
   \                     f_printf:
   \   00000000   0xB40D             PUSH     {R0,R2,R3}
   \   00000002   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000006   0x000D             MOVS     R5,R1
   3992          	va_list arp;
   3993          	BYTE f, r;
   3994          	UINT i, j, w;
   3995          	ULONG v;
   3996          	TCHAR c, d, s[16], *p;
   3997          	int res, chc, cc;
   3998          
   3999          
   4000          	va_start(arp, str);
   \   00000008   0xAF0E             ADD      R7,SP,#+56
   4001          
   4002          	for (cc = res = 0; cc != EOF; res += cc) {
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0004             MOVS     R4,R0
   \   0000000E   0xE004             B.N      ??f_printf_0
   4003          		c = *str++;
   4004          		if (c == 0) break;			/* End of string */
   4005          		if (c != '%') {				/* Non escape character */
   4006          			cc = f_putc(c, fil);
   4007          			if (cc != EOF) cc = 1;
   4008          			continue;
   4009          		}
   4010          		w = f = 0;
   4011          		c = *str++;
   4012          		if (c == '0') {				/* Flag: '0' padding */
   4013          			f = 1; c = *str++;
   4014          		} else {
   4015          			if (c == '-') {			/* Flag: left justified */
   4016          				f = 2; c = *str++;
   4017          			}
   4018          		}
   4019          		while (IsDigit(c)) {		/* Precision */
   4020          			w = w * 10 + c - '0';
   4021          			c = *str++;
   4022          		}
   4023          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
   4024          			f |= 4; c = *str++;
   4025          		}
   4026          		if (!c) break;
   4027          		d = c;
   4028          		if (IsLower(d)) d -= 0x20;
   4029          		switch (d) {				/* Type is... */
   4030          		case 'S' :					/* String */
   4031          			p = va_arg(arp, TCHAR*);
   4032          			for (j = 0; p[j]; j++) ;
   4033          			chc = 0;
   4034          			if (!(f & 2)) {
   4035          				while (j++ < w) chc += (cc = f_putc(' ', fil));
   4036          			}
   4037          			chc += (cc = f_puts(p, fil));
   4038          			while (j++ < w) chc += (cc = f_putc(' ', fil));
   4039          			if (cc != EOF) cc = chc;
   4040          			continue;
   4041          		case 'C' :					/* Character */
   4042          			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
   4043          		case 'B' :					/* Binary */
   4044          			r = 2; break;
   4045          		case 'O' :					/* Octal */
   4046          			r = 8; break;
   4047          		case 'D' :					/* Signed decimal */
   4048          		case 'U' :					/* Unsigned decimal */
   4049          			r = 10; break;
   4050          		case 'X' :					/* Hexdecimal */
   4051          			r = 16; break;
   4052          		default:					/* Unknown type (passthrough) */
   4053          			cc = f_putc(c, fil); continue;
   4054          		}
   4055          
   4056          		/* Get an argument and put it in numeral */
   4057          		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
   4058          		if (d == 'D' && (v & 0x80000000)) {
   4059          			v = 0 - v;
   4060          			f |= 8;
   4061          		}
   4062          		i = 0;
   4063          		do {
   4064          			d = (TCHAR)(v % r); v /= r;
   4065          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   4066          			s[i++] = d + '0';
   4067          		} while (v && i < sizeof(s) / sizeof(s[0]));
   4068          		if (f & 8) s[i++] = '-';
   4069          		j = i; d = (f & 1) ? '0' : ' ';
   4070          		res = 0;
   4071          		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
   4072          		do res += (cc = f_putc(s[--i], fil)); while(i);
   4073          		while (j++ < w) res += (cc = f_putc(' ', fil));
   4074          		if (cc != EOF) cc = res;
   \                     ??f_printf_1:
   \   00000010   0xF110 0x0F01      CMN      R0,#+1
   \   00000014   0xD000             BEQ.N    ??f_printf_2
   \   00000016   0x0020             MOVS     R0,R4
   \                     ??f_printf_2:
   \   00000018   0x1904             ADDS     R4,R0,R4
   \                     ??f_printf_0:
   \   0000001A   0xF110 0x0F01      CMN      R0,#+1
   \   0000001E   0xD004             BEQ.N    ??f_printf_3
   \   00000020   0x782A             LDRB     R2,[R5, #+0]
   \   00000022   0x1C6D             ADDS     R5,R5,#+1
   \   00000024   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xD104             BNE.N    ??f_printf_4
   4075          	}
   4076          
   4077          	va_end(arp);
   4078          	return (cc == EOF) ? cc : res;
   \                     ??f_printf_3:
   \   0000002A   0xF110 0x0F01      CMN      R0,#+1
   \   0000002E   0xF040 0x8117      BNE.W    ??f_printf_5
   \   00000032   0xE116             B.N      ??f_printf_6
   \                     ??f_printf_4:
   \   00000034   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000036   0x2A25             CMP      R2,#+37
   \   00000038   0xD009             BEQ.N    ??f_printf_7
   \   0000003A   0x990D             LDR      R1,[SP, #+52]
   \   0000003C   0x0010             MOVS     R0,R2
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x.... 0x....      BL       f_putc
   \   00000044   0xF110 0x0F01      CMN      R0,#+1
   \   00000048   0xD000             BEQ.N    ??f_printf_8
   \   0000004A   0x2001             MOVS     R0,#+1
   \                     ??f_printf_8:
   \   0000004C   0xE7E4             B.N      ??f_printf_2
   \                     ??f_printf_7:
   \   0000004E   0x2600             MOVS     R6,#+0
   \   00000050   0x46B0             MOV      R8,R6
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0x782A             LDRB     R2,[R5, #+0]
   \   00000056   0x1C6D             ADDS     R5,R5,#+1
   \   00000058   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005A   0x2A30             CMP      R2,#+48
   \   0000005C   0xD104             BNE.N    ??f_printf_9
   \   0000005E   0xF05F 0x0801      MOVS     R8,#+1
   \   00000062   0x782A             LDRB     R2,[R5, #+0]
   \   00000064   0x1C6D             ADDS     R5,R5,#+1
   \   00000066   0xE00F             B.N      ??f_printf_10
   \                     ??f_printf_9:
   \   00000068   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006A   0x2A2D             CMP      R2,#+45
   \   0000006C   0xD10C             BNE.N    ??f_printf_10
   \   0000006E   0xF05F 0x0802      MOVS     R8,#+2
   \   00000072   0x782A             LDRB     R2,[R5, #+0]
   \   00000074   0x1C6D             ADDS     R5,R5,#+1
   \   00000076   0xE007             B.N      ??f_printf_10
   \                     ??f_printf_11:
   \   00000078   0x210A             MOVS     R1,#+10
   \   0000007A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000007C   0xFB01 0x2106      MLA      R1,R1,R6,R2
   \   00000080   0xF1B1 0x0630      SUBS     R6,R1,#+48
   \   00000084   0x782A             LDRB     R2,[R5, #+0]
   \   00000086   0x1C6D             ADDS     R5,R5,#+1
   \                     ??f_printf_10:
   \   00000088   0xF1B2 0x0130      SUBS     R1,R2,#+48
   \   0000008C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008E   0x290A             CMP      R1,#+10
   \   00000090   0xD3F2             BCC.N    ??f_printf_11
   \   00000092   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000094   0x2A6C             CMP      R2,#+108
   \   00000096   0xD002             BEQ.N    ??f_printf_12
   \   00000098   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000009A   0x2A4C             CMP      R2,#+76
   \   0000009C   0xD103             BNE.N    ??f_printf_13
   \                     ??f_printf_12:
   \   0000009E   0xF058 0x0804      ORRS     R8,R8,#0x4
   \   000000A2   0x782A             LDRB     R2,[R5, #+0]
   \   000000A4   0x1C6D             ADDS     R5,R5,#+1
   \                     ??f_printf_13:
   \   000000A6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A8   0x2A00             CMP      R2,#+0
   \   000000AA   0xD0BE             BEQ.N    ??f_printf_3
   \                     ??f_printf_14:
   \   000000AC   0x4693             MOV      R11,R2
   \   000000AE   0xF1BB 0x0061      SUBS     R0,R11,#+97
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x281A             CMP      R0,#+26
   \   000000B6   0xD201             BCS.N    ??f_printf_15
   \   000000B8   0xF1BB 0x0B20      SUBS     R11,R11,#+32
   \                     ??f_printf_15:
   \   000000BC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000C0   0x4658             MOV      R0,R11
   \   000000C2   0x2842             CMP      R0,#+66
   \   000000C4   0xD048             BEQ.N    ??f_printf_16
   \   000000C6   0x2843             CMP      R0,#+67
   \   000000C8   0xD03E             BEQ.N    ??f_printf_17
   \   000000CA   0x2844             CMP      R0,#+68
   \   000000CC   0xD04D             BEQ.N    ??f_printf_18
   \   000000CE   0x284F             CMP      R0,#+79
   \   000000D0   0xD049             BEQ.N    ??f_printf_19
   \   000000D2   0x2853             CMP      R0,#+83
   \   000000D4   0xD004             BEQ.N    ??f_printf_20
   \   000000D6   0x2855             CMP      R0,#+85
   \   000000D8   0xD047             BEQ.N    ??f_printf_18
   \   000000DA   0x2858             CMP      R0,#+88
   \   000000DC   0xD047             BEQ.N    ??f_printf_21
   \   000000DE   0xE048             B.N      ??f_printf_22
   \                     ??f_printf_20:
   \   000000E0   0xF8D7 0xA000      LDR      R10,[R7, #+0]
   \   000000E4   0x1D3F             ADDS     R7,R7,#+4
   \   000000E6   0xF05F 0x0900      MOVS     R9,#+0
   \   000000EA   0xE001             B.N      ??f_printf_23
   \                     ??f_printf_24:
   \   000000EC   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??f_printf_23:
   \   000000F0   0xF819 0x000A      LDRB     R0,[R9, R10]
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD1F9             BNE.N    ??f_printf_24
   \   000000F8   0xF05F 0x0B00      MOVS     R11,#+0
   \   000000FC   0xEA5F 0x7088      LSLS     R0,R8,#+30
   \   00000100   0xD40B             BMI.N    ??f_printf_25
   \   00000102   0xE005             B.N      ??f_printf_26
   \                     ??f_printf_27:
   \   00000104   0x990D             LDR      R1,[SP, #+52]
   \   00000106   0x2020             MOVS     R0,#+32
   \   00000108   0x.... 0x....      BL       f_putc
   \   0000010C   0xEB10 0x0B0B      ADDS     R11,R0,R11
   \                     ??f_printf_26:
   \   00000110   0x4648             MOV      R0,R9
   \   00000112   0xF110 0x0901      ADDS     R9,R0,#+1
   \   00000116   0x42B0             CMP      R0,R6
   \   00000118   0xD3F4             BCC.N    ??f_printf_27
   \                     ??f_printf_25:
   \   0000011A   0x990D             LDR      R1,[SP, #+52]
   \   0000011C   0x4650             MOV      R0,R10
   \   0000011E   0x.... 0x....      BL       f_puts
   \   00000122   0xEB10 0x0B0B      ADDS     R11,R0,R11
   \   00000126   0xE005             B.N      ??f_printf_28
   \                     ??f_printf_29:
   \   00000128   0x990D             LDR      R1,[SP, #+52]
   \   0000012A   0x2020             MOVS     R0,#+32
   \   0000012C   0x.... 0x....      BL       f_putc
   \   00000130   0xEB10 0x0B0B      ADDS     R11,R0,R11
   \                     ??f_printf_28:
   \   00000134   0x4649             MOV      R1,R9
   \   00000136   0xF111 0x0901      ADDS     R9,R1,#+1
   \   0000013A   0x42B1             CMP      R1,R6
   \   0000013C   0xD3F4             BCC.N    ??f_printf_29
   \   0000013E   0xF110 0x0F01      CMN      R0,#+1
   \   00000142   0xD000             BEQ.N    ??f_printf_30
   \   00000144   0x4658             MOV      R0,R11
   \                     ??f_printf_30:
   \   00000146   0xE767             B.N      ??f_printf_2
   \                     ??f_printf_17:
   \   00000148   0x0038             MOVS     R0,R7
   \   0000014A   0x1D07             ADDS     R7,R0,#+4
   \   0000014C   0x990D             LDR      R1,[SP, #+52]
   \   0000014E   0x6800             LDR      R0,[R0, #+0]
   \   00000150   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000152   0x.... 0x....      BL       f_putc
   \   00000156   0xE75F             B.N      ??f_printf_2
   \                     ??f_printf_16:
   \   00000158   0x2002             MOVS     R0,#+2
   \                     ??f_printf_31:
   \   0000015A   0xEA5F 0x7148      LSLS     R1,R8,#+29
   \   0000015E   0xD50E             BPL.N    ??f_printf_32
   \   00000160   0x6839             LDR      R1,[R7, #+0]
   \   00000162   0x1D3F             ADDS     R7,R7,#+4
   \   00000164   0xE015             B.N      ??f_printf_33
   \                     ??f_printf_19:
   \   00000166   0x2008             MOVS     R0,#+8
   \   00000168   0xE7F7             B.N      ??f_printf_31
   \                     ??f_printf_18:
   \   0000016A   0x200A             MOVS     R0,#+10
   \   0000016C   0xE7F5             B.N      ??f_printf_31
   \                     ??f_printf_21:
   \   0000016E   0x2010             MOVS     R0,#+16
   \   00000170   0xE7F3             B.N      ??f_printf_31
   \                     ??f_printf_22:
   \   00000172   0x990D             LDR      R1,[SP, #+52]
   \   00000174   0x0010             MOVS     R0,R2
   \   00000176   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000178   0x.... 0x....      BL       f_putc
   \   0000017C   0xE74C             B.N      ??f_printf_2
   \                     ??f_printf_32:
   \   0000017E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000182   0xF1BB 0x0F44      CMP      R11,#+68
   \   00000186   0xD102             BNE.N    ??f_printf_34
   \   00000188   0x6839             LDR      R1,[R7, #+0]
   \   0000018A   0x1D3F             ADDS     R7,R7,#+4
   \   0000018C   0xE001             B.N      ??f_printf_33
   \                     ??f_printf_34:
   \   0000018E   0x6839             LDR      R1,[R7, #+0]
   \   00000190   0x1D3F             ADDS     R7,R7,#+4
   \                     ??f_printf_33:
   \   00000192   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000196   0xF1BB 0x0F44      CMP      R11,#+68
   \   0000019A   0xD104             BNE.N    ??f_printf_35
   \   0000019C   0x2900             CMP      R1,#+0
   \   0000019E   0xD502             BPL.N    ??f_printf_35
   \   000001A0   0x4249             RSBS     R1,R1,#+0
   \   000001A2   0xF058 0x0808      ORRS     R8,R8,#0x8
   \                     ??f_printf_35:
   \   000001A6   0xF05F 0x0A00      MOVS     R10,#+0
   \                     ??f_printf_36:
   \   000001AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001AC   0xFBB1 0xF3F0      UDIV     R3,R1,R0
   \   000001B0   0xFB00 0x1B13      MLS      R11,R0,R3,R1
   \   000001B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B6   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   \   000001BA   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000001BE   0xF1BB 0x0F0A      CMP      R11,#+10
   \   000001C2   0xD307             BCC.N    ??f_printf_37
   \   000001C4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001C6   0x2A78             CMP      R2,#+120
   \   000001C8   0xD101             BNE.N    ??f_printf_38
   \   000001CA   0x2327             MOVS     R3,#+39
   \   000001CC   0xE000             B.N      ??f_printf_39
   \                     ??f_printf_38:
   \   000001CE   0x2307             MOVS     R3,#+7
   \                     ??f_printf_39:
   \   000001D0   0xEB13 0x0B0B      ADDS     R11,R3,R11
   \                     ??f_printf_37:
   \   000001D4   0xAB00             ADD      R3,SP,#+0
   \   000001D6   0xF11B 0x0430      ADDS     R4,R11,#+48
   \   000001DA   0xF80A 0x4003      STRB     R4,[R10, R3]
   \   000001DE   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000001E2   0x2900             CMP      R1,#+0
   \   000001E4   0xD002             BEQ.N    ??f_printf_40
   \   000001E6   0xF1BA 0x0F10      CMP      R10,#+16
   \   000001EA   0xD3DE             BCC.N    ??f_printf_36
   \                     ??f_printf_40:
   \   000001EC   0xEA5F 0x7008      LSLS     R0,R8,#+28
   \   000001F0   0xD505             BPL.N    ??f_printf_41
   \   000001F2   0xA800             ADD      R0,SP,#+0
   \   000001F4   0x212D             MOVS     R1,#+45
   \   000001F6   0xF80A 0x1000      STRB     R1,[R10, R0]
   \   000001FA   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??f_printf_41:
   \   000001FE   0x46D1             MOV      R9,R10
   \   00000200   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   00000204   0xD502             BPL.N    ??f_printf_42
   \   00000206   0xF05F 0x0B30      MOVS     R11,#+48
   \   0000020A   0xE001             B.N      ??f_printf_43
   \                     ??f_printf_42:
   \   0000020C   0xF05F 0x0B20      MOVS     R11,#+32
   \                     ??f_printf_43:
   \   00000210   0x2400             MOVS     R4,#+0
   \   00000212   0xE005             B.N      ??f_printf_44
   \                     ??f_printf_45:
   \   00000214   0x990D             LDR      R1,[SP, #+52]
   \   00000216   0x4658             MOV      R0,R11
   \   00000218   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000021A   0x.... 0x....      BL       f_putc
   \   0000021E   0x1904             ADDS     R4,R0,R4
   \                     ??f_printf_44:
   \   00000220   0xEA5F 0x7088      LSLS     R0,R8,#+30
   \   00000224   0xD404             BMI.N    ??f_printf_46
   \   00000226   0x4648             MOV      R0,R9
   \   00000228   0xF110 0x0901      ADDS     R9,R0,#+1
   \   0000022C   0x42B0             CMP      R0,R6
   \   0000022E   0xD3F1             BCC.N    ??f_printf_45
   \                     ??f_printf_46:
   \   00000230   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000234   0x990D             LDR      R1,[SP, #+52]
   \   00000236   0xA800             ADD      R0,SP,#+0
   \   00000238   0xF81A 0x0000      LDRB     R0,[R10, R0]
   \   0000023C   0x.... 0x....      BL       f_putc
   \   00000240   0x1904             ADDS     R4,R0,R4
   \   00000242   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000246   0xD1F3             BNE.N    ??f_printf_46
   \                     ??f_printf_47:
   \   00000248   0x4649             MOV      R1,R9
   \   0000024A   0xF111 0x0901      ADDS     R9,R1,#+1
   \   0000024E   0x42B1             CMP      R1,R6
   \   00000250   0xF4BF 0xAEDE      BCS.W    ??f_printf_1
   \   00000254   0x990D             LDR      R1,[SP, #+52]
   \   00000256   0x2020             MOVS     R0,#+32
   \   00000258   0x.... 0x....      BL       f_putc
   \   0000025C   0x1904             ADDS     R4,R0,R4
   \   0000025E   0xE7F3             B.N      ??f_printf_47
   \                     ??f_printf_5:
   \   00000260   0x0020             MOVS     R0,R4
   \                     ??f_printf_6:
   \   00000262   0xB004             ADD      SP,SP,#+16
   \   00000264   0xE8BD 0x0FF0      POP      {R4-R11}
   \   00000268   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
   4079          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     Files

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     LfnOfs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     `?<Constant "\\"*:<>?|\\177">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     ??excvt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     `?<Constant "+,;=[]">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x00544146         DC32     0x544146

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     CurrVol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     FatFs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x41615252         DC32     0x41615252

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x61417272         DC32     0x61417272

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     Fsid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     FatFs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     ??vst

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     ??cst

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     `?<Constant "\\353\\376\\220MSDOS5.0">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     `?<Constant "NO NAME    FAT32   ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     `?<Constant "NO NAME    FAT     ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x00FFFF00         DC32     0xffff00

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"*:<>?|\\177">`:
   \   00000000   0x22 0x2A          DC8 "\"*:<>?|\177"
   \              0x3A 0x3C    
   \              0x3E 0x3F    
   \              0x7C 0x7F    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "+,;=[]">`:
   \   00000000   0x2B 0x2C          DC8 "+,;=[]"
   \              0x3B 0x3D    
   \              0x5B 0x5D    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\353\\376\\220MSDOS5.0">`:
   \   00000000   0xEB 0xFE          DC8 "\353\376\220MSDOS5.0"
   \              0x90 0x4D    
   \              0x53 0x44    
   \              0x4F 0x53    
   \              0x35 0x2E    
   \              0x30 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "NO NAME    FAT32   ">`:
   \   00000000   0x4E 0x4F          DC8 "NO NAME    FAT32   "
   \              0x20 0x4E    
   \              0x41 0x4D    
   \              0x45 0x20    
   \              0x20 0x20    
   \              0x20 0x46    
   \              0x41 0x54    
   \              0x33 0x32    
   \              0x20 0x20    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "NO NAME    FAT     ">`:
   \   00000000   0x4E 0x4F          DC8 "NO NAME    FAT     "
   \              0x20 0x4E    
   \              0x41 0x4D    
   \              0x45 0x20    
   \              0x20 0x20    
   \              0x20 0x46    
   \              0x41 0x54    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x00    
   4080          
   4081          #endif /* !_FS_READONLY */
   4082          #endif /* _USE_STRFUNC */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  check_fs
               8 -> LPLD_Disk_Read
        0  chk_chr
        8  chk_lock
       24  chk_mounted
              24 -> LPLD_Disk_Initialize
              24 -> LPLD_Disk_Read
              24 -> LPLD_Disk_Status
              24 -> check_fs
              24 -> clear_lock
        0  clear_lock
        0  clmt_clust
        0  clust2sect
       24  cmp_lfn
              24 -> ff_wtoupper
       24  create_chain
              24 -> get_fat
              24 -> put_fat
       40  create_name
              40 -> chk_chr
              40 -> ff_convert
              40 -> mem_set
        0  dec_lock
       24  dir_find
              24 -> cmp_lfn
              24 -> dir_next
              24 -> dir_sdi
              24 -> mem_cmp
              24 -> move_window
              24 -> sum_sfn
       24  dir_next
              24 -> clust2sect
              24 -> create_chain
              24 -> get_fat
              24 -> mem_set
              24 -> move_window
       24  dir_read
              24 -> dir_next
              24 -> move_window
              24 -> pick_lfn
              24 -> sum_sfn
       40  dir_register
              40 -> dir_find
              40 -> dir_next
              40 -> dir_sdi
              40 -> fit_lfn
              40 -> gen_numname
              40 -> mem_cpy
              40 -> mem_set
              40 -> move_window
              40 -> sum_sfn
       16  dir_remove
              16 -> dir_next
              16 -> dir_sdi
              16 -> move_window
       16  dir_sdi
              16 -> clust2sect
              16 -> get_fat
        0  enq_lock
       64  f_chdir
              64 -> chk_mounted
              64 -> ff_memalloc
              64 -> ff_memfree
              64 -> follow_path
        0  f_chdrive
       72  f_chmod
              72 -> chk_mounted
              72 -> ff_memalloc
              72 -> ff_memfree
              72 -> follow_path
              72 -> sync
        8  f_close
               8 -> dec_lock
               8 -> f_sync
      112  f_getcwd
             112 -> chk_mounted
             112 -> dir_next
             112 -> dir_read
             112 -> dir_sdi
             112 -> ff_memalloc
             112 -> ff_memfree
             112 -> get_fileinfo
       40  f_getfree
              40 -> chk_mounted
              40 -> get_fat
              40 -> move_window
       32  f_gets
              32 -> f_read
       40  f_lseek
              40 -> LPLD_Disk_Read
              40 -> LPLD_Disk_Write
              40 -> clmt_clust
              40 -> clust2sect
              40 -> create_chain
              40 -> get_fat
              40 -> validate
       88  f_mkdir
              88 -> chk_mounted
              88 -> clust2sect
              88 -> create_chain
              88 -> dir_register
              88 -> ff_memalloc
              88 -> ff_memfree
              88 -> follow_path
              88 -> get_fattime
              88 -> mem_cpy
              88 -> mem_set
              88 -> move_window
              88 -> remove_chain
              88 -> sync
       64  f_mkfs
              64 -> LPLD_Disk_IOC
              64 -> LPLD_Disk_Initialize
              64 -> LPLD_Disk_Write
              64 -> get_fattime
              64 -> mem_cpy
              64 -> mem_set
       16  f_mount
              16 -> clear_lock
       88  f_open
              88 -> chk_lock
              88 -> chk_mounted
              88 -> dir_register
              88 -> enq_lock
              88 -> ff_memalloc
              88 -> ff_memfree
              88 -> follow_path
              88 -> get_fattime
              88 -> inc_lock
              88 -> move_window
              88 -> remove_chain
       32  f_opendir
              32 -> chk_mounted
              32 -> dir_sdi
              32 -> ff_memalloc
              32 -> ff_memfree
              32 -> follow_path
       64  f_printf
              64 -> f_putc
              64 -> f_puts
       24  f_putc
              24 -> f_putc
              24 -> f_write
       16  f_puts
              16 -> f_putc
       32  f_read
              32 -> LPLD_Disk_Read
              32 -> LPLD_Disk_Write
              32 -> clmt_clust
              32 -> clust2sect
              32 -> get_fat
              32 -> mem_cpy
              32 -> validate
       32  f_readdir
              32 -> dir_next
              32 -> dir_read
              32 -> dir_sdi
              32 -> ff_memalloc
              32 -> ff_memfree
              32 -> get_fileinfo
              32 -> validate
      128  f_rename
             128 -> chk_lock
             128 -> chk_mounted
             128 -> clust2sect
             128 -> dir_register
             128 -> dir_remove
             128 -> ff_memalloc
             128 -> ff_memfree
             128 -> follow_path
             128 -> mem_cpy
             128 -> move_window
             128 -> sync
       72  f_stat
              72 -> chk_mounted
              72 -> ff_memalloc
              72 -> ff_memfree
              72 -> follow_path
              72 -> get_fileinfo
       16  f_sync
              16 -> LPLD_Disk_Write
              16 -> get_fattime
              16 -> move_window
              16 -> sync
              16 -> validate
       16  f_truncate
              16 -> get_fat
              16 -> put_fat
              16 -> remove_chain
              16 -> validate
      104  f_unlink
             104 -> chk_lock
             104 -> chk_mounted
             104 -> dir_read
             104 -> dir_remove
             104 -> dir_sdi
             104 -> ff_memalloc
             104 -> ff_memfree
             104 -> follow_path
             104 -> mem_cpy
             104 -> remove_chain
             104 -> sync
       72  f_utime
              72 -> chk_mounted
              72 -> ff_memalloc
              72 -> ff_memfree
              72 -> follow_path
              72 -> sync
       32  f_write
              32 -> LPLD_Disk_Read
              32 -> LPLD_Disk_Write
              32 -> clmt_clust
              32 -> clust2sect
              32 -> create_chain
              32 -> mem_cpy
              32 -> validate
       16  fit_lfn
       16  follow_path
              16 -> create_name
              16 -> dir_find
              16 -> dir_sdi
       24  gen_numname
              24 -> mem_cpy
       24  get_fat
              24 -> move_window
       24  get_fileinfo
              24 -> ff_convert
        4  inc_lock
        4  mem_cmp
        0  mem_cpy
        0  mem_set
       24  move_window
              24 -> LPLD_Disk_Read
              24 -> LPLD_Disk_Write
       12  pick_lfn
       24  put_fat
              24 -> move_window
       24  remove_chain
              24 -> get_fat
              24 -> put_fat
        0  sum_sfn
       16  sync
              16 -> LPLD_Disk_IOC
              16 -> LPLD_Disk_Write
              16 -> mem_set
              16 -> move_window
        8  validate
               8 -> LPLD_Disk_Status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "+,;=[]">
      20  ?<Constant "NO NAME    FAT     ">
      20  ?<Constant "NO NAME    FAT32   ">
      12  ?<Constant "\"*:<>?|\177">
      12  ?<Constant "\353\376\220MSDOS5.0">
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable7
       4  ??DataTable9
       1  CurrVol
       4  FatFs
      96  Files
       2  Fsid
      16  LfnOfs
     120  check_fs
      20  chk_chr
     142  chk_lock
     880  chk_mounted
      42  clear_lock
      42  clmt_clust
      24  clust2sect
     150  cmp_lfn
     180  create_chain
     672  create_name
      24  cst
      78  dec_lock
     230  dir_find
     304  dir_next
     184  dir_read
     454  dir_register
      96  dir_remove
     174  dir_sdi
      38  enq_lock
     128  excvt
     144  f_chdir
      18  f_chdrive
     134  f_chmod
      36  f_close
     376  f_getcwd
     268  f_getfree
      78  f_gets
     768  f_lseek
     516  f_mkdir
    1728  f_mkfs
      62  f_mount
     558  f_open
     158  f_opendir
     620  f_printf
      56  f_putc
      44  f_puts
     510  f_read
     128  f_readdir
     380  f_rename
      94  f_stat
     184  f_sync
     166  f_truncate
     276  f_unlink
     140  f_utime
     566  f_write
     116  fit_lfn
     168  follow_path
     136  gen_numname
     242  get_fat
     250  get_fileinfo
     226  inc_lock
      32  mem_cmp
      20  mem_cpy
      16  mem_set
     116  move_window
     108  pick_lfn
     288  put_fat
     106  remove_chain
      30  sum_sfn
     214  sync
      42  validate
      24  vst

 
    103 bytes in section .bss
    264 bytes in section .rodata
 14 020 bytes in section .text
 
 14 020 bytes of CODE  memory
    264 bytes of CONST memory
    103 bytes of DATA  memory

Errors: none
Warnings: 1
