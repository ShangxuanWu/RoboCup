###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     25/Sep/2013  21:07:07 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\中国机器人大赛\robot_project\lib\LPLD\HAL_SDHC.c      #
#    Command line =  D:\中国机器人大赛\robot_project\lib\LPLD\HAL_SDHC.c -D   #
#                    IAR -D LPLD_K60 -lCN D:\中国机器人大赛\robot_project\pro #
#                    ject\LPLD_Template\iar\RAM\List\ -lB                     #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\RAM\List\ -o D:\中国机器人大赛\robot_project\project\L #
#                    PLD_Template\iar\RAM\Obj\ --no_cse --no_unroll           #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I D:\中国机器人大赛\robot_project\project\LPLD_T #
#                    emplate\iar\..\app\ -I D:\中国机器人大赛\robot_project\p #
#                    roject\LPLD_Template\iar\..\..\..\lib\common\ -I         #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\cpu\ -I D:\中国机器人大赛\robot_project\p #
#                    roject\LPLD_Template\iar\..\..\..\lib\cpu\headers\ -I    #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\adc16\ -I                         #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\enet\ -I                          #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\lptmr\ -I                         #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\mcg\ -I                           #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\pmc\ -I                           #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\rtc\ -I                           #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\uart\ -I                          #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\wdog\ -I                          #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\platforms\ -I                             #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\LPLD\ -I D:\中国机器人大赛\robot_project\ #
#                    project\LPLD_Template\iar\..\..\..\lib\LPLD\FatFs\ -I    #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\LPLD\USB\ -I                              #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\iar_config_files\ -Ol                     #
#    List file    =  D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\RAM\List\HAL_SDHC.lst                                  #
#    Object file  =  D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\RAM\Obj\HAL_SDHC.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\中国机器人大赛\robot_project\lib\LPLD\HAL_SDHC.c
      1          /*
      2           * --------------"拉普兰德K60底层库"-----------------
      3           *
      4           * 测试硬件平台:LPLD_K60 Card
      5           * 版权所有:北京拉普兰德电子技术有限公司
      6           * 网络销售:http://laplenden.taobao.com
      7           * 公司门户:http://www.lpld.cn
      8           *
      9           * 文件名: HAL_SDHC.c
     10           * 用途: SDHC底层模块相关函数
     11           * 最后修改日期: 20130214
     12           *
     13           * 开发者使用协议:
     14           *  本代码面向所有使用者开放源代码，开发者可以随意修改源代码。但本段及以上注释应
     15           *  予以保留，不得更改或删除原版权所有者姓名。二次开发者可以加注二次版权所有者，
     16           *  但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     17           *
     18           * 版权说明:
     19           *  SDHC模块驱动程序摘取自飞思卡尔MQX底层驱动，部分功能由拉普兰德修改。
     20           *  HAL_SDHC.h及HAL_SDHC.c内的代码版权归飞思卡尔公司享有。
     21           */
     22          
     23          #include "common.h"
     24          #include "HAL_SDHC.h"
     25          
     26          //SD卡信息全局变量

   \                                 In section .bss, align 4
     27          SDCARD_STRUCT_PTR        sdcard_ptr;
   \                     sdcard_ptr:
   \   00000000                      DS8 4
     28          //引用内核时钟
     29          extern int core_clk_khz;
     30          
     31          
     32          /*
     33           * LPLD_SDHC_InitGPIO
     34           * 初始化SDHC模块相关的GPIO引脚,并使能SDHC寄存器时钟
     35           * 
     36           * 参数:
     37           *    init--PCR寄存器掩码
     38           *
     39           * 输出:
     40           *    无
     41           */

   \                                 In section .text, align 2, keep-with-next
     42          static void LPLD_SDHC_InitGPIO(uint32 init)
     43          {  
     44            PORTE_PCR0 = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.D1  */
   \                     LPLD_SDHC_InitGPIO:
   \   00000000   0xF240 0x4143      MOVW     R1,#+1091
   \   00000004   0x4001             ANDS     R1,R1,R0
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable8  ;; 0x4004d000
   \   0000000A   0x6011             STR      R1,[R2, #+0]
     45            PORTE_PCR1 = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.D0  */
   \   0000000C   0xF240 0x4143      MOVW     R1,#+1091
   \   00000010   0x4001             ANDS     R1,R1,R0
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable8_1  ;; 0x4004d004
   \   00000016   0x6011             STR      R1,[R2, #+0]
     46            PORTE_PCR2 = init & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* SDHC.CLK */
   \   00000018   0xF410 0x6188      ANDS     R1,R0,#0x440
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable8_2  ;; 0x4004d008
   \   00000020   0x6011             STR      R1,[R2, #+0]
     47            PORTE_PCR3 = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.CMD */
   \   00000022   0xF240 0x4143      MOVW     R1,#+1091
   \   00000026   0x4001             ANDS     R1,R1,R0
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable8_3  ;; 0x4004d00c
   \   0000002C   0x6011             STR      R1,[R2, #+0]
     48            PORTE_PCR4 = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.D3  */
   \   0000002E   0xF240 0x4143      MOVW     R1,#+1091
   \   00000032   0x4001             ANDS     R1,R1,R0
   \   00000034   0x.... 0x....      LDR.W    R2,??DataTable8_4  ;; 0x4004d010
   \   00000038   0x6011             STR      R1,[R2, #+0]
     49            PORTE_PCR5 = init & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* SDHC.D2  */
   \   0000003A   0xF240 0x4143      MOVW     R1,#+1091
   \   0000003E   0x4008             ANDS     R0,R1,R0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable8_5  ;; 0x4004d014
   \   00000044   0x6008             STR      R0,[R1, #+0]
     50            
     51            SIM_SCGC3 |= SIM_SCGC3_SDHC_MASK; 
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40048030
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40048030
   \   00000054   0x6008             STR      R0,[R1, #+0]
     52          }
   \   00000056   0x4770             BX       LR               ;; return
     53          
     54          
     55          /*
     56           * LPLD_SDHC_SetBaudrate
     57           * 设置SDHC波特率
     58           * 
     59           * 参数:
     60           *    clock--模块输入时钟，即core_clk_khz*1000，单位Hz
     61           *    baud--SDHC期望时钟频率，单位Hz
     62           *
     63           * 输出:
     64           *    无
     65           */

   \                                 In section .text, align 2, keep-with-next
     66          static void LPLD_SDHC_SetBaudrate(uint32 clock, uint32 baud)
     67          {
   \                     LPLD_SDHC_SetBaudrate:
   \   00000000   0xB4F0             PUSH     {R4-R7}
     68            uint32 pres, div, min, minpres = 0x80, mindiv = 0x0F;
   \   00000002   0x2280             MOVS     R2,#+128
   \   00000004   0x230F             MOVS     R3,#+15
     69            int32  val;
     70            
     71            //找到相近的分频因子
     72            min = (uint32)-1;
   \   00000006   0xF05F 0x36FF      MOVS     R6,#-1
     73            for (pres = 2; pres <= 256; pres <<= 1)
   \   0000000A   0x2402             MOVS     R4,#+2
   \   0000000C   0xE00E             B.N      ??LPLD_SDHC_SetBaudrate_0
     74            {
     75              for (div = 1; div <= 16; div++)
     76              {
     77                val = pres * div * baud - clock;
   \                     ??LPLD_SDHC_SetBaudrate_1:
   \   0000000E   0xFB05 0xF704      MUL      R7,R5,R4
   \   00000012   0x434F             MULS     R7,R1,R7
   \   00000014   0x1A3F             SUBS     R7,R7,R0
     78                if (val >= 0)
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD404             BMI.N    ??LPLD_SDHC_SetBaudrate_2
     79                {
     80                  if (min > val)
   \   0000001A   0x42B7             CMP      R7,R6
   \   0000001C   0xD202             BCS.N    ??LPLD_SDHC_SetBaudrate_2
     81                  {
     82                    min = val;
   \   0000001E   0x003E             MOVS     R6,R7
     83                    minpres = pres;
   \   00000020   0x0022             MOVS     R2,R4
     84                    mindiv = div;
   \   00000022   0x002B             MOVS     R3,R5
     85                  }
     86                }
     87              }
   \                     ??LPLD_SDHC_SetBaudrate_2:
   \   00000024   0x1C6D             ADDS     R5,R5,#+1
   \                     ??LPLD_SDHC_SetBaudrate_3:
   \   00000026   0x2D11             CMP      R5,#+17
   \   00000028   0xD3F1             BCC.N    ??LPLD_SDHC_SetBaudrate_1
   \   0000002A   0x0064             LSLS     R4,R4,#+1
   \                     ??LPLD_SDHC_SetBaudrate_0:
   \   0000002C   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000030   0xD801             BHI.N    ??LPLD_SDHC_SetBaudrate_4
   \   00000032   0x2501             MOVS     R5,#+1
   \   00000034   0xE7F7             B.N      ??LPLD_SDHC_SetBaudrate_3
     88            }
     89            
     90            //禁止SDHC模块时钟
     91            SDHC_BASE_PTR->SYSCTL &= (~ SDHC_SYSCTL_SDCLKEN_MASK);
   \                     ??LPLD_SDHC_SetBaudrate_4:
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b102c
   \   00000044   0x6008             STR      R0,[R1, #+0]
     92            
     93            //修改分频因子
     94            div = SDHC_BASE_PTR->SYSCTL & (~ (SDHC_SYSCTL_DTOCV_MASK | SDHC_SYSCTL_SDCLKFS_MASK | SDHC_SYSCTL_DVS_MASK));
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable8_7  ;; 0xfff0000f
   \   00000050   0xEA11 0x0500      ANDS     R5,R1,R0
     95            SDHC_BASE_PTR->SYSCTL = div | (SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_SDCLKFS(minpres >> 1) | SDHC_SYSCTL_DVS(mindiv - 1));
   \   00000054   0x01D0             LSLS     R0,R2,#+7
   \   00000056   0xF410 0x407F      ANDS     R0,R0,#0xFF00
   \   0000005A   0x4328             ORRS     R0,R0,R5
   \   0000005C   0x1E59             SUBS     R1,R3,#+1
   \   0000005E   0x0109             LSLS     R1,R1,#+4
   \   00000060   0xF011 0x01F0      ANDS     R1,R1,#0xF0
   \   00000064   0x4308             ORRS     R0,R1,R0
   \   00000066   0xF450 0x2060      ORRS     R0,R0,#0xE0000
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b102c
   \   0000006E   0x6008             STR      R0,[R1, #+0]
     96            
     97            //等在时钟稳定
     98            while (0 == (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_SDSTB_MASK))
   \                     ??LPLD_SDHC_SetBaudrate_5:
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x400b1024
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x0700             LSLS     R0,R0,#+28
   \   00000078   0xD5FA             BPL.N    ??LPLD_SDHC_SetBaudrate_5
     99            {};
    100            
    101            //使能SDHC模块时钟
    102            SDHC_BASE_PTR->SYSCTL |= SDHC_SYSCTL_SDCLKEN_MASK;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b102c
   \   00000088   0x6008             STR      R0,[R1, #+0]
    103            SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_DTOE_MASK;
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0xF450 0x1080      ORRS     R0,R0,#0x100000
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000098   0x6008             STR      R0,[R1, #+0]
    104          }
   \   0000009A   0xBCF0             POP      {R4-R7}
   \   0000009C   0x4770             BX       LR               ;; return
    105          
    106          /*
    107           * LPLD_SDHC_IsRunning
    108           * 获取SDHC模块运行状态
    109           * 
    110           * 参数:
    111           *    无
    112           *
    113           * 输出:
    114           *    TRUE--正在运行
    115           *    FALSE--停止运行
    116           */

   \                                 In section .text, align 2, keep-with-next
    117          static boolean LPLD_SDHC_IsRunning(void)
    118          {
    119            return (0 != (SDHC_BASE_PTR->PRSSTAT & (SDHC_PRSSTAT_RTA_MASK | SDHC_PRSSTAT_WTA_MASK | SDHC_PRSSTAT_DLA_MASK | SDHC_PRSSTAT_CDIHB_MASK | SDHC_PRSSTAT_CIHB_MASK)));
   \                     LPLD_SDHC_IsRunning:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x400b1024
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF240 0x3107      MOVW     R1,#+775
   \   0000000A   0x4208             TST      R0,R1
   \   0000000C   0xD001             BEQ.N    ??LPLD_SDHC_IsRunning_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??LPLD_SDHC_IsRunning_1
   \                     ??LPLD_SDHC_IsRunning_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_IsRunning_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    120          }
    121          
    122          /*
    123           * LPLD_SDHC_WaitStatus
    124           * 等待指定状态标志位置位
    125           * 
    126           * 参数:
    127           *    mask--状态标志位掩码
    128           *
    129           * 输出:
    130           *    状态标志
    131           */

   \                                 In section .text, align 2, keep-with-next
    132          static uint32 LPLD_SDHC_WaitStatus(uint32 mask)
    133          {
    134            uint32 result;
    135            do
    136            {
    137              result = SDHC_BASE_PTR->IRQSTAT & mask;
   \                     LPLD_SDHC_WaitStatus:
   \                     ??LPLD_SDHC_WaitStatus_0:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x4001             ANDS     R1,R0,R1
    138            }
    139            while (0 == result);
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD0F9             BEQ.N    ??LPLD_SDHC_WaitStatus_0
    140            return result;
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    141          }
    142          
    143          /*
    144           * LPLD_SDHC_Init
    145           * SDHC模块初始化函数
    146           * 
    147           * 参数:
    148           *    coreClk--系y主频，单位Hz
    149           *    baud--SDHC期望时钟频率，单位Hz
    150           *
    151           * 输出:
    152           *    STA_OK--状态正常
    153           *    STA_NOINIT--驱动未初始化
    154           *    STA_NODISK--为插入卡
    155           *    STA_PROTECT--卡写保护
    156           */

   \                                 In section .text, align 2, keep-with-next
    157          static DRESULT LPLD_SDHC_Init(uint32 coreClk, uint32 baud)
    158          {
   \                     LPLD_SDHC_Init:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    159            
    160            sdcard_ptr->CARD = ESDHC_CARD_NONE;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6101             STR      R1,[R0, #+16]
    161            
    162            //禁用GPIO的SDHC复用功能
    163            LPLD_SDHC_InitGPIO (0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    164            
    165            //复位SDHC模块
    166            SDHC_BASE_PTR->SYSCTL = SDHC_SYSCTL_RSTA_MASK | SDHC_SYSCTL_SDCLKFS(0x80);
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x1008000
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    167            while (SDHC_BASE_PTR->SYSCTL & SDHC_SYSCTL_RSTA_MASK)
   \                     ??LPLD_SDHC_Init_0:
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x01C0             LSLS     R0,R0,#+7
   \   00000028   0xD4FA             BMI.N    ??LPLD_SDHC_Init_0
    168            { };
    169            
    170            //初始化寄存器值
    171            SDHC_BASE_PTR->VENDOR = 0;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x400b10c0
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x6001             STR      R1,[R0, #+0]
    172            SDHC_BASE_PTR->BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(512);
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x400b1004
   \   00000036   0xF45F 0x3181      MOVS     R1,#+66048
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    173            SDHC_BASE_PTR->PROCTL = SDHC_PROCTL_EMODE(ESDHC_PROCTL_EMODE_LITTLE) | SDHC_PROCTL_D3CD_MASK;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   00000040   0x2128             MOVS     R1,#+40
   \   00000042   0x6001             STR      R1,[R0, #+0]
    174            SDHC_BASE_PTR->WML = SDHC_WML_RDWML(2) | SDHC_WML_WRWML(1);
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x400b1044
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable9_5  ;; 0x10002
   \   0000004C   0x6001             STR      R1,[R0, #+0]
    175            
    176            //设置SDHC初始化时钟，最好不要超过400kHz
    177            LPLD_SDHC_SetBaudrate (coreClk, baud);
   \   0000004E   0x0029             MOVS     R1,R5
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       LPLD_SDHC_SetBaudrate
    178            
    179            //等待
    180            while (SDHC_BASE_PTR->PRSSTAT & (SDHC_PRSSTAT_CIHB_MASK | SDHC_PRSSTAT_CDIHB_MASK))
   \                     ??LPLD_SDHC_Init_1:
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x400b1024
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD1F8             BNE.N    ??LPLD_SDHC_Init_1
    181            { };
    182            
    183            //使能GPIO的SDHC复用
    184            LPLD_SDHC_InitGPIO (0xFFFF);
   \   00000064   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000068   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    185            
    186            //使能各种请求
    187            SDHC_BASE_PTR->IRQSTAT = 0xFFFF;
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000070   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000074   0x6001             STR      R1,[R0, #+0]
    188            SDHC_BASE_PTR->IRQSTATEN = SDHC_IRQSTATEN_DEBESEN_MASK | SDHC_IRQSTATEN_DCESEN_MASK | SDHC_IRQSTATEN_DTOESEN_MASK
    189              | SDHC_IRQSTATEN_CIESEN_MASK | SDHC_IRQSTATEN_CEBESEN_MASK | SDHC_IRQSTATEN_CCESEN_MASK | SDHC_IRQSTATEN_CTOESEN_MASK
    190                | SDHC_IRQSTATEN_BRRSEN_MASK | SDHC_IRQSTATEN_BWRSEN_MASK | SDHC_IRQSTATEN_CRMSEN_MASK
    191                  | SDHC_IRQSTATEN_TCSEN_MASK | SDHC_IRQSTATEN_CCSEN_MASK;
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x400b1034
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable10_4  ;; 0x7f00b3
   \   0000007E   0x6001             STR      R1,[R0, #+0]
    192            
    193            //等待80个初始时钟
    194            SDHC_BASE_PTR->SYSCTL |= SDHC_SYSCTL_INITA_MASK;
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b102c
   \   0000008E   0x6008             STR      R0,[R1, #+0]
    195            while (SDHC_BASE_PTR->SYSCTL & SDHC_SYSCTL_INITA_MASK)
   \                     ??LPLD_SDHC_Init_2:
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x0100             LSLS     R0,R0,#+4
   \   00000098   0xD4FA             BMI.N    ??LPLD_SDHC_Init_2
    196            { };
    197            
    198            //检查卡是否插入
    199            if (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_CINS_MASK)
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x400b1024
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0x03C0             LSLS     R0,R0,#+15
   \   000000A2   0xD505             BPL.N    ??LPLD_SDHC_Init_3
    200            {
    201              sdcard_ptr->CARD = ESDHC_CARD_UNKNOWN;
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x2101             MOVS     R1,#+1
   \   000000AC   0x6101             STR      R1,[R0, #+16]
   \   000000AE   0xE004             B.N      ??LPLD_SDHC_Init_4
    202            }
    203            else
    204            {
    205              sdcard_ptr->STATUS = STA_NODISK;
   \                     ??LPLD_SDHC_Init_3:
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x2102             MOVS     R1,#+2
   \   000000B8   0x6141             STR      R1,[R0, #+20]
    206            }
    207            SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \                     ??LPLD_SDHC_Init_4:
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000C8   0x6008             STR      R0,[R1, #+0]
    208            
    209            return RES_OK;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    210          }
    211          
    212          /*
    213           * LPLD_SDHC_SendCommand
    214           * 向SD卡发送指定CMD命令
    215           * 
    216           * 参数:
    217           *    command--SDHC命令信息结构体
    218           *
    219           * 输出:
    220           *    DRESULT--磁盘功能返回值
    221           */

   \                                 In section .text, align 2, keep-with-next
    222          static DRESULT LPLD_SDHC_SendCommand(ESDHC_COMMAND_STRUCT_PTR command)
    223          {
   \                     LPLD_SDHC_SendCommand:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    224            uint32 xfertyp;
    225            uint32 blkattr;
    226            
    227            //检查命令
    228            xfertyp = command->COMMAND;
   \   00000004   0x6825             LDR      R5,[R4, #+0]
    229            
    230            if (ESDHC_XFERTYP_CMDTYP_RESUME == ((xfertyp & SDHC_XFERTYP_CMDTYP_MASK) >> SDHC_XFERTYP_CMDTYP_SHIFT))
   \   00000006   0xF3C5 0x5081      UBFX     R0,R5,#+22,#+2
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD101             BNE.N    ??LPLD_SDHC_SendCommand_0
    231            {
    232              //恢复类型命令必须设置DPSEL位
    233              xfertyp |= SDHC_XFERTYP_DPSEL_MASK;
   \   0000000E   0xF455 0x1500      ORRS     R5,R5,#0x200000
    234            }
    235            
    236            if ((0 != command->BLOCKS) && (0 != command->BLOCKSIZE))
   \                     ??LPLD_SDHC_SendCommand_0:
   \   00000012   0x68A0             LDR      R0,[R4, #+8]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD01E             BEQ.N    ??LPLD_SDHC_SendCommand_1
   \   00000018   0x68E0             LDR      R0,[R4, #+12]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD01B             BEQ.N    ??LPLD_SDHC_SendCommand_1
    237            {
    238              xfertyp |= SDHC_XFERTYP_DPSEL_MASK;
   \   0000001E   0xF455 0x1500      ORRS     R5,R5,#0x200000
    239              if (command->BLOCKS != 1)
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD001             BEQ.N    ??LPLD_SDHC_SendCommand_2
    240              {
    241                //多块传输
    242                xfertyp |= SDHC_XFERTYP_MSBSEL_MASK;
   \   00000028   0xF055 0x0520      ORRS     R5,R5,#0x20
    243              }
    244              if ((uint32)-1 == command->BLOCKS)
   \                     ??LPLD_SDHC_SendCommand_2:
   \   0000002C   0x68A0             LDR      R0,[R4, #+8]
   \   0000002E   0xF110 0x0F01      CMN      R0,#+1
   \   00000032   0xD107             BNE.N    ??LPLD_SDHC_SendCommand_3
    245              {
    246                //大量传输
    247                blkattr = SDHC_BLKATTR_BLKSIZE(command->BLOCKSIZE) | SDHC_BLKATTR_BLKCNT(0xFFFF);
   \   00000034   0x68E0             LDR      R0,[R4, #+12]
   \   00000036   0x04C0             LSLS     R0,R0,#+19       ;; ZeroExtS R0,R0,#+19,#+19
   \   00000038   0x0CC0             LSRS     R0,R0,#+19
   \   0000003A   0xF040 0x407F      ORR      R0,R0,#0xFF000000
   \   0000003E   0xF450 0x007F      ORRS     R0,R0,#0xFF0000
   \   00000042   0xE009             B.N      ??LPLD_SDHC_SendCommand_4
    248              }
    249              else
    250              {
    251                blkattr = SDHC_BLKATTR_BLKSIZE(command->BLOCKSIZE) | SDHC_BLKATTR_BLKCNT(command->BLOCKS);
   \                     ??LPLD_SDHC_SendCommand_3:
   \   00000044   0x68E0             LDR      R0,[R4, #+12]
   \   00000046   0x04C0             LSLS     R0,R0,#+19       ;; ZeroExtS R0,R0,#+19,#+19
   \   00000048   0x0CC0             LSRS     R0,R0,#+19
   \   0000004A   0x68A1             LDR      R1,[R4, #+8]
   \   0000004C   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
    252                xfertyp |= SDHC_XFERTYP_BCEN_MASK;
   \   00000050   0xF055 0x0502      ORRS     R5,R5,#0x2
   \   00000054   0xE000             B.N      ??LPLD_SDHC_SendCommand_4
    253              }
    254            }
    255            else
    256            {
    257              blkattr = 0;
   \                     ??LPLD_SDHC_SendCommand_1:
   \   00000056   0x2000             MOVS     R0,#+0
    258            }
    259            
    260            //卡移除状态清除
    261            SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \                     ??LPLD_SDHC_SendCommand_4:
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   00000062   0x.... 0x....      LDR.W    R2,??DataTable10  ;; 0x400b1030
   \   00000066   0x6011             STR      R1,[R2, #+0]
    262            
    263            //等待CMD线空闲
    264            while (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_CIHB_MASK)
   \                     ??LPLD_SDHC_SendCommand_5:
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable8_8  ;; 0x400b1024
   \   0000006C   0x6809             LDR      R1,[R1, #+0]
   \   0000006E   0x07C9             LSLS     R1,R1,#+31
   \   00000070   0xD4FA             BMI.N    ??LPLD_SDHC_SendCommand_5
    265            { };
    266            
    267            //初始化命令
    268            SDHC_BASE_PTR->CMDARG = command->ARGUMENT;
   \   00000072   0x6861             LDR      R1,[R4, #+4]
   \   00000074   0x.... 0x....      LDR.W    R2,??DataTable10_5  ;; 0x400b1008
   \   00000078   0x6011             STR      R1,[R2, #+0]
    269            SDHC_BASE_PTR->BLKATTR = blkattr;
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x400b1004
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    270            SDHC_BASE_PTR->DSADDR = 0;
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable10_6  ;; 0x400b1000
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x6001             STR      R1,[R0, #+0]
    271            
    272            //发送命令
    273            SDHC_BASE_PTR->XFERTYP = xfertyp;
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable10_7  ;; 0x400b100c
   \   0000008C   0x6005             STR      R5,[R0, #+0]
    274            
    275            //等待响应
    276            if (LPLD_SDHC_WaitStatus (SDHC_IRQSTAT_CIE_MASK | SDHC_IRQSTAT_CEBE_MASK | SDHC_IRQSTAT_CCE_MASK | SDHC_IRQSTAT_CC_MASK) != SDHC_IRQSTAT_CC_MASK)
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable10_8  ;; 0xe0001
   \   00000092   0x.... 0x....      BL       LPLD_SDHC_WaitStatus
   \   00000096   0x2801             CMP      R0,#+1
   \   00000098   0xD00B             BEQ.N    ??LPLD_SDHC_SendCommand_6
    277            {
    278              SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CIE_MASK | SDHC_IRQSTAT_CEBE_MASK | SDHC_IRQSTAT_CCE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0xF440 0x2070      ORR      R0,R0,#0xF0000
   \   000000A4   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    279              return RES_ERROR;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xE043             B.N      ??LPLD_SDHC_SendCommand_7
    280            }
    281            
    282            //检查卡是否移除
    283            if (SDHC_BASE_PTR->IRQSTAT & SDHC_IRQSTAT_CRM_MASK)
   \                     ??LPLD_SDHC_SendCommand_6:
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x0600             LSLS     R0,R0,#+24
   \   000000BA   0xD50E             BPL.N    ??LPLD_SDHC_SendCommand_8
    284            {
    285              SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000CA   0x6008             STR      R0,[R1, #+0]
    286              sdcard_ptr->STATUS = STA_NODISK;
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0x2102             MOVS     R1,#+2
   \   000000D4   0x6141             STR      R1,[R0, #+20]
    287              return RES_NOTRDY;
   \   000000D6   0x2003             MOVS     R0,#+3
   \   000000D8   0xE02F             B.N      ??LPLD_SDHC_SendCommand_7
    288            }
    289            
    290            //获取响应
    291            if (SDHC_BASE_PTR->IRQSTAT & SDHC_IRQSTAT_CTOE_MASK)
   \                     ??LPLD_SDHC_SendCommand_8:
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0x03C0             LSLS     R0,R0,#+15
   \   000000E2   0xD509             BPL.N    ??LPLD_SDHC_SendCommand_9
    292            {
    293              SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    294              return RES_NONRSPNS;
   \   000000F4   0x2005             MOVS     R0,#+5
   \   000000F6   0xE020             B.N      ??LPLD_SDHC_SendCommand_7
    295            }
    296            if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) != SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO))
   \                     ??LPLD_SDHC_SendCommand_9:
   \   000000F8   0xF415 0x3F40      TST      R5,#0x30000
   \   000000FC   0xD014             BEQ.N    ??LPLD_SDHC_SendCommand_10
    297            {
    298              command->RESPONSE[0] = SDHC_BASE_PTR->CMDRSP[0];
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable11  ;; 0x400b1010
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0x6120             STR      R0,[R4, #+16]
    299              if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) == SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136))
   \   00000106   0xF415 0x3040      ANDS     R0,R5,#0x30000
   \   0000010A   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000010E   0xD10B             BNE.N    ??LPLD_SDHC_SendCommand_10
    300              {
    301                command->RESPONSE[1] = SDHC_BASE_PTR->CMDRSP[1];
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable11_1  ;; 0x400b1014
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x6160             STR      R0,[R4, #+20]
    302                command->RESPONSE[2] = SDHC_BASE_PTR->CMDRSP[2];
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0x400b1018
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x61A0             STR      R0,[R4, #+24]
    303                command->RESPONSE[3] = SDHC_BASE_PTR->CMDRSP[3];
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable11_3  ;; 0x400b101c
   \   00000124   0x6800             LDR      R0,[R0, #+0]
   \   00000126   0x61E0             STR      R0,[R4, #+28]
    304              }
    305            }
    306            SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_CC_MASK;
   \                     ??LPLD_SDHC_SendCommand_10:
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   0000012C   0x6800             LDR      R0,[R0, #+0]
   \   0000012E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000136   0x6008             STR      R0,[R1, #+0]
    307            
    308            return RES_OK;
   \   00000138   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_SendCommand_7:
   \   0000013A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    309          }
    310          
    311          
    312          /*
    313           * LPLD_SDHC_IOC
    314           * SDHC模块其他控制服务函数
    315           * 
    316           * 参数:
    317           *    cmd--SDHC模块控制命令
    318           *    *param_ptr--控制参数
    319           *
    320           * 输出:
    321           *    DRESULT--磁盘功能返回值
    322           */

   \                                 In section .text, align 2, keep-with-next
    323          DRESULT LPLD_SDHC_IOC(uint32 cmd, void *param_ptr)
    324          {
   \                     LPLD_SDHC_IOC:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x000D             MOVS     R5,R1
    325            
    326            ESDHC_COMMAND_STRUCT    command;
    327            boolean                 mem, io, mmc, ceata, mp, hc;
    328            int32                  val;
    329            DRESULT                 result = RES_OK;
   \   00000008   0x2400             MOVS     R4,#+0
    330            uint32 *             param32_ptr = param_ptr;
    331            
    332            switch (cmd)
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD015             BEQ.N    ??LPLD_SDHC_IOC_0
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xF000 0x81D4      BEQ.W    ??LPLD_SDHC_IOC_1
   \   00000014   0x2803             CMP      R0,#+3
   \   00000016   0xF000 0x8273      BEQ.W    ??LPLD_SDHC_IOC_2
   \   0000001A   0x2804             CMP      R0,#+4
   \   0000001C   0xF000 0x81D3      BEQ.W    ??LPLD_SDHC_IOC_3
   \   00000020   0x2805             CMP      R0,#+5
   \   00000022   0xF000 0x81EC      BEQ.W    ??LPLD_SDHC_IOC_4
   \   00000026   0x2806             CMP      R0,#+6
   \   00000028   0xF000 0x8209      BEQ.W    ??LPLD_SDHC_IOC_5
   \   0000002C   0x2807             CMP      R0,#+7
   \   0000002E   0xF000 0x8223      BEQ.W    ??LPLD_SDHC_IOC_6
   \   00000032   0x2893             CMP      R0,#+147
   \   00000034   0xF000 0x82A4      BEQ.W    ??LPLD_SDHC_IOC_7
   \   00000038   0xE2BD             B.N      ??LPLD_SDHC_IOC_8
    333            {
    334            case IO_IOCTL_ESDHC_INIT:  
    335              //初始化SDHC模块
    336              result = LPLD_SDHC_Init (core_clk_khz*1000, 400000);
   \                     ??LPLD_SDHC_IOC_0:
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable11_4  ;; 0x61a80
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF44F 0x727A      MOV      R2,#+1000
   \   00000048   0x4350             MULS     R0,R2,R0
   \   0000004A   0x.... 0x....      BL       LPLD_SDHC_Init
   \   0000004E   0x0004             MOVS     R4,R0
    337              if (RES_OK != result)
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x2C00             CMP      R4,#+0
   \   00000054   0xF040 0x82B0      BNE.W    ??LPLD_SDHC_IOC_9
    338              {
    339                break;
    340              }
    341              
    342              mem = FALSE;
   \                     ??LPLD_SDHC_IOC_10:
   \   00000058   0x2500             MOVS     R5,#+0
    343              io = FALSE;
   \   0000005A   0x2600             MOVS     R6,#+0
    344              mmc = FALSE;
   \   0000005C   0x2700             MOVS     R7,#+0
    345              ceata = FALSE;
   \   0000005E   0xF05F 0x0800      MOVS     R8,#+0
    346              hc = FALSE;
   \   00000062   0xF05F 0x0A00      MOVS     R10,#+0
    347              mp = FALSE;
   \   00000066   0xF05F 0x0900      MOVS     R9,#+0
    348              
    349              //CMD0 - 空闲命令，复位卡
    350              command.COMMAND = ESDHC_CMD0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x9000             STR      R0,[SP, #+0]
    351              command.ARGUMENT = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x9001             STR      R0,[SP, #+4]
    352              command.BLOCKS = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x9002             STR      R0,[SP, #+8]
    353              result = LPLD_SDHC_SendCommand (&command);
   \   00000076   0xA800             ADD      R0,SP,#+0
   \   00000078   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   0000007C   0x0004             MOVS     R4,R0
    354              if (result!=RES_OK)
   \   0000007E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000080   0x2C00             CMP      R4,#+0
   \   00000082   0xD005             BEQ.N    ??LPLD_SDHC_IOC_11
    355              {
    356                sdcard_ptr->STATUS = STA_NOINIT;
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x2101             MOVS     R1,#+1
   \   0000008C   0x6141             STR      R1,[R0, #+20]
    357                break;
   \   0000008E   0xE293             B.N      ??LPLD_SDHC_IOC_9
    358              }
    359              
    360              //CMD8 - 发送接口状态，检查是否支持高容量
    361              command.COMMAND = ESDHC_CMD8;
   \                     ??LPLD_SDHC_IOC_11:
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable11_6  ;; 0x81a0000
   \   00000094   0x9000             STR      R0,[SP, #+0]
    362              command.ARGUMENT = 0x000001AA;
   \   00000096   0xF44F 0x70D5      MOV      R0,#+426
   \   0000009A   0x9001             STR      R0,[SP, #+4]
    363              command.BLOCKS = 0;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x9002             STR      R0,[SP, #+8]
    364              result = LPLD_SDHC_SendCommand (&command);
   \   000000A0   0xA800             ADD      R0,SP,#+0
   \   000000A2   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000000A6   0x0004             MOVS     R4,R0
    365              if (result==RES_ERROR)
   \   000000A8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AA   0x2C01             CMP      R4,#+1
   \   000000AC   0xD105             BNE.N    ??LPLD_SDHC_IOC_12
    366              {
    367                sdcard_ptr->STATUS = STA_NOINIT;
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x2101             MOVS     R1,#+1
   \   000000B6   0x6141             STR      R1,[R0, #+20]
    368                break;
   \   000000B8   0xE27E             B.N      ??LPLD_SDHC_IOC_9
    369              }
    370              if (result == RES_OK)
   \                     ??LPLD_SDHC_IOC_12:
   \   000000BA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BC   0x2C00             CMP      R4,#+0
   \   000000BE   0xD10C             BNE.N    ??LPLD_SDHC_IOC_13
    371              {
    372                if (command.RESPONSE[0] != command.ARGUMENT)
   \   000000C0   0x9804             LDR      R0,[SP, #+16]
   \   000000C2   0x9901             LDR      R1,[SP, #+4]
   \   000000C4   0x4288             CMP      R0,R1
   \   000000C6   0xD006             BEQ.N    ??LPLD_SDHC_IOC_14
    373                {
    374                  sdcard_ptr->STATUS = STA_NOINIT;
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0x2101             MOVS     R1,#+1
   \   000000D0   0x6141             STR      R1,[R0, #+20]
    375                  result = RES_ERROR;
   \   000000D2   0x2401             MOVS     R4,#+1
    376                  break;
   \   000000D4   0xE270             B.N      ??LPLD_SDHC_IOC_9
    377                }
    378                hc = TRUE;
   \                     ??LPLD_SDHC_IOC_14:
   \   000000D6   0xF05F 0x0A01      MOVS     R10,#+1
    379              }
    380              
    381              //CMD5 - 发送操作状态，测试IO
    382              command.COMMAND = ESDHC_CMD5;
   \                     ??LPLD_SDHC_IOC_13:
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x5020000
   \   000000DE   0x9000             STR      R0,[SP, #+0]
    383              command.ARGUMENT = 0;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x9001             STR      R0,[SP, #+4]
    384              command.BLOCKS = 0;      
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x9002             STR      R0,[SP, #+8]
    385              result = LPLD_SDHC_SendCommand (&command);
   \   000000E8   0xA800             ADD      R0,SP,#+0
   \   000000EA   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000000EE   0x0004             MOVS     R4,R0
    386              if (result==RES_ERROR)
   \   000000F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F2   0x2C01             CMP      R4,#+1
   \   000000F4   0xD105             BNE.N    ??LPLD_SDHC_IOC_15
    387              {
    388                sdcard_ptr->STATUS = STA_NOINIT;
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000FA   0x6800             LDR      R0,[R0, #+0]
   \   000000FC   0x2101             MOVS     R1,#+1
   \   000000FE   0x6141             STR      R1,[R0, #+20]
    389                break;
   \   00000100   0xE25A             B.N      ??LPLD_SDHC_IOC_9
    390              }
    391              if (result == RES_OK)
   \                     ??LPLD_SDHC_IOC_15:
   \   00000102   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000104   0x2C00             CMP      R4,#+0
   \   00000106   0xD130             BNE.N    ??LPLD_SDHC_IOC_16
    392              {
    393                if (((command.RESPONSE[0] >> 28) & 0x07) && (command.RESPONSE[0] & 0x300000))
   \   00000108   0x9804             LDR      R0,[SP, #+16]
   \   0000010A   0x0F00             LSRS     R0,R0,#+28
   \   0000010C   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD02C             BEQ.N    ??LPLD_SDHC_IOC_17
   \   00000114   0x9804             LDR      R0,[SP, #+16]
   \   00000116   0xF410 0x1F40      TST      R0,#0x300000
   \   0000011A   0xD028             BEQ.N    ??LPLD_SDHC_IOC_17
    394                {
    395                  command.COMMAND = ESDHC_CMD5;
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable11_7  ;; 0x5020000
   \   00000120   0x9000             STR      R0,[SP, #+0]
    396                  command.ARGUMENT = 0x300000;
   \   00000122   0xF45F 0x1040      MOVS     R0,#+3145728
   \   00000126   0x9001             STR      R0,[SP, #+4]
    397                  command.BLOCKS = 0;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x9002             STR      R0,[SP, #+8]
    398                  val = 0;
   \   0000012C   0xF05F 0x0B00      MOVS     R11,#+0
    399                  do
    400                  {
    401                    val++;
   \                     ??LPLD_SDHC_IOC_18:
   \   00000130   0xF11B 0x0B01      ADDS     R11,R11,#+1
    402                    if (result = LPLD_SDHC_SendCommand (&command))
   \   00000134   0xA800             ADD      R0,SP,#+0
   \   00000136   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   0000013A   0x0004             MOVS     R4,R0
   \   0000013C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD105             BNE.N    ??LPLD_SDHC_IOC_19
    403                    {
    404                      break;
    405                    }
    406                  } while ((0 == (command.RESPONSE[0] & 0x80000000)) && (val < ESDHC_ALARM_FREQUENCY));
   \                     ??LPLD_SDHC_IOC_20:
   \   00000142   0x9804             LDR      R0,[SP, #+16]
   \   00000144   0x2800             CMP      R0,#+0
   \   00000146   0xD402             BMI.N    ??LPLD_SDHC_IOC_19
   \   00000148   0xF1BB 0x0F64      CMP      R11,#+100
   \   0000014C   0xDBF0             BLT.N    ??LPLD_SDHC_IOC_18
    407                  if (RES_OK != result)
   \                     ??LPLD_SDHC_IOC_19:
   \   0000014E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000150   0x2C00             CMP      R4,#+0
   \   00000152   0xF040 0x8231      BNE.W    ??LPLD_SDHC_IOC_9
    408                  {
    409                    break;
    410                  }
    411                  if (command.RESPONSE[0] & 0x80000000)
   \                     ??LPLD_SDHC_IOC_21:
   \   00000156   0x9804             LDR      R0,[SP, #+16]
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD500             BPL.N    ??LPLD_SDHC_IOC_22
    412                  {
    413                    io = TRUE;
   \   0000015C   0x2601             MOVS     R6,#+1
    414                  }
    415                  if (command.RESPONSE[0] & 0x08000000)
   \                     ??LPLD_SDHC_IOC_22:
   \   0000015E   0x9804             LDR      R0,[SP, #+16]
   \   00000160   0x0100             LSLS     R0,R0,#+4
   \   00000162   0xD504             BPL.N    ??LPLD_SDHC_IOC_17
    416                  {
    417                    mp = TRUE;
   \   00000164   0xF05F 0x0901      MOVS     R9,#+1
   \   00000168   0xE001             B.N      ??LPLD_SDHC_IOC_17
    418                  }
    419                }
    420              }
    421              else
    422              {
    423                mp = TRUE;
   \                     ??LPLD_SDHC_IOC_16:
   \   0000016A   0xF05F 0x0901      MOVS     R9,#+1
    424              }
    425              
    426              if (mp)
   \                     ??LPLD_SDHC_IOC_17:
   \   0000016E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000172   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000176   0xF000 0x80C6      BEQ.W    ??LPLD_SDHC_IOC_23
    427              {
    428                //CMD55 - 特殊应用命令，检查MMC卡
    429                command.COMMAND = ESDHC_CMD55;
   \   0000017A   0x.... 0x....      LDR.W    R0,??DataTable11_8  ;; 0x371a0000
   \   0000017E   0x9000             STR      R0,[SP, #+0]
    430                command.ARGUMENT = 0;
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0x9001             STR      R0,[SP, #+4]
    431                command.BLOCKS = 0;
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0x9002             STR      R0,[SP, #+8]
    432                if ((result = LPLD_SDHC_SendCommand (&command))==RES_ERROR)
   \   00000188   0xA800             ADD      R0,SP,#+0
   \   0000018A   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   0000018E   0x0004             MOVS     R4,R0
   \   00000190   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000192   0x2801             CMP      R0,#+1
   \   00000194   0xF000 0x8210      BEQ.W    ??LPLD_SDHC_IOC_9
    433                {
    434                  break;
    435                }
    436                if (result == RES_NONRSPNS)
   \                     ??LPLD_SDHC_IOC_24:
   \   00000198   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000019A   0x2C05             CMP      R4,#+5
   \   0000019C   0xD154             BNE.N    ??LPLD_SDHC_IOC_25
    437                {
    438                  //如果为MMC 或 CE-ATA 卡
    439                  io = FALSE;
   \   0000019E   0x2600             MOVS     R6,#+0
    440                  mem = FALSE;
   \   000001A0   0x2500             MOVS     R5,#+0
    441                  hc = FALSE;
   \   000001A2   0xF05F 0x0A00      MOVS     R10,#+0
    442                  
    443                  //CMD1 - 发送测试命令，检查高容量支持
    444                  command.COMMAND = ESDHC_CMD1;
   \   000001A6   0xF05F 0x7080      MOVS     R0,#+16777216
   \   000001AA   0x9000             STR      R0,[SP, #+0]
    445                  command.ARGUMENT = 0x40300000;
   \   000001AC   0x.... 0x....      LDR.W    R0,??DataTable11_9  ;; 0x40300000
   \   000001B0   0x9001             STR      R0,[SP, #+4]
    446                  command.BLOCKS = 0;
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0x9002             STR      R0,[SP, #+8]
    447                  if (result = LPLD_SDHC_SendCommand (&command))
   \   000001B6   0xA800             ADD      R0,SP,#+0
   \   000001B8   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000001BC   0x0004             MOVS     R4,R0
   \   000001BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001C0   0x2800             CMP      R0,#+0
   \   000001C2   0xF040 0x81F9      BNE.W    ??LPLD_SDHC_IOC_9
    448                  {
    449                    break;
    450                  }
    451                  if (0x20000000 == (command.RESPONSE[0] & 0x60000000))
   \                     ??LPLD_SDHC_IOC_26:
   \   000001C6   0x9804             LDR      R0,[SP, #+16]
   \   000001C8   0xF010 0x40C0      ANDS     R0,R0,#0x60000000
   \   000001CC   0xF1B0 0x5F00      CMP      R0,#+536870912
   \   000001D0   0xD101             BNE.N    ??LPLD_SDHC_IOC_27
    452                  {
    453                    hc = TRUE;
   \   000001D2   0xF05F 0x0A01      MOVS     R10,#+1
    454                  }
    455                  mmc = TRUE;
   \                     ??LPLD_SDHC_IOC_27:
   \   000001D6   0x2701             MOVS     R7,#+1
    456                  
    457                  //CMD39 - 快速IO，检查CE-ATA的CE签名 */
    458                  command.COMMAND = ESDHC_CMD39;
   \   000001D8   0x.... 0x....      LDR.W    R0,??DataTable11_10  ;; 0x27020000
   \   000001DC   0x9000             STR      R0,[SP, #+0]
    459                  command.ARGUMENT = 0x0C00;
   \   000001DE   0xF44F 0x6040      MOV      R0,#+3072
   \   000001E2   0x9001             STR      R0,[SP, #+4]
    460                  command.BLOCKS = 0;
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0x9002             STR      R0,[SP, #+8]
    461                  if (result = LPLD_SDHC_SendCommand (&command))
   \   000001E8   0xA800             ADD      R0,SP,#+0
   \   000001EA   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000001EE   0x0004             MOVS     R4,R0
   \   000001F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F2   0x2800             CMP      R0,#+0
   \   000001F4   0xF040 0x81E0      BNE.W    ??LPLD_SDHC_IOC_9
    462                  {
    463                    break;
    464                  }
    465                  if (0xCE == (command.RESPONSE[0] >> 8) & 0xFF)
   \                     ??LPLD_SDHC_IOC_28:
   \   000001F8   0x9804             LDR      R0,[SP, #+16]
   \   000001FA   0x0A00             LSRS     R0,R0,#+8
   \   000001FC   0x28CE             CMP      R0,#+206
   \   000001FE   0xD101             BNE.N    ??LPLD_SDHC_IOC_29
   \   00000200   0x2001             MOVS     R0,#+1
   \   00000202   0xE000             B.N      ??LPLD_SDHC_IOC_30
   \                     ??LPLD_SDHC_IOC_29:
   \   00000204   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_IOC_30:
   \   00000206   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000208   0x2800             CMP      R0,#+0
   \   0000020A   0xD07C             BEQ.N    ??LPLD_SDHC_IOC_23
    466                  {
    467                    //CMD39 - 快速IO，检查CE-ATA的AA签名 */
    468                    command.COMMAND = ESDHC_CMD39;
   \   0000020C   0x.... 0x....      LDR.W    R0,??DataTable11_10  ;; 0x27020000
   \   00000210   0x9000             STR      R0,[SP, #+0]
    469                    command.ARGUMENT = 0x0D00;
   \   00000212   0xF44F 0x6050      MOV      R0,#+3328
   \   00000216   0x9001             STR      R0,[SP, #+4]
    470                    command.BLOCKS = 0;
   \   00000218   0x2000             MOVS     R0,#+0
   \   0000021A   0x9002             STR      R0,[SP, #+8]
    471                    if (result = LPLD_SDHC_SendCommand (&command))
   \   0000021C   0xA800             ADD      R0,SP,#+0
   \   0000021E   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   00000222   0x0004             MOVS     R4,R0
   \   00000224   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000226   0x2800             CMP      R0,#+0
   \   00000228   0xF040 0x81C6      BNE.W    ??LPLD_SDHC_IOC_9
    472                    {
    473                      break;
    474                    }
    475                    if (0xAA == (command.RESPONSE[0] >> 8) & 0xFF)
   \                     ??LPLD_SDHC_IOC_31:
   \   0000022C   0x9804             LDR      R0,[SP, #+16]
   \   0000022E   0x0A00             LSRS     R0,R0,#+8
   \   00000230   0x28AA             CMP      R0,#+170
   \   00000232   0xD101             BNE.N    ??LPLD_SDHC_IOC_32
   \   00000234   0x2001             MOVS     R0,#+1
   \   00000236   0xE000             B.N      ??LPLD_SDHC_IOC_33
   \                     ??LPLD_SDHC_IOC_32:
   \   00000238   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_IOC_33:
   \   0000023A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000023C   0x2800             CMP      R0,#+0
   \   0000023E   0xD062             BEQ.N    ??LPLD_SDHC_IOC_23
    476                    {
    477                      mmc = FALSE;
   \   00000240   0x2700             MOVS     R7,#+0
    478                      ceata = TRUE;
   \   00000242   0xF05F 0x0801      MOVS     R8,#+1
   \   00000246   0xE05E             B.N      ??LPLD_SDHC_IOC_23
    479                    }
    480                  }
    481                }
    482                else
    483                {
    484                  //如果为SD卡
    485                  //ACMD41 - 发送操作状态
    486                  command.COMMAND = ESDHC_ACMD41;
   \                     ??LPLD_SDHC_IOC_25:
   \   00000248   0x.... 0x....      LDR.W    R0,??DataTable11_11  ;; 0x29020000
   \   0000024C   0x9000             STR      R0,[SP, #+0]
    487                  command.ARGUMENT = 0;
   \   0000024E   0x2000             MOVS     R0,#+0
   \   00000250   0x9001             STR      R0,[SP, #+4]
    488                  command.BLOCKS = 0;
   \   00000252   0x2000             MOVS     R0,#+0
   \   00000254   0x9002             STR      R0,[SP, #+8]
    489                  if (result = LPLD_SDHC_SendCommand (&command))
   \   00000256   0xA800             ADD      R0,SP,#+0
   \   00000258   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   0000025C   0x0004             MOVS     R4,R0
   \   0000025E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000260   0x2800             CMP      R0,#+0
   \   00000262   0xD005             BEQ.N    ??LPLD_SDHC_IOC_34
    490                  {
    491                    sdcard_ptr->STATUS = STA_NOINIT;
   \   00000264   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000268   0x6800             LDR      R0,[R0, #+0]
   \   0000026A   0x2101             MOVS     R1,#+1
   \   0000026C   0x6141             STR      R1,[R0, #+20]
    492                    break;
   \   0000026E   0xE1A3             B.N      ??LPLD_SDHC_IOC_9
    493                  }
    494                  if (command.RESPONSE[0] & 0x300000)
   \                     ??LPLD_SDHC_IOC_34:
   \   00000270   0x9804             LDR      R0,[SP, #+16]
   \   00000272   0xF410 0x1F40      TST      R0,#0x300000
   \   00000276   0xD046             BEQ.N    ??LPLD_SDHC_IOC_23
    495                  {
    496                    val = 0;
   \   00000278   0xF05F 0x0B00      MOVS     R11,#+0
    497                    do
    498                    {
    499                      val++;
   \                     ??LPLD_SDHC_IOC_35:
   \   0000027C   0xF11B 0x0B01      ADDS     R11,R11,#+1
    500                      
    501                      //CMD55 + ACMD41 - 发送OCR
    502                      command.COMMAND = ESDHC_CMD55;
   \   00000280   0x.... 0x....      LDR.W    R0,??DataTable11_8  ;; 0x371a0000
   \   00000284   0x9000             STR      R0,[SP, #+0]
    503                      command.ARGUMENT = 0;
   \   00000286   0x2000             MOVS     R0,#+0
   \   00000288   0x9001             STR      R0,[SP, #+4]
    504                      command.BLOCKS = 0;
   \   0000028A   0x2000             MOVS     R0,#+0
   \   0000028C   0x9002             STR      R0,[SP, #+8]
    505                      if (result = LPLD_SDHC_SendCommand (&command))
   \   0000028E   0xA800             ADD      R0,SP,#+0
   \   00000290   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   00000294   0x0004             MOVS     R4,R0
   \   00000296   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000298   0x2800             CMP      R0,#+0
   \   0000029A   0xD11D             BNE.N    ??LPLD_SDHC_IOC_36
    506                      {
    507                        break;
    508                      }
    509                      
    510                      command.COMMAND = ESDHC_ACMD41;
   \                     ??LPLD_SDHC_IOC_37:
   \   0000029C   0x.... 0x....      LDR.W    R0,??DataTable11_11  ;; 0x29020000
   \   000002A0   0x9000             STR      R0,[SP, #+0]
    511                      if (hc)
   \   000002A2   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000002A6   0xF1BA 0x0F00      CMP      R10,#+0
   \   000002AA   0xD003             BEQ.N    ??LPLD_SDHC_IOC_38
    512                      {
    513                        command.ARGUMENT = 0x40300000;
   \   000002AC   0x.... 0x....      LDR.W    R0,??DataTable11_9  ;; 0x40300000
   \   000002B0   0x9001             STR      R0,[SP, #+4]
   \   000002B2   0xE002             B.N      ??LPLD_SDHC_IOC_39
    514                      }
    515                      else
    516                      {
    517                        command.ARGUMENT = 0x00300000;
   \                     ??LPLD_SDHC_IOC_38:
   \   000002B4   0xF45F 0x1040      MOVS     R0,#+3145728
   \   000002B8   0x9001             STR      R0,[SP, #+4]
    518                      }
    519                      command.BLOCKS = 0;
   \                     ??LPLD_SDHC_IOC_39:
   \   000002BA   0x2000             MOVS     R0,#+0
   \   000002BC   0x9002             STR      R0,[SP, #+8]
    520                      if (result = LPLD_SDHC_SendCommand (&command))
   \   000002BE   0xA800             ADD      R0,SP,#+0
   \   000002C0   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000002C4   0x0004             MOVS     R4,R0
   \   000002C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002C8   0x2800             CMP      R0,#+0
   \   000002CA   0xD105             BNE.N    ??LPLD_SDHC_IOC_36
    521                      {
    522                        break;
    523                      }
    524                    } while ((0 == (command.RESPONSE[0] & 0x80000000)) && (val < ESDHC_ALARM_FREQUENCY));
   \                     ??LPLD_SDHC_IOC_40:
   \   000002CC   0x9804             LDR      R0,[SP, #+16]
   \   000002CE   0x2800             CMP      R0,#+0
   \   000002D0   0xD402             BMI.N    ??LPLD_SDHC_IOC_36
   \   000002D2   0xF1BB 0x0F64      CMP      R11,#+100
   \   000002D6   0xDBD1             BLT.N    ??LPLD_SDHC_IOC_35
    525                    if (RES_OK != result)
   \                     ??LPLD_SDHC_IOC_36:
   \   000002D8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002DA   0x2C00             CMP      R4,#+0
   \   000002DC   0xF040 0x816C      BNE.W    ??LPLD_SDHC_IOC_9
    526                    {
    527                      break;
    528                    }
    529                    if (val >= ESDHC_ALARM_FREQUENCY)
   \                     ??LPLD_SDHC_IOC_41:
   \   000002E0   0xF1BB 0x0F64      CMP      R11,#+100
   \   000002E4   0xDB02             BLT.N    ??LPLD_SDHC_IOC_42
    530                    {
    531                      hc = FALSE;
   \   000002E6   0xF05F 0x0A00      MOVS     R10,#+0
   \   000002EA   0xE00C             B.N      ??LPLD_SDHC_IOC_23
    532                    }
    533                    else
    534                    {
    535                      mem = TRUE;
   \                     ??LPLD_SDHC_IOC_42:
   \   000002EC   0x2501             MOVS     R5,#+1
    536                      if (hc)
   \   000002EE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000002F2   0xF1BA 0x0F00      CMP      R10,#+0
   \   000002F6   0xD006             BEQ.N    ??LPLD_SDHC_IOC_23
    537                      {
    538                        hc = FALSE;
   \   000002F8   0xF05F 0x0A00      MOVS     R10,#+0
    539                        if (command.RESPONSE[0] & 0x40000000)
   \   000002FC   0x9804             LDR      R0,[SP, #+16]
   \   000002FE   0x0040             LSLS     R0,R0,#+1
   \   00000300   0xD501             BPL.N    ??LPLD_SDHC_IOC_23
    540                        {
    541                          hc = TRUE;
   \   00000302   0xF05F 0x0A01      MOVS     R10,#+1
    542                        }
    543                      }
    544                    }
    545                  }
    546                }
    547              }
    548              if (mmc)
   \                     ??LPLD_SDHC_IOC_23:
   \   00000306   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000308   0x2F00             CMP      R7,#+0
   \   0000030A   0xD004             BEQ.N    ??LPLD_SDHC_IOC_43
    549              {
    550                sdcard_ptr->CARD = ESDHC_CARD_MMC;
   \   0000030C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000310   0x6800             LDR      R0,[R0, #+0]
   \   00000312   0x2107             MOVS     R1,#+7
   \   00000314   0x6101             STR      R1,[R0, #+16]
    551              }
    552              if (ceata)
   \                     ??LPLD_SDHC_IOC_43:
   \   00000316   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000031A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000031E   0xD004             BEQ.N    ??LPLD_SDHC_IOC_44
    553              {
    554                sdcard_ptr->CARD = ESDHC_CARD_CEATA;
   \   00000320   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000324   0x6800             LDR      R0,[R0, #+0]
   \   00000326   0x2108             MOVS     R1,#+8
   \   00000328   0x6101             STR      R1,[R0, #+16]
    555              }
    556              if (io)
   \                     ??LPLD_SDHC_IOC_44:
   \   0000032A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000032C   0x2E00             CMP      R6,#+0
   \   0000032E   0xD004             BEQ.N    ??LPLD_SDHC_IOC_45
    557              {
    558                sdcard_ptr->CARD = ESDHC_CARD_SDIO;
   \   00000330   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000334   0x6800             LDR      R0,[R0, #+0]
   \   00000336   0x2104             MOVS     R1,#+4
   \   00000338   0x6101             STR      R1,[R0, #+16]
    559              }
    560              if (mem)
   \                     ??LPLD_SDHC_IOC_45:
   \   0000033A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000033C   0x2D00             CMP      R5,#+0
   \   0000033E   0xD00E             BEQ.N    ??LPLD_SDHC_IOC_46
    561              {
    562                sdcard_ptr->CARD = ESDHC_CARD_SD;
   \   00000340   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000344   0x6800             LDR      R0,[R0, #+0]
   \   00000346   0x2102             MOVS     R1,#+2
   \   00000348   0x6101             STR      R1,[R0, #+16]
    563                if (hc)
   \   0000034A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000034E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000352   0xD004             BEQ.N    ??LPLD_SDHC_IOC_46
    564                {
    565                  sdcard_ptr->CARD = ESDHC_CARD_SDHC;
   \   00000354   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000358   0x6800             LDR      R0,[R0, #+0]
   \   0000035A   0x2103             MOVS     R1,#+3
   \   0000035C   0x6101             STR      R1,[R0, #+16]
    566                }
    567              }
    568              if (io && mem)
   \                     ??LPLD_SDHC_IOC_46:
   \   0000035E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000360   0x2E00             CMP      R6,#+0
   \   00000362   0xD011             BEQ.N    ??LPLD_SDHC_IOC_47
   \   00000364   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000366   0x2D00             CMP      R5,#+0
   \   00000368   0xD00E             BEQ.N    ??LPLD_SDHC_IOC_47
    569              {
    570                sdcard_ptr->CARD = ESDHC_CARD_SDCOMBO;
   \   0000036A   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000036E   0x6800             LDR      R0,[R0, #+0]
   \   00000370   0x2105             MOVS     R1,#+5
   \   00000372   0x6101             STR      R1,[R0, #+16]
    571                if (hc)
   \   00000374   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000378   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000037C   0xD004             BEQ.N    ??LPLD_SDHC_IOC_47
    572                {
    573                  sdcard_ptr->CARD = ESDHC_CARD_SDHCCOMBO;
   \   0000037E   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000382   0x6800             LDR      R0,[R0, #+0]
   \   00000384   0x2106             MOVS     R1,#+6
   \   00000386   0x6101             STR      R1,[R0, #+16]
    574                }
    575              }
    576              
    577              //禁用GPIO的SDHC复用
    578              LPLD_SDHC_InitGPIO (0);
   \                     ??LPLD_SDHC_IOC_47:
   \   00000388   0x2000             MOVS     R0,#+0
   \   0000038A   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    579              
    580              //设置SDHC工作状态下的默认波特率
    581              LPLD_SDHC_SetBaudrate (core_clk_khz*1000, 25000000);
   \   0000038E   0x.... 0x....      LDR.W    R1,??DataTable11_12  ;; 0x17d7840
   \   00000392   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   00000396   0x6800             LDR      R0,[R0, #+0]
   \   00000398   0xF44F 0x727A      MOV      R2,#+1000
   \   0000039C   0x4350             MULS     R0,R2,R0
   \   0000039E   0x.... 0x....      BL       LPLD_SDHC_SetBaudrate
    582              
    583              //使能GPIO的SDHC复用
    584              LPLD_SDHC_InitGPIO (0xFFFF);
   \   000003A2   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000003A6   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    585              
    586              if(result == RES_OK)
   \   000003AA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003AC   0x2C00             CMP      R4,#+0
   \   000003AE   0xD104             BNE.N    ??LPLD_SDHC_IOC_48
    587              {
    588                sdcard_ptr->STATUS = STA_OK;
   \   000003B0   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000003B4   0x6800             LDR      R0,[R0, #+0]
   \   000003B6   0x2100             MOVS     R1,#+0
   \   000003B8   0x6141             STR      R1,[R0, #+20]
    589              }
    590              break;
   \                     ??LPLD_SDHC_IOC_48:
   \   000003BA   0xE0FD             B.N      ??LPLD_SDHC_IOC_9
    591            case IO_IOCTL_ESDHC_SEND_COMMAND:
    592              result = LPLD_SDHC_SendCommand ((ESDHC_COMMAND_STRUCT_PTR)param32_ptr);
   \                     ??LPLD_SDHC_IOC_1:
   \   000003BC   0x0028             MOVS     R0,R5
   \   000003BE   0x.... 0x....      BL       LPLD_SDHC_SendCommand
   \   000003C2   0x0004             MOVS     R4,R0
    593              break;
   \   000003C4   0xE0F8             B.N      ??LPLD_SDHC_IOC_9
    594            case IO_IOCTL_ESDHC_GET_BAUDRATE:
    595              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_3:
   \   000003C6   0x2D00             CMP      R5,#+0
   \   000003C8   0xD101             BNE.N    ??LPLD_SDHC_IOC_49
    596              {
    597                result = RES_ERROR;
   \   000003CA   0x2401             MOVS     R4,#+1
   \   000003CC   0xE016             B.N      ??LPLD_SDHC_IOC_50
    598              }
    599              else
    600              {
    601                //获取波特率
    602                val = ((SDHC_BASE_PTR->SYSCTL & SDHC_SYSCTL_SDCLKFS_MASK) >> SDHC_SYSCTL_SDCLKFS_SHIFT) << 1;
   \                     ??LPLD_SDHC_IOC_49:
   \   000003CE   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   000003D2   0x6800             LDR      R0,[R0, #+0]
   \   000003D4   0x09C0             LSRS     R0,R0,#+7
   \   000003D6   0xF410 0x7BFF      ANDS     R11,R0,#0x1FE
    603                val *= ((SDHC_BASE_PTR->SYSCTL & SDHC_SYSCTL_DVS_MASK) >> SDHC_SYSCTL_DVS_SHIFT) + 1;
   \   000003DA   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b102c
   \   000003DE   0x6800             LDR      R0,[R0, #+0]
   \   000003E0   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \   000003E4   0x1C40             ADDS     R0,R0,#+1
   \   000003E6   0xFB00 0xFB0B      MUL      R11,R0,R11
    604                *param32_ptr = (uint32)((core_clk_khz*1000 / val));
   \   000003EA   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   000003EE   0x6800             LDR      R0,[R0, #+0]
   \   000003F0   0xF44F 0x717A      MOV      R1,#+1000
   \   000003F4   0x4348             MULS     R0,R1,R0
   \   000003F6   0xFB90 0xF0FB      SDIV     R0,R0,R11
   \   000003FA   0x6028             STR      R0,[R5, #+0]
    605              }
    606              break;
   \                     ??LPLD_SDHC_IOC_50:
   \   000003FC   0xE0DC             B.N      ??LPLD_SDHC_IOC_9
    607            case IO_IOCTL_ESDHC_SET_BAUDRATE:
    608              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_4:
   \   000003FE   0x2D00             CMP      R5,#+0
   \   00000400   0xD101             BNE.N    ??LPLD_SDHC_IOC_51
    609              {
    610                result = RES_ERROR;
   \   00000402   0x2401             MOVS     R4,#+1
   \   00000404   0xE01A             B.N      ??LPLD_SDHC_IOC_52
    611              }
    612              else if (0 == (*param32_ptr))
   \                     ??LPLD_SDHC_IOC_51:
   \   00000406   0x6828             LDR      R0,[R5, #+0]
   \   00000408   0x2800             CMP      R0,#+0
   \   0000040A   0xD101             BNE.N    ??LPLD_SDHC_IOC_53
    613              {
    614                result = RES_ERROR;
   \   0000040C   0x2401             MOVS     R4,#+1
   \   0000040E   0xE015             B.N      ??LPLD_SDHC_IOC_52
    615              }
    616              else
    617              {
    618                if (! LPLD_SDHC_IsRunning ())
   \                     ??LPLD_SDHC_IOC_53:
   \   00000410   0x.... 0x....      BL       LPLD_SDHC_IsRunning
   \   00000414   0x2800             CMP      R0,#+0
   \   00000416   0xD110             BNE.N    ??LPLD_SDHC_IOC_54
    619                {
    620                  //禁用GPIO的SDHC复用
    621                  LPLD_SDHC_InitGPIO (0);
   \   00000418   0x2000             MOVS     R0,#+0
   \   0000041A   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
    622                  
    623                  //设置波特率
    624                  LPLD_SDHC_SetBaudrate (core_clk_khz*1000, *param32_ptr);
   \   0000041E   0x6829             LDR      R1,[R5, #+0]
   \   00000420   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   00000424   0x6800             LDR      R0,[R0, #+0]
   \   00000426   0xF44F 0x727A      MOV      R2,#+1000
   \   0000042A   0x4350             MULS     R0,R2,R0
   \   0000042C   0x.... 0x....      BL       LPLD_SDHC_SetBaudrate
    625                  
    626                  //使能GPIO的SDHC复用
    627                  LPLD_SDHC_InitGPIO (0xFFFF);
   \   00000430   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000434   0x.... 0x....      BL       LPLD_SDHC_InitGPIO
   \   00000438   0xE000             B.N      ??LPLD_SDHC_IOC_52
    628                }
    629                else
    630                {
    631                  result = RES_ERROR;
   \                     ??LPLD_SDHC_IOC_54:
   \   0000043A   0x2401             MOVS     R4,#+1
    632                }
    633              }
    634              break;
   \                     ??LPLD_SDHC_IOC_52:
   \   0000043C   0xE0BC             B.N      ??LPLD_SDHC_IOC_9
    635            case IO_IOCTL_ESDHC_GET_BUS_WIDTH:
    636              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_5:
   \   0000043E   0x2D00             CMP      R5,#+0
   \   00000440   0xD101             BNE.N    ??LPLD_SDHC_IOC_55
    637              {
    638                result = RES_ERROR;
   \   00000442   0x2401             MOVS     R4,#+1
   \   00000444   0xE017             B.N      ??LPLD_SDHC_IOC_56
    639              }
    640              else
    641              {
    642                //获得SDHC总线宽度
    643                val = (SDHC_BASE_PTR->PROCTL & SDHC_PROCTL_DTW_MASK) >> SDHC_PROCTL_DTW_SHIFT;
   \                     ??LPLD_SDHC_IOC_55:
   \   00000446   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   0000044A   0x6800             LDR      R0,[R0, #+0]
   \   0000044C   0xF3C0 0x0B41      UBFX     R11,R0,#+1,#+2
    644                if (ESDHC_PROCTL_DTW_1BIT == val)
   \   00000450   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000454   0xD102             BNE.N    ??LPLD_SDHC_IOC_57
    645                {
    646                  *param32_ptr = ESDHC_BUS_WIDTH_1BIT;
   \   00000456   0x2000             MOVS     R0,#+0
   \   00000458   0x6028             STR      R0,[R5, #+0]
   \   0000045A   0xE00C             B.N      ??LPLD_SDHC_IOC_56
    647                }
    648                else if (ESDHC_PROCTL_DTW_4BIT == val)
   \                     ??LPLD_SDHC_IOC_57:
   \   0000045C   0xF1BB 0x0F01      CMP      R11,#+1
   \   00000460   0xD102             BNE.N    ??LPLD_SDHC_IOC_58
    649                {
    650                  *param32_ptr = ESDHC_BUS_WIDTH_4BIT;
   \   00000462   0x2001             MOVS     R0,#+1
   \   00000464   0x6028             STR      R0,[R5, #+0]
   \   00000466   0xE006             B.N      ??LPLD_SDHC_IOC_56
    651                }
    652                else if (ESDHC_PROCTL_DTW_8BIT == val)
   \                     ??LPLD_SDHC_IOC_58:
   \   00000468   0xF1BB 0x0F10      CMP      R11,#+16
   \   0000046C   0xD102             BNE.N    ??LPLD_SDHC_IOC_59
    653                {
    654                  *param32_ptr = ESDHC_BUS_WIDTH_8BIT;
   \   0000046E   0x2002             MOVS     R0,#+2
   \   00000470   0x6028             STR      R0,[R5, #+0]
   \   00000472   0xE000             B.N      ??LPLD_SDHC_IOC_56
    655                }
    656                else
    657                {
    658                  result = RES_ERROR;
   \                     ??LPLD_SDHC_IOC_59:
   \   00000474   0x2401             MOVS     R4,#+1
    659                }
    660              }
    661              break;
   \                     ??LPLD_SDHC_IOC_56:
   \   00000476   0xE09F             B.N      ??LPLD_SDHC_IOC_9
    662            case IO_IOCTL_ESDHC_SET_BUS_WIDTH:
    663              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_6:
   \   00000478   0x2D00             CMP      R5,#+0
   \   0000047A   0xD101             BNE.N    ??LPLD_SDHC_IOC_60
    664              {
    665                result = RES_ERROR;
   \   0000047C   0x2401             MOVS     R4,#+1
   \   0000047E   0xE03E             B.N      ??LPLD_SDHC_IOC_61
    666              }
    667              else
    668              {
    669                //设置SDHC总线宽度
    670                if (! LPLD_SDHC_IsRunning ())
   \                     ??LPLD_SDHC_IOC_60:
   \   00000480   0x.... 0x....      BL       LPLD_SDHC_IsRunning
   \   00000484   0x2800             CMP      R0,#+0
   \   00000486   0xD139             BNE.N    ??LPLD_SDHC_IOC_62
    671                {
    672                  if (ESDHC_BUS_WIDTH_1BIT == *param32_ptr)
   \   00000488   0x6828             LDR      R0,[R5, #+0]
   \   0000048A   0x2800             CMP      R0,#+0
   \   0000048C   0xD10E             BNE.N    ??LPLD_SDHC_IOC_63
    673                  {
    674                    SDHC_BASE_PTR->PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   0000048E   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   00000492   0x6800             LDR      R0,[R0, #+0]
   \   00000494   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000498   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x400b1028
   \   0000049C   0x6008             STR      R0,[R1, #+0]
    675                    SDHC_BASE_PTR->PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_1BIT);
   \   0000049E   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   000004A2   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x400b1028
   \   000004A6   0x6809             LDR      R1,[R1, #+0]
   \   000004A8   0x6001             STR      R1,[R0, #+0]
   \   000004AA   0xE028             B.N      ??LPLD_SDHC_IOC_61
    676                  }
    677                  else if (ESDHC_BUS_WIDTH_4BIT == *param32_ptr)
   \                     ??LPLD_SDHC_IOC_63:
   \   000004AC   0x6828             LDR      R0,[R5, #+0]
   \   000004AE   0x2801             CMP      R0,#+1
   \   000004B0   0xD110             BNE.N    ??LPLD_SDHC_IOC_64
    678                  {
    679                    SDHC_BASE_PTR->PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   000004B2   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   000004B6   0x6800             LDR      R0,[R0, #+0]
   \   000004B8   0xF030 0x0006      BICS     R0,R0,#0x6
   \   000004BC   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x400b1028
   \   000004C0   0x6008             STR      R0,[R1, #+0]
    680                    SDHC_BASE_PTR->PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_4BIT);
   \   000004C2   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   000004C6   0x6800             LDR      R0,[R0, #+0]
   \   000004C8   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000004CC   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x400b1028
   \   000004D0   0x6008             STR      R0,[R1, #+0]
   \   000004D2   0xE014             B.N      ??LPLD_SDHC_IOC_61
    681                  }
    682                  else if (ESDHC_BUS_WIDTH_8BIT == *param32_ptr)
   \                     ??LPLD_SDHC_IOC_64:
   \   000004D4   0x6828             LDR      R0,[R5, #+0]
   \   000004D6   0x2802             CMP      R0,#+2
   \   000004D8   0xD10E             BNE.N    ??LPLD_SDHC_IOC_65
    683                  {
    684                    SDHC_BASE_PTR->PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   000004DA   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   000004DE   0x6800             LDR      R0,[R0, #+0]
   \   000004E0   0xF030 0x0006      BICS     R0,R0,#0x6
   \   000004E4   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x400b1028
   \   000004E8   0x6008             STR      R0,[R1, #+0]
    685                    SDHC_BASE_PTR->PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_8BIT);
   \   000004EA   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x400b1028
   \   000004EE   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x400b1028
   \   000004F2   0x6809             LDR      R1,[R1, #+0]
   \   000004F4   0x6001             STR      R1,[R0, #+0]
   \   000004F6   0xE002             B.N      ??LPLD_SDHC_IOC_61
    686                  }
    687                  else
    688                  {
    689                    result = RES_ERROR;
   \                     ??LPLD_SDHC_IOC_65:
   \   000004F8   0x2401             MOVS     R4,#+1
   \   000004FA   0xE000             B.N      ??LPLD_SDHC_IOC_61
    690                  }
    691                }
    692                else
    693                {
    694                  result = RES_ERROR;
   \                     ??LPLD_SDHC_IOC_62:
   \   000004FC   0x2401             MOVS     R4,#+1
    695                }
    696              }
    697              break;
   \                     ??LPLD_SDHC_IOC_61:
   \   000004FE   0xE05B             B.N      ??LPLD_SDHC_IOC_9
    698            case IO_IOCTL_ESDHC_GET_CARD:
    699              if (NULL == param32_ptr)
   \                     ??LPLD_SDHC_IOC_2:
   \   00000500   0x2D00             CMP      R5,#+0
   \   00000502   0xD101             BNE.N    ??LPLD_SDHC_IOC_66
    700              {
    701                result = RES_ERROR;
   \   00000504   0x2401             MOVS     R4,#+1
   \   00000506   0xE03A             B.N      ??LPLD_SDHC_IOC_67
    702              }
    703              else
    704              {
    705                //等待80个时钟
    706                SDHC_BASE_PTR->SYSCTL |= SDHC_SYSCTL_INITA_MASK;
   \                     ??LPLD_SDHC_IOC_66:
   \   00000508   0x....             LDR.N    R0,??DataTable8_6  ;; 0x400b102c
   \   0000050A   0x6800             LDR      R0,[R0, #+0]
   \   0000050C   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000510   0x....             LDR.N    R1,??DataTable8_6  ;; 0x400b102c
   \   00000512   0x6008             STR      R0,[R1, #+0]
    707                while (SDHC_BASE_PTR->SYSCTL & SDHC_SYSCTL_INITA_MASK)
   \                     ??LPLD_SDHC_IOC_68:
   \   00000514   0x....             LDR.N    R0,??DataTable8_6  ;; 0x400b102c
   \   00000516   0x6800             LDR      R0,[R0, #+0]
   \   00000518   0x0100             LSLS     R0,R0,#+4
   \   0000051A   0xD4FB             BMI.N    ??LPLD_SDHC_IOC_68
    708                { };
    709                
    710                //更新并返回卡实际状态
    711                if (SDHC_BASE_PTR->IRQSTAT & SDHC_IRQSTAT_CRM_MASK)
   \   0000051C   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000520   0x6800             LDR      R0,[R0, #+0]
   \   00000522   0x0600             LSLS     R0,R0,#+24
   \   00000524   0xD511             BPL.N    ??LPLD_SDHC_IOC_69
    712                {
    713                  SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \   00000526   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   0000052A   0x6800             LDR      R0,[R0, #+0]
   \   0000052C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000530   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000534   0x6008             STR      R0,[R1, #+0]
    714                  sdcard_ptr->CARD = ESDHC_CARD_NONE;
   \   00000536   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000053A   0x6800             LDR      R0,[R0, #+0]
   \   0000053C   0x2100             MOVS     R1,#+0
   \   0000053E   0x6101             STR      R1,[R0, #+16]
    715                  sdcard_ptr->STATUS = STA_NODISK;
   \   00000540   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000544   0x6800             LDR      R0,[R0, #+0]
   \   00000546   0x2102             MOVS     R1,#+2
   \   00000548   0x6141             STR      R1,[R0, #+20]
    716                }
    717                if (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_CINS_MASK)
   \                     ??LPLD_SDHC_IOC_69:
   \   0000054A   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400b1024
   \   0000054C   0x6800             LDR      R0,[R0, #+0]
   \   0000054E   0x03C0             LSLS     R0,R0,#+15
   \   00000550   0xD50B             BPL.N    ??LPLD_SDHC_IOC_70
    718                {
    719                  if (ESDHC_CARD_NONE == sdcard_ptr->CARD)
   \   00000552   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000556   0x6800             LDR      R0,[R0, #+0]
   \   00000558   0x6900             LDR      R0,[R0, #+16]
   \   0000055A   0x2800             CMP      R0,#+0
   \   0000055C   0xD10A             BNE.N    ??LPLD_SDHC_IOC_71
    720                  {
    721                    sdcard_ptr->CARD = ESDHC_CARD_UNKNOWN;
   \   0000055E   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000562   0x6800             LDR      R0,[R0, #+0]
   \   00000564   0x2101             MOVS     R1,#+1
   \   00000566   0x6101             STR      R1,[R0, #+16]
   \   00000568   0xE004             B.N      ??LPLD_SDHC_IOC_71
    722                  }
    723                }
    724                else
    725                {
    726                  sdcard_ptr->CARD = ESDHC_CARD_NONE;
   \                     ??LPLD_SDHC_IOC_70:
   \   0000056A   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000056E   0x6800             LDR      R0,[R0, #+0]
   \   00000570   0x2100             MOVS     R1,#+0
   \   00000572   0x6101             STR      R1,[R0, #+16]
    727                }
    728                *param32_ptr = sdcard_ptr->CARD;
   \                     ??LPLD_SDHC_IOC_71:
   \   00000574   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000578   0x6800             LDR      R0,[R0, #+0]
   \   0000057A   0x6900             LDR      R0,[R0, #+16]
   \   0000057C   0x6028             STR      R0,[R5, #+0]
    729              }
    730              break;
   \                     ??LPLD_SDHC_IOC_67:
   \   0000057E   0xE01B             B.N      ??LPLD_SDHC_IOC_9
    731              
    732            case IO_IOCTL_FLUSH_OUTPUT:
    733              //等待传输完成
    734              LPLD_SDHC_WaitStatus (SDHC_IRQSTAT_TC_MASK);
   \                     ??LPLD_SDHC_IOC_7:
   \   00000580   0x2002             MOVS     R0,#+2
   \   00000582   0x.... 0x....      BL       LPLD_SDHC_WaitStatus
    735              if (SDHC_BASE_PTR->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   00000586   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   0000058A   0x6800             LDR      R0,[R0, #+0]
   \   0000058C   0xF410 0x0FE0      TST      R0,#0x700000
   \   00000590   0xD008             BEQ.N    ??LPLD_SDHC_IOC_72
    736              {
    737                SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK;
   \   00000592   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000596   0x6800             LDR      R0,[R0, #+0]
   \   00000598   0xF450 0x00E0      ORRS     R0,R0,#0x700000
   \   0000059C   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000005A0   0x6008             STR      R0,[R1, #+0]
    738                result = RES_ERROR;
   \   000005A2   0x2401             MOVS     R4,#+1
    739              }
    740              SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_TC_MASK | SDHC_IRQSTAT_BRR_MASK | SDHC_IRQSTAT_BWR_MASK;
   \                     ??LPLD_SDHC_IOC_72:
   \   000005A4   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000005A8   0x6800             LDR      R0,[R0, #+0]
   \   000005AA   0xF050 0x0032      ORRS     R0,R0,#0x32
   \   000005AE   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000005B2   0x6008             STR      R0,[R1, #+0]
    741              break;
   \   000005B4   0xE000             B.N      ??LPLD_SDHC_IOC_9
    742            default:
    743              result = RES_ERROR;
   \                     ??LPLD_SDHC_IOC_8:
   \   000005B6   0x2401             MOVS     R4,#+1
    744              break;
    745            }
    746            
    747            
    748            return result;
   \                     ??LPLD_SDHC_IOC_9:
   \   000005B8   0x0020             MOVS     R0,R4
   \   000005BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005BC   0xB009             ADD      SP,SP,#+36
   \   000005BE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    749          }
    750          
    751          /*
    752           * LPLD_SDHC_Read
    753           * SDHC读操作
    754           * 
    755           * 参数:
    756           *    *data_ptr--存储数据地址指针
    757           *    n--待读的数据长度
    758           *
    759           * 输出:
    760           *    DRESULT--磁盘功能返回值
    761           */

   \                                 In section .text, align 2, keep-with-next
    762          static DSTATUS LPLD_SDHC_Read(uint8 *data_ptr, int32 n)
    763          {
   \                     LPLD_SDHC_Read:
   \   00000000   0xB410             PUSH     {R4}
    764            uint32 buffer;
    765            int32 remains;
    766            
    767            remains = n;
   \   00000002   0x000A             MOVS     R2,R1
    768            if (((uint32)data_ptr & 0x03) == 0)
   \   00000004   0xF010 0x0303      ANDS     R3,R0,#0x3
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD139             BNE.N    ??LPLD_SDHC_Read_0
   \   0000000C   0xE00D             B.N      ??LPLD_SDHC_Read_1
    769            {    
    770              //数据位字对齐，可以以最快的速度直接从寄存器拷贝
    771              while (remains >= 4)
    772              {
    773                if (SDHC_BASE_PTR->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
    774                {
    775                  SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
    776                  return RES_ERROR;
    777                }
    778                
    779                //等待，直到收到的数据达到水印长度或传输完成
    780                while ((0 == (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_BREN_MASK)) && (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_DLA_MASK))
   \                     ??LPLD_SDHC_Read_2:
   \   0000000E   0x....             LDR.N    R3,??DataTable8_8  ;; 0x400b1024
   \   00000010   0x681B             LDR      R3,[R3, #+0]
   \   00000012   0x051B             LSLS     R3,R3,#+20
   \   00000014   0xD403             BMI.N    ??LPLD_SDHC_Read_3
   \   00000016   0x....             LDR.N    R3,??DataTable8_8  ;; 0x400b1024
   \   00000018   0x681B             LDR      R3,[R3, #+0]
   \   0000001A   0x075B             LSLS     R3,R3,#+29
   \   0000001C   0xD4F7             BMI.N    ??LPLD_SDHC_Read_2
    781                { };
    782                
    783                *((uint32 *)data_ptr) = SDHC_BASE_PTR->DATPORT;
   \                     ??LPLD_SDHC_Read_3:
   \   0000001E   0x.... 0x....      LDR.W    R3,??DataTable11_13  ;; 0x400b1020
   \   00000022   0x681B             LDR      R3,[R3, #+0]
   \   00000024   0x6003             STR      R3,[R0, #+0]
    784                data_ptr += 4;
   \   00000026   0x1D00             ADDS     R0,R0,#+4
    785                remains -= 4;
   \   00000028   0x1F12             SUBS     R2,R2,#+4
   \                     ??LPLD_SDHC_Read_1:
   \   0000002A   0x2A04             CMP      R2,#+4
   \   0000002C   0xDB3C             BLT.N    ??LPLD_SDHC_Read_4
   \   0000002E   0x.... 0x....      LDR.W    R3,??DataTable10  ;; 0x400b1030
   \   00000032   0x681B             LDR      R3,[R3, #+0]
   \   00000034   0xF413 0x0FE0      TST      R3,#0x700000
   \   00000038   0xD0E9             BEQ.N    ??LPLD_SDHC_Read_2
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000044   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE063             B.N      ??LPLD_SDHC_Read_5
    786              }
    787            }
    788            else
    789            {
    790              //非对齐数据，读到临时区域并以字节复制
    791              while (remains >= 4)
    792              {
    793                if (SDHC_BASE_PTR->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
    794                {
    795                  SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
    796                  return RES_ERROR;
    797                }
    798                
    799                //等待，直到收到的数据达到水印长度或传输完成
    800                while ((0 == (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_BREN_MASK)) && (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_DLA_MASK))
   \                     ??LPLD_SDHC_Read_6:
   \   00000052   0x....             LDR.N    R3,??DataTable8_8  ;; 0x400b1024
   \   00000054   0x681B             LDR      R3,[R3, #+0]
   \   00000056   0x051B             LSLS     R3,R3,#+20
   \   00000058   0xD403             BMI.N    ??LPLD_SDHC_Read_7
   \   0000005A   0x....             LDR.N    R3,??DataTable8_8  ;; 0x400b1024
   \   0000005C   0x681B             LDR      R3,[R3, #+0]
   \   0000005E   0x075B             LSLS     R3,R3,#+29
   \   00000060   0xD4F7             BMI.N    ??LPLD_SDHC_Read_6
    801                { };
    802                
    803                buffer = SDHC_BASE_PTR->DATPORT;
   \                     ??LPLD_SDHC_Read_7:
   \   00000062   0x.... 0x....      LDR.W    R3,??DataTable11_13  ;; 0x400b1020
   \   00000066   0x681B             LDR      R3,[R3, #+0]
    804                
    805                *data_ptr++ = buffer & 0xFF;
   \   00000068   0x7003             STRB     R3,[R0, #+0]
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
    806                *data_ptr++ = (buffer >> 8) & 0xFF;
   \   0000006C   0x0A1C             LSRS     R4,R3,#+8
   \   0000006E   0x7004             STRB     R4,[R0, #+0]
   \   00000070   0x1C40             ADDS     R0,R0,#+1
    807                *data_ptr++ = (buffer >> 16) & 0xFF;
   \   00000072   0x0C1C             LSRS     R4,R3,#+16
   \   00000074   0x7004             STRB     R4,[R0, #+0]
   \   00000076   0x1C40             ADDS     R0,R0,#+1
    808                *data_ptr++ = (buffer >> 24) & 0xFF;
   \   00000078   0x0E1B             LSRS     R3,R3,#+24
   \   0000007A   0x7003             STRB     R3,[R0, #+0]
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
    809                
    810                remains -= 4;
   \   0000007E   0x1F12             SUBS     R2,R2,#+4
   \                     ??LPLD_SDHC_Read_0:
   \   00000080   0x2A04             CMP      R2,#+4
   \   00000082   0xDB11             BLT.N    ??LPLD_SDHC_Read_4
   \   00000084   0x.... 0x....      LDR.W    R3,??DataTable10  ;; 0x400b1030
   \   00000088   0x681B             LDR      R3,[R3, #+0]
   \   0000008A   0xF413 0x0FE0      TST      R3,#0x700000
   \   0000008E   0xD0E0             BEQ.N    ??LPLD_SDHC_Read_6
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   0000009A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000A2   0x6008             STR      R0,[R1, #+0]
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xE038             B.N      ??LPLD_SDHC_Read_5
    811              }      
    812            }
    813            
    814            if (remains)
   \                     ??LPLD_SDHC_Read_4:
   \   000000A8   0x2A00             CMP      R2,#+0
   \   000000AA   0xD023             BEQ.N    ??LPLD_SDHC_Read_8
    815            {
    816              //剩下的少于单字长度数据
    817              if (SDHC_BASE_PTR->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   000000AC   0x.... 0x....      LDR.W    R3,??DataTable10  ;; 0x400b1030
   \   000000B0   0x681B             LDR      R3,[R3, #+0]
   \   000000B2   0xF413 0x0FE0      TST      R3,#0x700000
   \   000000B6   0xD00B             BEQ.N    ??LPLD_SDHC_Read_9
    818              {
    819                SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   000000C2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000CA   0x6008             STR      R0,[R1, #+0]
    820                return RES_ERROR;
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0xE024             B.N      ??LPLD_SDHC_Read_5
    821              }
    822              
    823              //等待，直到收到的数据达到水印长度或传输完成
    824              while ((0 == (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_BREN_MASK)) && (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_DLA_MASK))
   \                     ??LPLD_SDHC_Read_9:
   \   000000D0   0x....             LDR.N    R3,??DataTable8_8  ;; 0x400b1024
   \   000000D2   0x681B             LDR      R3,[R3, #+0]
   \   000000D4   0x051B             LSLS     R3,R3,#+20
   \   000000D6   0xD403             BMI.N    ??LPLD_SDHC_Read_10
   \   000000D8   0x....             LDR.N    R3,??DataTable8_8  ;; 0x400b1024
   \   000000DA   0x681B             LDR      R3,[R3, #+0]
   \   000000DC   0x075B             LSLS     R3,R3,#+29
   \   000000DE   0xD4F7             BMI.N    ??LPLD_SDHC_Read_9
    825              { };
    826              
    827              buffer = SDHC_BASE_PTR->DATPORT;
   \                     ??LPLD_SDHC_Read_10:
   \   000000E0   0x.... 0x....      LDR.W    R3,??DataTable11_13  ;; 0x400b1020
   \   000000E4   0x681B             LDR      R3,[R3, #+0]
   \   000000E6   0xE003             B.N      ??LPLD_SDHC_Read_11
    828              while (remains)
    829              {
    830                
    831                *data_ptr++ = buffer & 0xFF;
   \                     ??LPLD_SDHC_Read_12:
   \   000000E8   0x7003             STRB     R3,[R0, #+0]
   \   000000EA   0x1C40             ADDS     R0,R0,#+1
    832                buffer >>= 8;
   \   000000EC   0x0A1B             LSRS     R3,R3,#+8
    833                
    834                remains--;
   \   000000EE   0x1E52             SUBS     R2,R2,#+1
    835              }
   \                     ??LPLD_SDHC_Read_11:
   \   000000F0   0x2A00             CMP      R2,#+0
   \   000000F2   0xD1F9             BNE.N    ??LPLD_SDHC_Read_12
    836            }
    837            
    838            if (SDHC_BASE_PTR->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \                     ??LPLD_SDHC_Read_8:
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000F8   0x6800             LDR      R0,[R0, #+0]
   \   000000FA   0xF410 0x0FE0      TST      R0,#0x700000
   \   000000FE   0xD00B             BEQ.N    ??LPLD_SDHC_Read_13
    839            {
    840              SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000104   0x6800             LDR      R0,[R0, #+0]
   \   00000106   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   0000010A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000112   0x6008             STR      R0,[R1, #+0]
    841              return RES_ERROR;
   \   00000114   0x2001             MOVS     R0,#+1
   \   00000116   0xE000             B.N      ??LPLD_SDHC_Read_5
    842            }
    843            
    844            return (n - remains);
   \                     ??LPLD_SDHC_Read_13:
   \   00000118   0x1A88             SUBS     R0,R1,R2
   \                     ??LPLD_SDHC_Read_5:
   \   0000011A   0xBC10             POP      {R4}
   \   0000011C   0x4770             BX       LR               ;; return
    845          }
    846          
    847          /*
    848           * LPLD_SDHC_Write
    849           * SDHC写操作
    850           * 
    851           * 参数:
    852           *    *data_ptr--存储数据地址指针
    853           *    n--待写的数据长度
    854           *
    855           * 输出:
    856           *    DRESULT--磁盘功能返回值
    857           */

   \                                 In section .text, align 2, keep-with-next
    858          static DSTATUS LPLD_SDHC_Write(uint8 *data_ptr, int32 n)
    859          {
   \                     LPLD_SDHC_Write:
   \   00000000   0xB410             PUSH     {R4}
    860            uint8 *udata_ptr;
    861            uint32 buffer;
    862            int32 remains;
    863            
    864            //复制数据指针
    865            udata_ptr = (uint8 *)data_ptr;
    866            
    867            remains = n;
   \   00000002   0x000A             MOVS     R2,R1
    868            if (((uint32)udata_ptr & 0x03) == 0)
   \   00000004   0xF010 0x0303      ANDS     R3,R0,#0x3
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD138             BNE.N    ??LPLD_SDHC_Write_0
   \   0000000C   0xE009             B.N      ??LPLD_SDHC_Write_1
    869            {
    870              //数据位字对齐，可以以最快的速度直接拷贝到寄存器
    871              while (remains >= 4)
    872              {
    873                if (SDHC_BASE_PTR->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
    874                {
    875                  SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
    876                  return RES_ERROR;
    877                }
    878                
    879                //等待，直到水印空间可用 
    880                while (0 == (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
   \                     ??LPLD_SDHC_Write_2:
   \   0000000E   0x....             LDR.N    R3,??DataTable8_8  ;; 0x400b1024
   \   00000010   0x681B             LDR      R3,[R3, #+0]
   \   00000012   0x055B             LSLS     R3,R3,#+21
   \   00000014   0xD5FB             BPL.N    ??LPLD_SDHC_Write_2
    881                { };
    882                
    883                SDHC_BASE_PTR->DATPORT = *((uint32 *)udata_ptr);
   \   00000016   0x.... 0x....      LDR.W    R3,??DataTable11_13  ;; 0x400b1020
   \   0000001A   0x6804             LDR      R4,[R0, #+0]
   \   0000001C   0x601C             STR      R4,[R3, #+0]
    884                udata_ptr += 4;
   \   0000001E   0x1D00             ADDS     R0,R0,#+4
    885                remains -= 4;
   \   00000020   0x1F12             SUBS     R2,R2,#+4
   \                     ??LPLD_SDHC_Write_1:
   \   00000022   0x2A04             CMP      R2,#+4
   \   00000024   0xDB3C             BLT.N    ??LPLD_SDHC_Write_3
   \   00000026   0x.... 0x....      LDR.W    R3,??DataTable10  ;; 0x400b1030
   \   0000002A   0x681B             LDR      R3,[R3, #+0]
   \   0000002C   0xF413 0x0FE0      TST      R3,#0x700000
   \   00000030   0xD0ED             BEQ.N    ??LPLD_SDHC_Write_2
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   0000003C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xE05B             B.N      ??LPLD_SDHC_Write_4
    886              }
    887            }
    888            else
    889            {
    890              //非对齐数据，写到临时区域并以字节复制
    891              while (remains >= 4)
    892              {
    893                if (SDHC_BASE_PTR->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
    894                {
    895                  SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
    896                  return RES_ERROR;
    897                }
    898                
    899                //等待，直到水印空间可用 
    900                while (0 == (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
   \                     ??LPLD_SDHC_Write_5:
   \   0000004A   0x....             LDR.N    R3,??DataTable8_8  ;; 0x400b1024
   \   0000004C   0x681B             LDR      R3,[R3, #+0]
   \   0000004E   0x055B             LSLS     R3,R3,#+21
   \   00000050   0xD5FB             BPL.N    ??LPLD_SDHC_Write_5
    901                { };
    902                
    903                buffer  = (*udata_ptr++);
   \   00000052   0x7803             LDRB     R3,[R0, #+0]
   \   00000054   0x1C40             ADDS     R0,R0,#+1
    904                buffer |= (*udata_ptr++) << 8;
   \   00000056   0x7804             LDRB     R4,[R0, #+0]
   \   00000058   0xEA53 0x2304      ORRS     R3,R3,R4, LSL #+8
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
    905                buffer |= (*udata_ptr++) << 16;
   \   0000005E   0x7804             LDRB     R4,[R0, #+0]
   \   00000060   0xEA53 0x4304      ORRS     R3,R3,R4, LSL #+16
   \   00000064   0x1C40             ADDS     R0,R0,#+1
    906                buffer |= (*udata_ptr++) << 24;
   \   00000066   0x7804             LDRB     R4,[R0, #+0]
   \   00000068   0xEA53 0x6304      ORRS     R3,R3,R4, LSL #+24
   \   0000006C   0x1C40             ADDS     R0,R0,#+1
    907                
    908                //等待，直到水印空间可用 
    909                while (0 == (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
   \                     ??LPLD_SDHC_Write_6:
   \   0000006E   0x....             LDR.N    R4,??DataTable8_8  ;; 0x400b1024
   \   00000070   0x6824             LDR      R4,[R4, #+0]
   \   00000072   0x0564             LSLS     R4,R4,#+21
   \   00000074   0xD5FB             BPL.N    ??LPLD_SDHC_Write_6
    910                { };
    911                
    912                SDHC_BASE_PTR->DATPORT = buffer;
   \   00000076   0x.... 0x....      LDR.W    R4,??DataTable11_13  ;; 0x400b1020
   \   0000007A   0x6023             STR      R3,[R4, #+0]
    913                remains -= 4;
   \   0000007C   0x1F12             SUBS     R2,R2,#+4
   \                     ??LPLD_SDHC_Write_0:
   \   0000007E   0x2A04             CMP      R2,#+4
   \   00000080   0xDB0E             BLT.N    ??LPLD_SDHC_Write_3
   \   00000082   0x....             LDR.N    R3,??DataTable10  ;; 0x400b1030
   \   00000084   0x681B             LDR      R3,[R3, #+0]
   \   00000086   0xF413 0x0FE0      TST      R3,#0x700000
   \   0000008A   0xD0DE             BEQ.N    ??LPLD_SDHC_Write_5
   \   0000008C   0x....             LDR.N    R0,??DataTable10  ;; 0x400b1030
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000094   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000098   0x....             LDR.N    R1,??DataTable10  ;; 0x400b1030
   \   0000009A   0x6008             STR      R0,[R1, #+0]
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE030             B.N      ??LPLD_SDHC_Write_4
    914              }      
    915            }
    916            
    917            if (remains)
   \                     ??LPLD_SDHC_Write_3:
   \   000000A0   0x2A00             CMP      R2,#+0
   \   000000A2   0xD01E             BEQ.N    ??LPLD_SDHC_Write_7
    918            {
    919              //剩余少于单字长度的数据
    920              if (SDHC_BASE_PTR->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   000000A4   0x....             LDR.N    R3,??DataTable10  ;; 0x400b1030
   \   000000A6   0x681B             LDR      R3,[R3, #+0]
   \   000000A8   0xF413 0x0FE0      TST      R3,#0x700000
   \   000000AC   0xD009             BEQ.N    ??LPLD_SDHC_Write_8
    921              {
    922                SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
   \   000000AE   0x....             LDR.N    R0,??DataTable10  ;; 0x400b1030
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   000000B6   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000000BA   0x....             LDR.N    R1,??DataTable10  ;; 0x400b1030
   \   000000BC   0x6008             STR      R0,[R1, #+0]
    923                return RES_ERROR;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xE01F             B.N      ??LPLD_SDHC_Write_4
    924              }
    925              
    926              buffer = 0xFFFFFFFF;
   \                     ??LPLD_SDHC_Write_8:
   \   000000C2   0xF05F 0x33FF      MOVS     R3,#-1
   \   000000C6   0xE003             B.N      ??LPLD_SDHC_Write_9
    927              while (remains)
    928              {
    929                buffer <<= 8;
   \                     ??LPLD_SDHC_Write_10:
   \   000000C8   0x021B             LSLS     R3,R3,#+8
    930                buffer |= udata_ptr[remains];
   \   000000CA   0x5C14             LDRB     R4,[R2, R0]
   \   000000CC   0x4323             ORRS     R3,R4,R3
    931                remains--;
   \   000000CE   0x1E52             SUBS     R2,R2,#+1
    932              }
   \                     ??LPLD_SDHC_Write_9:
   \   000000D0   0x2A00             CMP      R2,#+0
   \   000000D2   0xD1F9             BNE.N    ??LPLD_SDHC_Write_10
    933              
    934              //等待，直到水印空间可用 
    935              while (0 == (SDHC_BASE_PTR->PRSSTAT & SDHC_PRSSTAT_BWEN_MASK))
   \                     ??LPLD_SDHC_Write_11:
   \   000000D4   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400b1024
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0x0540             LSLS     R0,R0,#+21
   \   000000DA   0xD5FB             BPL.N    ??LPLD_SDHC_Write_11
    936              { };
    937              
    938              SDHC_BASE_PTR->DATPORT = buffer;        
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable11_13  ;; 0x400b1020
   \   000000E0   0x6003             STR      R3,[R0, #+0]
    939            }
    940            
    941            if (SDHC_BASE_PTR->IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \                     ??LPLD_SDHC_Write_7:
   \   000000E2   0x....             LDR.N    R0,??DataTable10  ;; 0x400b1030
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0xF410 0x0FE0      TST      R0,#0x700000
   \   000000EA   0xD009             BEQ.N    ??LPLD_SDHC_Write_12
    942            {
    943              SDHC_BASE_PTR->IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
   \   000000EC   0x....             LDR.N    R0,??DataTable10  ;; 0x400b1030
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   000000F4   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000000F8   0x....             LDR.N    R1,??DataTable10  ;; 0x400b1030
   \   000000FA   0x6008             STR      R0,[R1, #+0]
    944              return RES_ERROR;
   \   000000FC   0x2001             MOVS     R0,#+1
   \   000000FE   0xE000             B.N      ??LPLD_SDHC_Write_4
    945            }
    946            
    947            return (n - remains);
   \                     ??LPLD_SDHC_Write_12:
   \   00000100   0x1A88             SUBS     R0,R1,R2
   \                     ??LPLD_SDHC_Write_4:
   \   00000102   0xBC10             POP      {R4}
   \   00000104   0x4770             BX       LR               ;; return
    948          }
    949          
    950          /*
    951           * LPLD_SDHC_InitCard
    952           * 初始化SDHC模块及SD卡，设置正常工作波特率为40MHz
    953           * 
    954           * 参数:
    955           *    无
    956           *
    957           * 输出:
    958           *    STA_OK--状态正常
    959           *    STA_NOINIT--驱动未初始化
    960           *    STA_NODISK--为插入卡
    961           *    STA_PROTECT--卡写保护
    962           */

   \                                 In section .text, align 2, keep-with-next
    963          DSTATUS LPLD_SDHC_InitCard(void)
    964          {
   \                     LPLD_SDHC_InitCard:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
    965            uint32 baudrate, param, c_size, c_size_mult, read_bl_len, time_out = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    966            ESDHC_COMMAND_STRUCT command;
    967            DSTATUS result;
    968            
    969            //分配SD卡信息结构体的数据空间并初始化
    970            sdcard_ptr = (SDCARD_STRUCT_PTR)malloc(sizeof(SDCARD_STRUCT));
   \   00000006   0x2018             MOVS     R0,#+24
   \   00000008   0x.... 0x....      BL       malloc
   \   0000000C   0x....             LDR.N    R1,??DataTable10_1
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    971            sdcard_ptr->CARD = ESDHC_CARD_NONE;
   \   00000010   0x....             LDR.N    R0,??DataTable10_1
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6101             STR      R1,[R0, #+16]
    972            sdcard_ptr->TIMEOUT = 0;
   \   00000018   0x....             LDR.N    R0,??DataTable10_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    973            sdcard_ptr->NUM_BLOCKS = 0;
   \   00000020   0x....             LDR.N    R0,??DataTable10_1
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6041             STR      R1,[R0, #+4]
    974            sdcard_ptr->ADDRESS = 0;
   \   00000028   0x....             LDR.N    R0,??DataTable10_1
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x60C1             STR      R1,[R0, #+12]
    975            sdcard_ptr->SDHC = FALSE;
   \   00000030   0x....             LDR.N    R0,??DataTable10_1
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x7201             STRB     R1,[R0, #+8]
    976            sdcard_ptr->VERSION2 = FALSE;
   \   00000038   0x....             LDR.N    R0,??DataTable10_1
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x7241             STRB     R1,[R0, #+9]
    977            sdcard_ptr->STATUS = STA_OK;
   \   00000040   0x....             LDR.N    R0,??DataTable10_1
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x6141             STR      R1,[R0, #+20]
   \   00000048   0xE7FF             B.N      ??LPLD_SDHC_InitCard_0
    978             
    979            while(time_out < 1000)
    980            {
    981              
    982              //初始化SDHC模块并检测卡
    983              if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_INIT, NULL)))
    984              {
    985                continue;
   \                     ??LPLD_SDHC_InitCard_1:
   \                     ??LPLD_SDHC_InitCard_0:
   \   0000004A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000004E   0x4284             CMP      R4,R0
   \   00000050   0xD223             BCS.N    ??LPLD_SDHC_InitCard_2
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD1F5             BNE.N    ??LPLD_SDHC_InitCard_1
    986              }
    987              
    988              //SDHC检查
    989              param = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x9000             STR      R0,[SP, #+0]
    990              if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_GET_CARD, &param)))
   \   00000062   0xA900             ADD      R1,SP,#+0
   \   00000064   0x2003             MOVS     R0,#+3
   \   00000066   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD1ED             BNE.N    ??LPLD_SDHC_InitCard_0
    991              {
    992                continue;
    993              }
    994              if ((ESDHC_CARD_SD == param) || (ESDHC_CARD_SDHC == param) || (ESDHC_CARD_SDCOMBO == param) || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??LPLD_SDHC_InitCard_3:
   \   0000006E   0x9800             LDR      R0,[SP, #+0]
   \   00000070   0x2802             CMP      R0,#+2
   \   00000072   0xD008             BEQ.N    ??LPLD_SDHC_InitCard_4
   \   00000074   0x9800             LDR      R0,[SP, #+0]
   \   00000076   0x2803             CMP      R0,#+3
   \   00000078   0xD005             BEQ.N    ??LPLD_SDHC_InitCard_4
   \   0000007A   0x9800             LDR      R0,[SP, #+0]
   \   0000007C   0x2805             CMP      R0,#+5
   \   0000007E   0xD002             BEQ.N    ??LPLD_SDHC_InitCard_4
   \   00000080   0x9800             LDR      R0,[SP, #+0]
   \   00000082   0x2806             CMP      R0,#+6
   \   00000084   0xD111             BNE.N    ??LPLD_SDHC_InitCard_5
    995              {
    996                if ((ESDHC_CARD_SDHC == param) || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??LPLD_SDHC_InitCard_4:
   \   00000086   0x9800             LDR      R0,[SP, #+0]
   \   00000088   0x2803             CMP      R0,#+3
   \   0000008A   0xD002             BEQ.N    ??LPLD_SDHC_InitCard_6
   \   0000008C   0x9800             LDR      R0,[SP, #+0]
   \   0000008E   0x2806             CMP      R0,#+6
   \   00000090   0xD109             BNE.N    ??LPLD_SDHC_InitCard_7
    997                {
    998                  sdcard_ptr->SDHC = TRUE;
   \                     ??LPLD_SDHC_InitCard_6:
   \   00000092   0x....             LDR.N    R0,??DataTable10_1
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x2101             MOVS     R1,#+1
   \   00000098   0x7201             STRB     R1,[R0, #+8]
    999                  break;
   1000                }
   1001              }
   1002              else
   1003              {
   1004                continue;
   1005              }
   1006              time_out++;
   1007            }
   1008            
   1009            if(time_out >= 1000)
   \                     ??LPLD_SDHC_InitCard_2:
   \   0000009A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000009E   0x4284             CMP      R4,R0
   \   000000A0   0xD304             BCC.N    ??LPLD_SDHC_InitCard_8
   1010              return RES_NOTRDY;
   \   000000A2   0x2003             MOVS     R0,#+3
   \   000000A4   0xE0A4             B.N      ??LPLD_SDHC_InitCard_9
   \                     ??LPLD_SDHC_InitCard_7:
   \   000000A6   0x1C64             ADDS     R4,R4,#+1
   \   000000A8   0xE7CF             B.N      ??LPLD_SDHC_InitCard_0
   \                     ??LPLD_SDHC_InitCard_5:
   \   000000AA   0xE7CE             B.N      ??LPLD_SDHC_InitCard_0
   1011            
   1012            //卡识别
   1013            command.COMMAND = ESDHC_CMD2;
   \                     ??LPLD_SDHC_InitCard_8:
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable11_14  ;; 0x2090000
   \   000000B0   0x9001             STR      R0,[SP, #+4]
   1014            command.ARGUMENT = 0;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x9002             STR      R0,[SP, #+8]
   1015            command.BLOCKS = 0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x9003             STR      R0,[SP, #+12]
   1016            if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000000BA   0xA901             ADD      R1,SP,#+4
   \   000000BC   0x2002             MOVS     R0,#+2
   \   000000BE   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xF040 0x8094      BNE.W    ??LPLD_SDHC_InitCard_9
   1017            {
   1018              return result;
   1019            }
   1020            
   1021            //获取卡地址
   1022            command.COMMAND = ESDHC_CMD3;
   \                     ??LPLD_SDHC_InitCard_10:
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable11_15  ;; 0x31a0000
   \   000000CC   0x9001             STR      R0,[SP, #+4]
   1023            command.ARGUMENT = 0;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x9002             STR      R0,[SP, #+8]
   1024            command.BLOCKS = 0;
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x9003             STR      R0,[SP, #+12]
   1025            if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000000D6   0xA901             ADD      R1,SP,#+4
   \   000000D8   0x2002             MOVS     R0,#+2
   \   000000DA   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xF040 0x8086      BNE.W    ??LPLD_SDHC_InitCard_9
   1026            {
   1027              return result;
   1028            }
   1029            sdcard_ptr->ADDRESS = command.RESPONSE[0] & 0xFFFF0000;
   \                     ??LPLD_SDHC_InitCard_11:
   \   000000E4   0x9805             LDR      R0,[SP, #+20]
   \   000000E6   0x0C00             LSRS     R0,R0,#+16
   \   000000E8   0x0400             LSLS     R0,R0,#+16
   \   000000EA   0x....             LDR.N    R1,??DataTable10_1
   \   000000EC   0x6809             LDR      R1,[R1, #+0]
   \   000000EE   0x60C8             STR      R0,[R1, #+12]
   1030            
   1031            //获取卡参数
   1032            command.COMMAND = ESDHC_CMD9;
   \   000000F0   0x....             LDR.N    R0,??DataTable11_16  ;; 0x9090000
   \   000000F2   0x9001             STR      R0,[SP, #+4]
   1033            command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000000F4   0x....             LDR.N    R0,??DataTable10_1
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0x68C0             LDR      R0,[R0, #+12]
   \   000000FA   0x9002             STR      R0,[SP, #+8]
   1034            command.BLOCKS = 0;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x9003             STR      R0,[SP, #+12]
   1035            if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   00000100   0xA901             ADD      R1,SP,#+4
   \   00000102   0x2002             MOVS     R0,#+2
   \   00000104   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD171             BNE.N    ??LPLD_SDHC_InitCard_9
   1036            {
   1037              return result;
   1038            }
   1039            if (0 == (command.RESPONSE[3] & 0x00C00000))
   \                     ??LPLD_SDHC_InitCard_12:
   \   0000010C   0x9808             LDR      R0,[SP, #+32]
   \   0000010E   0xF410 0x0F40      TST      R0,#0xC00000
   \   00000112   0xD11B             BNE.N    ??LPLD_SDHC_InitCard_13
   1040            {
   1041              read_bl_len = (command.RESPONSE[2] >> 8) & 0x0F;
   \   00000114   0x9807             LDR      R0,[SP, #+28]
   \   00000116   0xF3C0 0x2203      UBFX     R2,R0,#+8,#+4
   1042              c_size = command.RESPONSE[2] & 0x03;
   \   0000011A   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \   0000011E   0xF010 0x0003      ANDS     R0,R0,#0x3
   1043              c_size = (c_size << 10) | (command.RESPONSE[1] >> 22);
   \   00000122   0x9906             LDR      R1,[SP, #+24]
   \   00000124   0x0D89             LSRS     R1,R1,#+22
   \   00000126   0xEA51 0x2080      ORRS     R0,R1,R0, LSL #+10
   1044              c_size_mult = (command.RESPONSE[1] >> 7) & 0x07;
   \   0000012A   0x9906             LDR      R1,[SP, #+24]
   \   0000012C   0xF3C1 0x11C2      UBFX     R1,R1,#+7,#+3
   1045              sdcard_ptr->NUM_BLOCKS = (c_size + 1) * (1 << (c_size_mult + 2)) * (1 << (read_bl_len - 9));
   \   00000130   0x1C40             ADDS     R0,R0,#+1
   \   00000132   0x2301             MOVS     R3,#+1
   \   00000134   0x1C89             ADDS     R1,R1,#+2
   \   00000136   0xFA13 0xF101      LSLS     R1,R3,R1
   \   0000013A   0x4348             MULS     R0,R1,R0
   \   0000013C   0x2101             MOVS     R1,#+1
   \   0000013E   0x3A09             SUBS     R2,R2,#+9
   \   00000140   0x4091             LSLS     R1,R1,R2
   \   00000142   0x4348             MULS     R0,R1,R0
   \   00000144   0x....             LDR.N    R1,??DataTable10_1
   \   00000146   0x6809             LDR      R1,[R1, #+0]
   \   00000148   0x6048             STR      R0,[R1, #+4]
   \   0000014A   0xE00B             B.N      ??LPLD_SDHC_InitCard_14
   1046            }
   1047            else
   1048            {
   1049              sdcard_ptr->VERSION2 = TRUE;
   \                     ??LPLD_SDHC_InitCard_13:
   \   0000014C   0x....             LDR.N    R0,??DataTable10_1
   \   0000014E   0x6800             LDR      R0,[R0, #+0]
   \   00000150   0x2101             MOVS     R1,#+1
   \   00000152   0x7241             STRB     R1,[R0, #+9]
   1050              c_size = (command.RESPONSE[1] >> 8) & 0x003FFFFF;
   \   00000154   0x9806             LDR      R0,[SP, #+24]
   \   00000156   0xF3C0 0x2015      UBFX     R0,R0,#+8,#+22
   1051              sdcard_ptr->NUM_BLOCKS = (c_size + 1) << 10;
   \   0000015A   0x1C40             ADDS     R0,R0,#+1
   \   0000015C   0x0280             LSLS     R0,R0,#+10
   \   0000015E   0x....             LDR.N    R1,??DataTable10_1
   \   00000160   0x6809             LDR      R1,[R1, #+0]
   \   00000162   0x6048             STR      R0,[R1, #+4]
   1052            }
   1053            
   1054            //设置正常工作波特率为40MHz
   1055            param = 40000000;      
   \                     ??LPLD_SDHC_InitCard_14:
   \   00000164   0x....             LDR.N    R0,??DataTable11_17  ;; 0x2625a00
   \   00000166   0x9000             STR      R0,[SP, #+0]
   1056            if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SET_BAUDRATE, &param)))
   \   00000168   0xA900             ADD      R1,SP,#+0
   \   0000016A   0x2005             MOVS     R0,#+5
   \   0000016C   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000170   0x2800             CMP      R0,#+0
   \   00000172   0xD13D             BNE.N    ??LPLD_SDHC_InitCard_9
   1057            {
   1058              return result;
   1059            }
   1060            
   1061            //选择卡
   1062            command.COMMAND = ESDHC_CMD7;
   \                     ??LPLD_SDHC_InitCard_15:
   \   00000174   0x....             LDR.N    R0,??DataTable11_18  ;; 0x71b0000
   \   00000176   0x9001             STR      R0,[SP, #+4]
   1063            command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   00000178   0x....             LDR.N    R0,??DataTable10_1
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0x68C0             LDR      R0,[R0, #+12]
   \   0000017E   0x9002             STR      R0,[SP, #+8]
   1064            command.BLOCKS = 0;
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0x9003             STR      R0,[SP, #+12]
   1065            if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   00000184   0xA901             ADD      R1,SP,#+4
   \   00000186   0x2002             MOVS     R0,#+2
   \   00000188   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD12F             BNE.N    ??LPLD_SDHC_InitCard_9
   1066            {
   1067              return result;
   1068            }
   1069            
   1070            //设置块大小为512字节
   1071            command.COMMAND = ESDHC_CMD16;
   \                     ??LPLD_SDHC_InitCard_16:
   \   00000190   0x....             LDR.N    R0,??DataTable11_19  ;; 0x101a0000
   \   00000192   0x9001             STR      R0,[SP, #+4]
   1072            command.ARGUMENT = IO_SDCARD_BLOCK_SIZE;
   \   00000194   0xF44F 0x7000      MOV      R0,#+512
   \   00000198   0x9002             STR      R0,[SP, #+8]
   1073            command.BLOCKS = 0;
   \   0000019A   0x2000             MOVS     R0,#+0
   \   0000019C   0x9003             STR      R0,[SP, #+12]
   1074            if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   0000019E   0xA901             ADD      R1,SP,#+4
   \   000001A0   0x2002             MOVS     R0,#+2
   \   000001A2   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000001A6   0x2800             CMP      R0,#+0
   \   000001A8   0xD122             BNE.N    ??LPLD_SDHC_InitCard_9
   1075            {
   1076              return result;
   1077            }
   1078            
   1079            if (ESDHC_BUS_WIDTH_4BIT == ESDHC_BUS_WIDTH_4BIT)
   1080            {
   1081              //特殊应用命令
   1082              command.COMMAND = ESDHC_CMD55;
   \                     ??LPLD_SDHC_InitCard_17:
   \   000001AA   0x....             LDR.N    R0,??DataTable11_8  ;; 0x371a0000
   \   000001AC   0x9001             STR      R0,[SP, #+4]
   1083              command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000001AE   0x....             LDR.N    R0,??DataTable10_1
   \   000001B0   0x6800             LDR      R0,[R0, #+0]
   \   000001B2   0x68C0             LDR      R0,[R0, #+12]
   \   000001B4   0x9002             STR      R0,[SP, #+8]
   1084              command.BLOCKS = 0;
   \   000001B6   0x2000             MOVS     R0,#+0
   \   000001B8   0x9003             STR      R0,[SP, #+12]
   1085              if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000001BA   0xA901             ADD      R1,SP,#+4
   \   000001BC   0x2002             MOVS     R0,#+2
   \   000001BE   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000001C2   0x2800             CMP      R0,#+0
   \   000001C4   0xD114             BNE.N    ??LPLD_SDHC_InitCard_9
   1086              {
   1087                return result;
   1088              }
   1089              
   1090              //设置总线宽度为4bit
   1091              command.COMMAND = ESDHC_ACMD6;
   \                     ??LPLD_SDHC_InitCard_18:
   \   000001C6   0x....             LDR.N    R0,??DataTable11_20  ;; 0x61a0000
   \   000001C8   0x9001             STR      R0,[SP, #+4]
   1092              command.ARGUMENT = 2;
   \   000001CA   0x2002             MOVS     R0,#+2
   \   000001CC   0x9002             STR      R0,[SP, #+8]
   1093              command.BLOCKS = 0;
   \   000001CE   0x2000             MOVS     R0,#+0
   \   000001D0   0x9003             STR      R0,[SP, #+12]
   1094              if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000001D2   0xA901             ADD      R1,SP,#+4
   \   000001D4   0x2002             MOVS     R0,#+2
   \   000001D6   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000001DA   0x2800             CMP      R0,#+0
   \   000001DC   0xD108             BNE.N    ??LPLD_SDHC_InitCard_9
   1095              {
   1096                return result;
   1097              }
   1098              
   1099              param = ESDHC_BUS_WIDTH_4BIT;
   \                     ??LPLD_SDHC_InitCard_19:
   \   000001DE   0x2001             MOVS     R0,#+1
   \   000001E0   0x9000             STR      R0,[SP, #+0]
   1100              if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SET_BUS_WIDTH, &param)))
   \   000001E2   0xA900             ADD      R1,SP,#+0
   \   000001E4   0x2007             MOVS     R0,#+7
   \   000001E6   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000001EA   0x2800             CMP      R0,#+0
   \   000001EC   0xD100             BNE.N    ??LPLD_SDHC_InitCard_9
   1101              {
   1102                return result;
   1103              }
   1104            }
   1105            
   1106            return RES_OK;
   \                     ??LPLD_SDHC_InitCard_20:
   \   000001EE   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_InitCard_9:
   \   000001F0   0xB00A             ADD      SP,SP,#+40
   \   000001F2   0xBD10             POP      {R4,PC}          ;; return
   1107          }
   1108          
   1109          
   1110          /*
   1111           * LPLD_SDHC_ReadBlocks
   1112           * 读指定扇区指定长度的块
   1113           * 
   1114           * 参数:
   1115           *    buff--存储读出数据的地址指针
   1116           *    sector--开始的扇区号
   1117           *    count--读出的扇区数（块数）
   1118           *
   1119           * 输出:
   1120           *    DRESULT--磁盘功能返回值
   1121           */

   \                                 In section .text, align 2, keep-with-next
   1122          DRESULT LPLD_SDHC_ReadBlocks(uint8 *buff, uint32 sector, uint32 count)
   1123          {
   \                     LPLD_SDHC_ReadBlocks:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
   1124            ESDHC_COMMAND_STRUCT command;
   1125            int cnt;
   1126            int32 result;
   1127            
   1128            //SD卡数据地址调节
   1129            if (! sdcard_ptr->SDHC)
   \   00000008   0x....             LDR.N    R0,??DataTable10_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x7A00             LDRB     R0,[R0, #+8]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD100             BNE.N    ??LPLD_SDHC_ReadBlocks_0
   1130            {
   1131              sector <<= IO_SDCARD_BLOCK_SIZE_POWER;
   \   00000012   0x0249             LSLS     R1,R1,#+9
   1132            }
   1133            
   1134            //设置读块命令
   1135            if (count > 1)
   \                     ??LPLD_SDHC_ReadBlocks_0:
   \   00000014   0x2D02             CMP      R5,#+2
   \   00000016   0xD302             BCC.N    ??LPLD_SDHC_ReadBlocks_1
   1136            {
   1137              command.COMMAND = ESDHC_CMD18;
   \   00000018   0x....             LDR.N    R0,??DataTable11_21  ;; 0x121a0034
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0xE001             B.N      ??LPLD_SDHC_ReadBlocks_2
   1138            }   
   1139            else
   1140            {
   1141              command.COMMAND = ESDHC_CMD17;
   \                     ??LPLD_SDHC_ReadBlocks_1:
   \   0000001E   0x....             LDR.N    R0,??DataTable11_22  ;; 0x111a0010
   \   00000020   0x9000             STR      R0,[SP, #+0]
   1142            }
   1143            
   1144            command.ARGUMENT = sector;
   \                     ??LPLD_SDHC_ReadBlocks_2:
   \   00000022   0x9101             STR      R1,[SP, #+4]
   1145            command.BLOCKS = count;
   \   00000024   0x9502             STR      R5,[SP, #+8]
   1146            command.BLOCKSIZE = IO_SDCARD_BLOCK_SIZE;
   \   00000026   0xF44F 0x7000      MOV      R0,#+512
   \   0000002A   0x9003             STR      R0,[SP, #+12]
   1147            if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   0000002C   0xA900             ADD      R1,SP,#+0
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD001             BEQ.N    ??LPLD_SDHC_ReadBlocks_3
   1148            {
   1149              return (DRESULT)result;
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xE01A             B.N      ??LPLD_SDHC_ReadBlocks_4
   1150            }
   1151            
   1152            //读取数据
   1153            for (cnt = 0; cnt < count; cnt++)
   \                     ??LPLD_SDHC_ReadBlocks_3:
   \   0000003C   0x2600             MOVS     R6,#+0
   \   0000003E   0xE002             B.N      ??LPLD_SDHC_ReadBlocks_5
   1154            {
   1155              if (IO_SDCARD_BLOCK_SIZE != (result=LPLD_SDHC_Read(buff,IO_SDCARD_BLOCK_SIZE)))
   1156              {
   1157                return (DRESULT)result;
   1158              }
   1159              buff += IO_SDCARD_BLOCK_SIZE;
   \                     ??LPLD_SDHC_ReadBlocks_6:
   \   00000040   0xF204 0x2400      ADDW     R4,R4,#+512
   \   00000044   0x1C76             ADDS     R6,R6,#+1
   \                     ??LPLD_SDHC_ReadBlocks_5:
   \   00000046   0x42AE             CMP      R6,R5
   \   00000048   0xD20A             BCS.N    ??LPLD_SDHC_ReadBlocks_7
   \   0000004A   0xF44F 0x7100      MOV      R1,#+512
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       LPLD_SDHC_Read
   \   00000054   0xF44F 0x7100      MOV      R1,#+512
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD0F1             BEQ.N    ??LPLD_SDHC_ReadBlocks_6
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0xE008             B.N      ??LPLD_SDHC_ReadBlocks_4
   1160            }
   1161            
   1162            //等待传输结束
   1163            if (RES_OK !=(result=LPLD_SDHC_IOC (IO_IOCTL_FLUSH_OUTPUT, NULL)))
   \                     ??LPLD_SDHC_ReadBlocks_7:
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x2093             MOVS     R0,#+147
   \   00000064   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD001             BEQ.N    ??LPLD_SDHC_ReadBlocks_8
   1164            {
   1165              return (DRESULT)result;
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0xE000             B.N      ??LPLD_SDHC_ReadBlocks_4
   1166            }
   1167            
   1168            return (DRESULT)result;
   \                     ??LPLD_SDHC_ReadBlocks_8:
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??LPLD_SDHC_ReadBlocks_4:
   \   00000072   0xB008             ADD      SP,SP,#+32
   \   00000074   0xBD70             POP      {R4-R6,PC}       ;; return
   1169          }
   1170          
   1171          
   1172          /*
   1173           * LPLD_SDHC_WriteBlocks
   1174           * 在指定扇区写入指定长度块数数据
   1175           * 
   1176           * 参数:
   1177           *    buff--存储待写入数据的地址指针
   1178           *    sector--开始的扇区号
   1179           *    count--写入的扇区数（块数）
   1180           *
   1181           * 输出:
   1182           *    DRESULT--磁盘功能返回值
   1183           */

   \                                 In section .text, align 2, keep-with-next
   1184          DRESULT LPLD_SDHC_WriteBlocks(uint8* buff, uint32 sector, uint32 count)
   1185          {
   \                     LPLD_SDHC_WriteBlocks:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x0015             MOVS     R5,R2
   1186              ESDHC_COMMAND_STRUCT command;
   1187              uint8               tmp[4];
   1188              int32             cnt;
   1189                int32 result;
   1190              
   1191           
   1192              //SD卡数据地址调节
   1193              if (! sdcard_ptr->SDHC)
   \   00000008   0x....             LDR.N    R0,??DataTable11_23
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x7A00             LDRB     R0,[R0, #+8]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD100             BNE.N    ??LPLD_SDHC_WriteBlocks_0
   1194              {
   1195                  sector <<= IO_SDCARD_BLOCK_SIZE_POWER;
   \   00000012   0x0249             LSLS     R1,R1,#+9
   1196              }
   1197          
   1198              //设置写块命令
   1199              if (count > 1)
   \                     ??LPLD_SDHC_WriteBlocks_0:
   \   00000014   0x2D02             CMP      R5,#+2
   \   00000016   0xD302             BCC.N    ??LPLD_SDHC_WriteBlocks_1
   1200              {
   1201                  command.COMMAND = ESDHC_CMD25;
   \   00000018   0x....             LDR.N    R0,??DataTable11_24  ;; 0x191a0024
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0xE001             B.N      ??LPLD_SDHC_WriteBlocks_2
   1202              }
   1203              else
   1204              {
   1205                  command.COMMAND = ESDHC_CMD24;
   \                     ??LPLD_SDHC_WriteBlocks_1:
   \   0000001E   0x....             LDR.N    R0,??DataTable11_25  ;; 0x181a0000
   \   00000020   0x9001             STR      R0,[SP, #+4]
   1206              }
   1207          
   1208              command.ARGUMENT = sector;
   \                     ??LPLD_SDHC_WriteBlocks_2:
   \   00000022   0x9102             STR      R1,[SP, #+8]
   1209              command.BLOCKS = count;
   \   00000024   0x9503             STR      R5,[SP, #+12]
   1210              command.BLOCKSIZE = IO_SDCARD_BLOCK_SIZE;
   \   00000026   0xF44F 0x7000      MOV      R0,#+512
   \   0000002A   0x9004             STR      R0,[SP, #+16]
   1211              if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   0000002C   0xA901             ADD      R1,SP,#+4
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_3
   1212              {
   1213                  return (DRESULT)result;
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xE07D             B.N      ??LPLD_SDHC_WriteBlocks_4
   1214              }
   1215              
   1216              //写数据
   1217              for (cnt = 0; cnt < count; cnt++)
   \                     ??LPLD_SDHC_WriteBlocks_3:
   \   0000003C   0x2400             MOVS     R4,#+0
   \   0000003E   0xE002             B.N      ??LPLD_SDHC_WriteBlocks_5
   1218              {
   1219                  if (IO_SDCARD_BLOCK_SIZE != (result=LPLD_SDHC_Write (buff, IO_SDCARD_BLOCK_SIZE)))
   1220                  {
   1221                      return (DRESULT)result;
   1222                  }
   1223                  buff += IO_SDCARD_BLOCK_SIZE;
   \                     ??LPLD_SDHC_WriteBlocks_6:
   \   00000040   0xF206 0x2600      ADDW     R6,R6,#+512
   \   00000044   0x1C64             ADDS     R4,R4,#+1
   \                     ??LPLD_SDHC_WriteBlocks_5:
   \   00000046   0x42AC             CMP      R4,R5
   \   00000048   0xD20A             BCS.N    ??LPLD_SDHC_WriteBlocks_7
   \   0000004A   0xF44F 0x7100      MOV      R1,#+512
   \   0000004E   0x0030             MOVS     R0,R6
   \   00000050   0x.... 0x....      BL       LPLD_SDHC_Write
   \   00000054   0xF44F 0x7100      MOV      R1,#+512
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD0F1             BEQ.N    ??LPLD_SDHC_WriteBlocks_6
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0xE06B             B.N      ??LPLD_SDHC_WriteBlocks_4
   1224              }
   1225          
   1226              //等待传输结束
   1227              if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_FLUSH_OUTPUT, NULL)))
   \                     ??LPLD_SDHC_WriteBlocks_7:
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x2093             MOVS     R0,#+147
   \   00000064   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_8
   1228              {
   1229                  return (DRESULT)result;
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0xE063             B.N      ??LPLD_SDHC_WriteBlocks_4
   1230              }
   1231          
   1232              //等待卡准备好/传输状态
   1233              do
   1234              {
   1235                  command.COMMAND = ESDHC_CMD13;
   \                     ??LPLD_SDHC_WriteBlocks_8:
   \   00000070   0x....             LDR.N    R0,??DataTable11_26  ;; 0xd1a0000
   \   00000072   0x9001             STR      R0,[SP, #+4]
   1236                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   00000074   0x....             LDR.N    R0,??DataTable11_23
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x68C0             LDR      R0,[R0, #+12]
   \   0000007A   0x9002             STR      R0,[SP, #+8]
   1237                  command.BLOCKS = 0;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x9003             STR      R0,[SP, #+12]
   1238                  if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   00000080   0xA901             ADD      R1,SP,#+4
   \   00000082   0x2002             MOVS     R0,#+2
   \   00000084   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_9
   1239                  {
   1240                      return (DRESULT)result;
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0xE053             B.N      ??LPLD_SDHC_WriteBlocks_4
   1241                  }
   1242          
   1243                  //卡状态错误检查
   1244                  if (command.RESPONSE[0] & 0xFFD98008)
   \                     ??LPLD_SDHC_WriteBlocks_9:
   \   00000090   0x9805             LDR      R0,[SP, #+20]
   \   00000092   0x....             LDR.N    R1,??DataTable11_27  ;; 0xffd98008
   \   00000094   0x4208             TST      R0,R1
   \   00000096   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_10
   1245                  {
   1246                      count = 0; /* necessary to get real number of written blocks */
   \   00000098   0x2500             MOVS     R5,#+0
   1247                      break;
   \   0000009A   0xE005             B.N      ??LPLD_SDHC_WriteBlocks_11
   1248                  }
   1249          
   1250              } while (0x000000900 != (command.RESPONSE[0] & 0x00001F00));
   \                     ??LPLD_SDHC_WriteBlocks_10:
   \   0000009C   0x9805             LDR      R0,[SP, #+20]
   \   0000009E   0xF410 0x50F8      ANDS     R0,R0,#0x1F00
   \   000000A2   0xF5B0 0x6F10      CMP      R0,#+2304
   \   000000A6   0xD1E3             BNE.N    ??LPLD_SDHC_WriteBlocks_8
   1251          
   1252              if (cnt != count)
   \                     ??LPLD_SDHC_WriteBlocks_11:
   \   000000A8   0x42AC             CMP      R4,R5
   \   000000AA   0xD044             BEQ.N    ??LPLD_SDHC_WriteBlocks_12
   1253              {
   1254                  //特殊应用命令
   1255                  command.COMMAND = ESDHC_CMD55;
   \   000000AC   0x....             LDR.N    R0,??DataTable11_8  ;; 0x371a0000
   \   000000AE   0x9001             STR      R0,[SP, #+4]
   1256                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000000B0   0x....             LDR.N    R0,??DataTable11_23
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x68C0             LDR      R0,[R0, #+12]
   \   000000B6   0x9002             STR      R0,[SP, #+8]
   1257                  command.BLOCKS = 0;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x9003             STR      R0,[SP, #+12]
   1258                  if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000000BC   0xA901             ADD      R1,SP,#+4
   \   000000BE   0x2002             MOVS     R0,#+2
   \   000000C0   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_13
   1259                  {
   1260                      return (DRESULT)result;
   \   000000C8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CA   0xE035             B.N      ??LPLD_SDHC_WriteBlocks_4
   1261                  }
   1262                          
   1263                  //使用ACMD22命令获得写入的块数量
   1264                  command.COMMAND = ESDHC_ACMD22;
   \                     ??LPLD_SDHC_WriteBlocks_13:
   \   000000CC   0x....             LDR.N    R0,??DataTable11_28  ;; 0x161a0010
   \   000000CE   0x9001             STR      R0,[SP, #+4]
   1265                  command.ARGUMENT = 0;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x9002             STR      R0,[SP, #+8]
   1266                  command.BLOCKS = 1;
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x9003             STR      R0,[SP, #+12]
   1267                  command.BLOCKSIZE = 4;
   \   000000D8   0x2004             MOVS     R0,#+4
   \   000000DA   0x9004             STR      R0,[SP, #+16]
   1268                  if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_ESDHC_SEND_COMMAND, &command)))
   \   000000DC   0xA901             ADD      R1,SP,#+4
   \   000000DE   0x2002             MOVS     R0,#+2
   \   000000E0   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_14
   1269                  {
   1270                      return (DRESULT)result;
   \   000000E8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EA   0xE025             B.N      ??LPLD_SDHC_WriteBlocks_4
   1271                  }
   1272                  
   1273                  if (4 != (result=LPLD_SDHC_Read (tmp, 4)))
   \                     ??LPLD_SDHC_WriteBlocks_14:
   \   000000EC   0x2104             MOVS     R1,#+4
   \   000000EE   0xA800             ADD      R0,SP,#+0
   \   000000F0   0x.... 0x....      BL       LPLD_SDHC_Read
   \   000000F4   0x2804             CMP      R0,#+4
   \   000000F6   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_15
   1274                  {
   1275                      return (DRESULT)result;
   \   000000F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FA   0xE01D             B.N      ??LPLD_SDHC_WriteBlocks_4
   1276                      
   1277                  }
   1278          
   1279                  if (RES_OK != (result=LPLD_SDHC_IOC (IO_IOCTL_FLUSH_OUTPUT, NULL)))
   \                     ??LPLD_SDHC_WriteBlocks_15:
   \   000000FC   0x2100             MOVS     R1,#+0
   \   000000FE   0x2093             MOVS     R0,#+147
   \   00000100   0x.... 0x....      BL       LPLD_SDHC_IOC
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD001             BEQ.N    ??LPLD_SDHC_WriteBlocks_16
   1280                  {
   1281                      return (DRESULT)result;
   \   00000108   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010A   0xE015             B.N      ??LPLD_SDHC_WriteBlocks_4
   1282                  }
   1283          
   1284                  count = (tmp[0] << 24) | (tmp[1] << 16) | (tmp[2] << 8) | tmp[3];
   \                     ??LPLD_SDHC_WriteBlocks_16:
   \   0000010C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000110   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000114   0x0409             LSLS     R1,R1,#+16
   \   00000116   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000011A   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   0000011E   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000122   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000126   0xEA51 0x0500      ORRS     R5,R1,R0
   1285                  if ((cnt < 0) || (cnt > count))
   \   0000012A   0x2C00             CMP      R4,#+0
   \   0000012C   0xD401             BMI.N    ??LPLD_SDHC_WriteBlocks_17
   \   0000012E   0x42A5             CMP      R5,R4
   \   00000130   0xD201             BCS.N    ??LPLD_SDHC_WriteBlocks_12
   1286                      return RES_ERROR;
   \                     ??LPLD_SDHC_WriteBlocks_17:
   \   00000132   0x2001             MOVS     R0,#+1
   \   00000134   0xE000             B.N      ??LPLD_SDHC_WriteBlocks_4
   1287              }
   1288              
   1289              return RES_OK;
   \                     ??LPLD_SDHC_WriteBlocks_12:
   \   00000136   0x2000             MOVS     R0,#+0
   \                     ??LPLD_SDHC_WriteBlocks_4:
   \   00000138   0xB00A             ADD      SP,SP,#+40
   \   0000013A   0xBD70             POP      {R4-R6,PC}       ;; return
   1290          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x4004D004         DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x4004D008         DC32     0x4004d008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x4004D00C         DC32     0x4004d00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x4004D010         DC32     0x4004d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x4004D014         DC32     0x4004d014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x400B102C         DC32     0x400b102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0xFFF0000F         DC32     0xfff0000f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x400B1024         DC32     0x400b1024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x01008000         DC32     0x1008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x400B10C0         DC32     0x400b10c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x400B1004         DC32     0x400b1004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x400B1044         DC32     0x400b1044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x00010002         DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x400B1030         DC32     0x400b1030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     sdcard_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x400B1028         DC32     0x400b1028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x400B1034         DC32     0x400b1034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x007F00B3         DC32     0x7f00b3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x400B1008         DC32     0x400b1008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x400B1000         DC32     0x400b1000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x400B100C         DC32     0x400b100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x000E0001         DC32     0xe0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x400B1010         DC32     0x400b1010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x400B1014         DC32     0x400b1014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x400B1018         DC32     0x400b1018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x400B101C         DC32     0x400b101c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x00061A80         DC32     0x61a80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     core_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x081A0000         DC32     0x81a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x05020000         DC32     0x5020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x371A0000         DC32     0x371a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x40300000         DC32     0x40300000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x27020000         DC32     0x27020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x29020000         DC32     0x29020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x017D7840         DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x400B1020         DC32     0x400b1020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x02090000         DC32     0x2090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \   00000000   0x031A0000         DC32     0x31a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \   00000000   0x09090000         DC32     0x9090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \   00000000   0x02625A00         DC32     0x2625a00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_18:
   \   00000000   0x071B0000         DC32     0x71b0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_19:
   \   00000000   0x101A0000         DC32     0x101a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_20:
   \   00000000   0x061A0000         DC32     0x61a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_21:
   \   00000000   0x121A0034         DC32     0x121a0034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_22:
   \   00000000   0x111A0010         DC32     0x111a0010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_23:
   \   00000000   0x........         DC32     sdcard_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_24:
   \   00000000   0x191A0024         DC32     0x191a0024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_25:
   \   00000000   0x181A0000         DC32     0x181a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_26:
   \   00000000   0x0D1A0000         DC32     0xd1a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_27:
   \   00000000   0xFFD98008         DC32     0xffd98008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_28:
   \   00000000   0x161A0010         DC32     0x161a0010

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       72  LPLD_SDHC_IOC
             72 -> LPLD_SDHC_Init
             72 -> LPLD_SDHC_InitGPIO
             72 -> LPLD_SDHC_IsRunning
             72 -> LPLD_SDHC_SendCommand
             72 -> LPLD_SDHC_SetBaudrate
             72 -> LPLD_SDHC_WaitStatus
       16  LPLD_SDHC_Init
             16 -> LPLD_SDHC_InitGPIO
             16 -> LPLD_SDHC_SetBaudrate
       48  LPLD_SDHC_InitCard
             48 -> LPLD_SDHC_IOC
             48 -> malloc
        0  LPLD_SDHC_InitGPIO
        0  LPLD_SDHC_IsRunning
        4  LPLD_SDHC_Read
       48  LPLD_SDHC_ReadBlocks
             48 -> LPLD_SDHC_IOC
             48 -> LPLD_SDHC_Read
       16  LPLD_SDHC_SendCommand
             16 -> LPLD_SDHC_WaitStatus
       16  LPLD_SDHC_SetBaudrate
        0  LPLD_SDHC_WaitStatus
        4  LPLD_SDHC_Write
       56  LPLD_SDHC_WriteBlocks
             56 -> LPLD_SDHC_IOC
             56 -> LPLD_SDHC_Read
             56 -> LPLD_SDHC_Write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_22
       4  ??DataTable11_23
       4  ??DataTable11_24
       4  ??DataTable11_25
       4  ??DataTable11_26
       4  ??DataTable11_27
       4  ??DataTable11_28
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
    1474  LPLD_SDHC_IOC
     206  LPLD_SDHC_Init
     500  LPLD_SDHC_InitCard
      88  LPLD_SDHC_InitGPIO
      24  LPLD_SDHC_IsRunning
     286  LPLD_SDHC_Read
     118  LPLD_SDHC_ReadBlocks
     316  LPLD_SDHC_SendCommand
     158  LPLD_SDHC_SetBaudrate
      16  LPLD_SDHC_WaitStatus
     262  LPLD_SDHC_Write
     316  LPLD_SDHC_WriteBlocks
       4  sdcard_ptr

 
     4 bytes in section .bss
 3 976 bytes in section .text
 
 3 976 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: 1
