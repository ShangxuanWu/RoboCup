###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     25/Sep/2013  21:07:05 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\中国机器人大赛\robot_project\lib\LPLD\USB\USB.c       #
#    Command line =  D:\中国机器人大赛\robot_project\lib\LPLD\USB\USB.c -D    #
#                    IAR -D LPLD_K60 -lCN D:\中国机器人大赛\robot_project\pro #
#                    ject\LPLD_Template\iar\RAM\List\ -lB                     #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\RAM\List\ -o D:\中国机器人大赛\robot_project\project\L #
#                    PLD_Template\iar\RAM\Obj\ --no_cse --no_unroll           #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I D:\中国机器人大赛\robot_project\project\LPLD_T #
#                    emplate\iar\..\app\ -I D:\中国机器人大赛\robot_project\p #
#                    roject\LPLD_Template\iar\..\..\..\lib\common\ -I         #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\cpu\ -I D:\中国机器人大赛\robot_project\p #
#                    roject\LPLD_Template\iar\..\..\..\lib\cpu\headers\ -I    #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\adc16\ -I                         #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\enet\ -I                          #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\lptmr\ -I                         #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\mcg\ -I                           #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\pmc\ -I                           #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\rtc\ -I                           #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\uart\ -I                          #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\wdog\ -I                          #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\platforms\ -I                             #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\LPLD\ -I D:\中国机器人大赛\robot_project\ #
#                    project\LPLD_Template\iar\..\..\..\lib\LPLD\FatFs\ -I    #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\LPLD\USB\ -I                              #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\iar_config_files\ -Ol                     #
#    List file    =  D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\RAM\List\USB.lst                                       #
#    Object file  =  D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\RAM\Obj\USB.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

D:\中国机器人大赛\robot_project\lib\LPLD\USB\USB.c
      1          /*
      2           * 文件名: USB.c
      3           * 用途: 定义USB底层协议函数和变量
      4           * 最后修改日期: 20121204
      5           *
      6           *
      7           * 说明:本页代码基于Freescale官方示例代码修改，源代码文件为 USB.c
      8           *    在本文件中将USB_Init函数移除
      9           *    将USB_EP_OUT_SizeCheck函数中的获得数据长度部分进行了修改
     10           *    将USB_Reset_Handler函数中的gu8USB_Toogle_flags变量修改为0xFE，原程序此处有BUG致使端点少接收一个字节
     11           */
     12          #include "USB.h"
     13          #include "USB_Desc.h"

   \                                 In section .rodata, align 4
   \   __absolute unsigned char const Device_Descriptor[18]
   \                     Device_Descriptor:
   \   00000000   0x12 0x01          DC8 18, 1, 0, 2, 2, 0, 0, 64, 162, 21, 15, 165, 0, 2, 1, 2, 3, 1, 0, 0
   \              0x00 0x02    
   \              0x02 0x00    
   \              0x00 0x40    
   \              0xA2 0x15    
   \              0x0F 0xA5    
   \              0x00 0x02    
   \              0x01 0x02    
   \              0x03 0x01    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   __absolute unsigned char const String_Descriptor0[4]
   \                     String_Descriptor0:
   \   00000000   0x04 0x03          DC8 4, 3, 9, 4
   \              0x09 0x04    

   \                                 In section .rodata, align 4
   \   __absolute unsigned char const String_Descriptor1[20]
   \                     String_Descriptor1:
   \   00000000   0x14 0x03          DC8 20, 3, 76, 0, 97, 0, 112, 0, 108, 0, 101, 0, 110, 0, 100, 0, 101, 0
   \              0x4C 0x00    
   \              0x61 0x00    
   \              0x70 0x00    
   \              0x6C 0x00    
   \              0x65 0x00    
   \              0x6E 0x00    
   \              0x64 0x00    
   \              0x65 0x00    
   \   00000012   0x6E 0x00          DC8 110, 0

   \                                 In section .rodata, align 4
   \   __absolute unsigned char const String_Descriptor2[18]
   \                     String_Descriptor2:
   \   00000000   0x12 0x03          DC8 18, 3, 85, 0, 83, 0, 66, 0, 45, 0, 85, 0, 65, 0, 82, 0, 84, 0, 0, 0
   \              0x55 0x00    
   \              0x53 0x00    
   \              0x42 0x00    
   \              0x2D 0x00    
   \              0x55 0x00    
   \              0x41 0x00    
   \              0x52 0x00    
   \              0x54 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   __absolute unsigned char const String_Descriptor3[18]
   \                     String_Descriptor3:
   \   00000000   0x12 0x03          DC8 18, 3, 84, 0, 69, 0, 83, 0, 84, 0, 95, 0, 49, 0, 46, 0, 49, 0, 0, 0
   \              0x54 0x00    
   \              0x45 0x00    
   \              0x53 0x00    
   \              0x54 0x00    
   \              0x5F 0x00    
   \              0x31 0x00    
   \              0x2E 0x00    
   \              0x31 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   __absolute unsigned char const Configuration_Descriptor[67]
   \                     Configuration_Descriptor:
   \   00000000   0x09 0x02          DC8 9, 2, 67, 0, 2, 1, 0, 192, 50, 9, 4, 0, 0, 1, 2, 2, 1, 1, 5, 36, 0
   \              0x43 0x00    
   \              0x02 0x01    
   \              0x00 0xC0    
   \              0x32 0x09    
   \              0x04 0x00    
   \              0x00 0x01    
   \              0x02 0x02    
   \              0x01 0x01    
   \              0x05 0x24    
   \              0x00         
   \   00000015   0x10 0x01          DC8 16, 1, 5, 36, 1, 0, 1, 4, 36, 2, 0, 5, 36, 6, 0, 1, 7, 5, 129, 3
   \              0x05 0x24    
   \              0x01 0x00    
   \              0x01 0x04    
   \              0x24 0x02    
   \              0x00 0x05    
   \              0x24 0x06    
   \              0x00 0x01    
   \              0x07 0x05    
   \              0x81 0x03    
   \   00000029   0x40 0x00          DC8 64, 0, 2, 9, 4, 1, 0, 2, 10, 0, 0, 1, 7, 5, 130, 2, 64, 0, 0, 7, 5
   \              0x02 0x09    
   \              0x04 0x01    
   \              0x00 0x02    
   \              0x0A 0x00    
   \              0x00 0x01    
   \              0x07 0x05    
   \              0x82 0x02    
   \              0x40 0x00    
   \              0x00 0x07    
   \              0x05         
   \   0000003E   0x03 0x02          DC8 3, 2, 64, 0, 0, 0
   \              0x40 0x00    
   \              0x00 0x00    
     14          
     15          //设置USB 缓冲区对齐
     16          //USB缓冲区必须是512字节对齐
     17          #pragma data_alignment=512
     18          

   \                                 In section .bss, align 512
     19          tBDT tBDTtable[16]; //为16个缓冲区分配缓冲区描述符
   \                     tBDTtable:
   \   00000000                      DS8 128
     20          
     21          //定义端点0缓冲区

   \                                 In section .bss, align 4
     22          UINT8 gu8EP0_OUT_ODD_Buffer[EP0_SIZE];
   \                     gu8EP0_OUT_ODD_Buffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     23          UINT8 gu8EP0_OUT_EVEN_Buffer[EP0_SIZE];
   \                     gu8EP0_OUT_EVEN_Buffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     24          UINT8 gu8EP0_IN_ODD_Buffer[EP0_SIZE];
   \                     gu8EP0_IN_ODD_Buffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     25          UINT8 gu8EP0_IN_EVEN_Buffer[EP0_SIZE];
   \                     gu8EP0_IN_EVEN_Buffer:
   \   00000000                      DS8 64
     26          //定义端点1缓冲区

   \                                 In section .bss, align 4
     27          UINT8 gu8EP1_OUT_ODD_Buffer[EP1_SIZE];
   \                     gu8EP1_OUT_ODD_Buffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     28          UINT8 gu8EP1_OUT_EVEN_Buffer[EP1_SIZE];
   \                     gu8EP1_OUT_EVEN_Buffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     29          UINT8 gu8EP1_IN_ODD_Buffer[EP1_SIZE];
   \                     gu8EP1_IN_ODD_Buffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     30          UINT8 gu8EP1_IN_EVEN_Buffer[EP1_SIZE];
   \                     gu8EP1_IN_EVEN_Buffer:
   \   00000000                      DS8 64
     31          //定义端点2缓冲区

   \                                 In section .bss, align 4
     32          UINT8 gu8EP2_OUT_ODD_Buffer[EP2_SIZE];
   \                     gu8EP2_OUT_ODD_Buffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     33          UINT8 gu8EP2_OUT_EVEN_Buffer[EP2_SIZE];
   \                     gu8EP2_OUT_EVEN_Buffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     34          UINT8 gu8EP2_IN_ODD_Buffer[EP2_SIZE];
   \                     gu8EP2_IN_ODD_Buffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     35          UINT8 gu8EP2_IN_EVEN_Buffer[EP2_SIZE];
   \                     gu8EP2_IN_EVEN_Buffer:
   \   00000000                      DS8 64
     36          //定义端点3缓冲区

   \                                 In section .bss, align 4
     37          UINT8 gu8EP3_OUT_ODD_Buffer[EP3_SIZE];
   \                     gu8EP3_OUT_ODD_Buffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     38          UINT8 gu8EP3_OUT_EVEN_Buffer[EP3_SIZE];
   \                     gu8EP3_OUT_EVEN_Buffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     39          UINT8 gu8EP3_IN_ODD_Buffer[EP3_SIZE];
   \                     gu8EP3_IN_ODD_Buffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     40          UINT8 gu8EP3_IN_EVEN_Buffer[EP3_SIZE];
   \                     gu8EP3_IN_EVEN_Buffer:
   \   00000000                      DS8 64
     41          //定义端点缓冲区指针

   \                                 In section .data, align 4
     42          UINT8 *BufferPointer[]=
   \                     BufferPointer:
   \   00000000   0x........         DC32 gu8EP0_OUT_ODD_Buffer, gu8EP0_OUT_EVEN_Buffer
   \              0x........   
   \   00000008   0x........         DC32 gu8EP0_IN_ODD_Buffer, gu8EP0_IN_EVEN_Buffer, gu8EP1_OUT_ODD_Buffer
   \              0x........   
   \              0x........   
   \   00000014   0x........         DC32 gu8EP1_OUT_EVEN_Buffer, gu8EP1_IN_ODD_Buffer
   \              0x........   
   \   0000001C   0x........         DC32 gu8EP1_IN_EVEN_Buffer, gu8EP2_OUT_ODD_Buffer
   \              0x........   
   \   00000024   0x........         DC32 gu8EP2_OUT_EVEN_Buffer, gu8EP2_IN_ODD_Buffer
   \              0x........   
   \   0000002C   0x........         DC32 gu8EP2_IN_EVEN_Buffer, gu8EP3_OUT_ODD_Buffer
   \              0x........   
   \   00000034   0x........         DC32 gu8EP3_OUT_EVEN_Buffer, gu8EP3_IN_ODD_Buffer
   \              0x........   
   \   0000003C   0x........         DC32 gu8EP3_IN_EVEN_Buffer
     43          {
     44              gu8EP0_OUT_ODD_Buffer,
     45              gu8EP0_OUT_EVEN_Buffer,
     46              gu8EP0_IN_ODD_Buffer,
     47              gu8EP0_IN_EVEN_Buffer,
     48              gu8EP1_OUT_ODD_Buffer,
     49              gu8EP1_OUT_EVEN_Buffer,
     50              gu8EP1_IN_ODD_Buffer,
     51              gu8EP1_IN_EVEN_Buffer,
     52              gu8EP2_OUT_ODD_Buffer,
     53              gu8EP2_OUT_EVEN_Buffer,
     54              gu8EP2_IN_ODD_Buffer,
     55              gu8EP2_IN_EVEN_Buffer,
     56              gu8EP3_OUT_ODD_Buffer,
     57              gu8EP3_OUT_EVEN_Buffer,
     58              gu8EP3_IN_ODD_Buffer,
     59              gu8EP3_IN_EVEN_Buffer
     60          };
     61          //定义端点缓冲区长度

   \                                 In section .rodata, align 4
     62          const UINT8 cEP_Size[]=
   \                     cEP_Size:
   \   00000000   0x40 0x40          DC8 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64
   \              0x40 0x40    
   \              0x40 0x40    
   \              0x40 0x40    
   \              0x40 0x40    
   \              0x40 0x40    
   \              0x40 0x40    
   \              0x40 0x40    
     63          {
     64              EP0_SIZE,    
     65              EP0_SIZE,    
     66              EP0_SIZE,    
     67              EP0_SIZE,    
     68              EP1_SIZE,    
     69              EP1_SIZE,    
     70              EP1_SIZE,    
     71              EP1_SIZE,    
     72              EP2_SIZE,    
     73              EP2_SIZE,    
     74              EP2_SIZE,    
     75              EP2_SIZE,    
     76              EP3_SIZE,
     77              EP3_SIZE,
     78              EP3_SIZE,
     79              EP3_SIZE
     80          };
     81          

   \                                 In section .data, align 4
     82          const UINT8* String_Table[4]=
   \                     String_Table:
   \   00000000   0x........         DC32 String_Descriptor0, String_Descriptor1, String_Descriptor2
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 String_Descriptor3
     83          {
     84              String_Descriptor0,
     85              String_Descriptor1,
     86              String_Descriptor2,
     87              String_Descriptor3
     88          };
     89          
     90          
     91          /* Global Variables for USB Handling */

   \                                 In section .bss, align 1
     92          UINT8 gu8USB_Flags;        //USB接收完成标志位
   \                     gu8USB_Flags:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     93          UINT8 gu8USBClearFlags;
   \                     gu8USBClearFlags:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     94          UINT8 *pu8IN_DataPointer; //USB输入缓冲区指针
   \                     pu8IN_DataPointer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     95          UINT8 gu8IN_Counter;
   \                     gu8IN_Counter:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     96          UINT8 gu8USB_Toogle_flags;//USB数据翻转标志位
   \                     gu8USB_Toogle_flags:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     97          UINT8 gu8Dummy;
   \                     gu8Dummy:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
     98          UINT16 gu8Status;
   \                     gu8Status:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
     99          UINT8 gu8Interface;       //USB接口标志位
   \                     gu8Interface:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    100          UINT8 gu8HALT_EP;         //USB端点停止标志位
   \                     gu8HALT_EP:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    101          UINT8 gu8USB_State;       //USB进程标志位
   \                     gu8USB_State:
   \   00000000                      DS8 1
    102          

   \                                 In section .bss, align 4
    103          tUSB_Setup *Setup_Pkt;//定义setup数据包指针
   \                     Setup_Pkt:
   \   00000000                      DS8 4
    104           

   \                                 In section .bss, align 4
    105          USB_REV_CALLBACK usb_rev_data_isr;
   \                     usb_rev_data_isr:
   \   00000000                      DS8 4
    106          

   \                                 In section .text, align 2, keep-with-next
    107          void USB_Rev_SetIsr(USB_REV_CALLBACK isr)
    108          {
    109            usb_rev_data_isr = isr; 
   \                     USB_Rev_SetIsr:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000004   0x6008             STR      R0,[R1, #+0]
    110          }
   \   00000006   0x4770             BX       LR               ;; return
    111          
    112          /*
    113          * EP_IN_Transfer
    114          *   端点IN传送，在不同USB模式下IN的含义不同
    115          *     在USB主机模式下（USB host）  IN表示  USB Host接收 USB Device的数据包
    116          *     在USB设备模式下（USB Device）IN表示  USB Host向 USB Device发送数据包
    117          *   当前在USB Device模式下，该函数的作用是Device设备发送数据包
    118          */

   \                                 In section .text, align 2, keep-with-next
    119          void EP_IN_Transfer(UINT8 u8EP,UINT8 *pu8DataPointer,UINT8 u8DataSize)
    120          {
   \                     EP_IN_Transfer:
   \   00000000   0xB430             PUSH     {R4,R5}
    121            UINT8 *pu8EPBuffer;
    122            UINT8 u8EPSize;     //端点的数据长度
    123            UINT16 u16Lenght=0;    
   \   00000002   0x2500             MOVS     R5,#+0
    124            UINT8 u8EndPointFlag;    
    125            
    126            /*调整当前缓冲区的位置*/
    127            u8EndPointFlag=u8EP;
   \   00000004   0x0003             MOVS     R3,R0
    128            if(u8EP)   //如果不是端点0,
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD000             BEQ.N    ??EP_IN_Transfer_0
    129              u8EP=(UINT8)(u8EP<<2);
   \   0000000C   0x0080             LSLS     R0,R0,#+2
    130            u8EP+=2; //EP值加2
   \                     ??EP_IN_Transfer_0:
   \   0000000E   0x1C80             ADDS     R0,R0,#+2
    131            
    132            pu8EPBuffer=BufferPointer[u8EP];   //将新EP的BUFFER地址给pu8EPBuffer
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      LDR.W    R4,??DataTable14_1
   \   00000016   0xF854 0x4020      LDR      R4,[R4, R0, LSL #+2]
    133            
    134            if(FLAG_CHK(fIN,gu8USBClearFlags)) //如果gu8USBClearFlags = 1
   \   0000001A   0x.... 0x....      LDR.W    R5,??DataTable14_2
   \   0000001E   0x782D             LDRB     R5,[R5, #+0]
   \   00000020   0x07ED             LSLS     R5,R5,#+31
   \   00000022   0xD51E             BPL.N    ??EP_IN_Transfer_1
    135            {
    136                pu8IN_DataPointer = pu8DataPointer; //将用户数据存储区的首地址给pu8IN_DataPointer
   \   00000024   0x.... 0x....      LDR.W    R5,??DataTable14_3
   \   00000028   0x6029             STR      R1,[R5, #+0]
    137                gu8IN_Counter = u8DataSize;         //将用户数据长度给gu8IN_Counter
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   0000002E   0x700A             STRB     R2,[R1, #+0]
    138          
    139                u16Lenght=(Setup_Pkt->wLength_h<<8)+Setup_Pkt->wLength_l ;//将setup数据的长度给u16Lenght
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x79C9             LDRB     R1,[R1, #+7]
   \   00000038   0x0209             LSLS     R1,R1,#+8
   \   0000003A   0x.... 0x....      LDR.W    R5,??DataTable14_5
   \   0000003E   0x682D             LDR      R5,[R5, #+0]
   \   00000040   0x79AD             LDRB     R5,[R5, #+6]
   \   00000042   0x194D             ADDS     R5,R1,R5
    140                if((u16Lenght < u8DataSize) && (u8EP==2)) //如果所发送的数据长度大于setup所设定的长度 同时 端点值 == 2
   \   00000044   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000046   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000048   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000004A   0x4295             CMP      R5,R2
   \   0000004C   0xD209             BCS.N    ??EP_IN_Transfer_1
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x2802             CMP      R0,#+2
   \   00000052   0xD106             BNE.N    ??EP_IN_Transfer_1
    141                {
    142                    gu8IN_Counter=Setup_Pkt->wLength_l; //只发送setup中的低8位长度
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   00000058   0x6809             LDR      R1,[R1, #+0]
   \   0000005A   0x7989             LDRB     R1,[R1, #+6]
   \   0000005C   0x.... 0x....      LDR.W    R2,??DataTable14_4
   \   00000060   0x7011             STRB     R1,[R2, #+0]
    143                }
    144            }
    145            /*检查发送长度*/
    146            if(gu8IN_Counter > cEP_Size[u8EP]) //如果发送数据包的长度 大于32字节时
   \                     ??EP_IN_Transfer_1:
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable14_6
   \   00000068   0x5C41             LDRB     R1,[R0, R1]
   \   0000006A   0x.... 0x....      LDR.W    R2,??DataTable14_4
   \   0000006E   0x7812             LDRB     R2,[R2, #+0]
   \   00000070   0x4291             CMP      R1,R2
   \   00000072   0xD217             BCS.N    ??EP_IN_Transfer_2
    147            {
    148                u8EPSize = cEP_Size[u8EP];     //将此时端点的长度限制在端点的默认长度
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable14_6
   \   0000007A   0x5C41             LDRB     R1,[R0, R1]
    149                gu8IN_Counter-=cEP_Size[u8EP]; //将数据包的长度减少EP_Size
   \   0000007C   0x.... 0x....      LDR.W    R2,??DataTable14_4
   \   00000080   0x7812             LDRB     R2,[R2, #+0]
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x.... 0x....      LDR.W    R5,??DataTable14_6
   \   00000088   0x5D45             LDRB     R5,[R0, R5]
   \   0000008A   0x1B52             SUBS     R2,R2,R5
   \   0000008C   0x.... 0x....      LDR.W    R5,??DataTable14_4
   \   00000090   0x702A             STRB     R2,[R5, #+0]
    150                FLAG_CLR(fIN,gu8USBClearFlags);//将gu8USBClearFlags清零
   \   00000092   0x.... 0x....      LDR.W    R2,??DataTable14_2
   \   00000096   0x7812             LDRB     R2,[R2, #+0]
   \   00000098   0xF012 0x02FE      ANDS     R2,R2,#0xFE
   \   0000009C   0x.... 0x....      LDR.W    R5,??DataTable14_2
   \   000000A0   0x702A             STRB     R2,[R5, #+0]
   \   000000A2   0xE00E             B.N      ??EP_IN_Transfer_3
    151            }
    152            else
    153            { 
    154                u8EPSize = gu8IN_Counter;      //如果小于
   \                     ??EP_IN_Transfer_2:
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   000000A8   0x7809             LDRB     R1,[R1, #+0]
    155                gu8IN_Counter=0;            
   \   000000AA   0x.... 0x....      LDR.W    R2,??DataTable14_4
   \   000000AE   0x2500             MOVS     R5,#+0
   \   000000B0   0x7015             STRB     R5,[R2, #+0]
    156                FLAG_SET(fIN,gu8USBClearFlags);//将gu8USBClearFlags置一
   \   000000B2   0x.... 0x....      LDR.W    R2,??DataTable14_2
   \   000000B6   0x7812             LDRB     R2,[R2, #+0]
   \   000000B8   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   000000BC   0x.... 0x....      LDR.W    R5,??DataTable14_2
   \   000000C0   0x702A             STRB     R2,[R5, #+0]
    157            }
    158          
    159            /*将用户缓冲的区的值复制到EP 缓冲区中准备发送*/
    160            tBDTtable[u8EP].Cnt=(u8EPSize);    //复制所要发送的数据长度
   \                     ??EP_IN_Transfer_3:
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0x.... 0x....      LDR.W    R2,??DataTable14_7
   \   000000C8   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   000000CC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000CE   0x8051             STRH     R1,[R2, #+2]
   \   000000D0   0xE00C             B.N      ??EP_IN_Transfer_4
    161            
    162            while(u8EPSize--)
    163                 *pu8EPBuffer++=*pu8IN_DataPointer++; //将用户的数据赋值给EP存储区
   \                     ??EP_IN_Transfer_5:
   \   000000D2   0x.... 0x....      LDR.W    R2,??DataTable14_3
   \   000000D6   0x6812             LDR      R2,[R2, #+0]
   \   000000D8   0x7812             LDRB     R2,[R2, #+0]
   \   000000DA   0x7022             STRB     R2,[R4, #+0]
   \   000000DC   0x.... 0x....      LDR.W    R2,??DataTable14_3
   \   000000E0   0x6812             LDR      R2,[R2, #+0]
   \   000000E2   0x1C52             ADDS     R2,R2,#+1
   \   000000E4   0x.... 0x....      LDR.W    R5,??DataTable14_3
   \   000000E8   0x602A             STR      R2,[R5, #+0]
   \   000000EA   0x1C64             ADDS     R4,R4,#+1
   \                     ??EP_IN_Transfer_4:
   \   000000EC   0x000A             MOVS     R2,R1
   \   000000EE   0x1E51             SUBS     R1,R2,#+1
   \   000000F0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F2   0x2A00             CMP      R2,#+0
   \   000000F4   0xD1ED             BNE.N    ??EP_IN_Transfer_5
    164                                                                     
    165            if(FLAG_CHK(u8EndPointFlag,gu8USB_Toogle_flags)) //如果相应端点的gu8USB_Toogle_flags == 1
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   000000FA   0x7809             LDRB     R1,[R1, #+0]
   \   000000FC   0x2201             MOVS     R2,#+1
   \   000000FE   0x409A             LSLS     R2,R2,R3
   \   00000100   0x4211             TST      R1,R2
   \   00000102   0xD00F             BEQ.N    ??EP_IN_Transfer_6
    166            {
    167                tBDTtable[u8EP].Stat._byte= kUDATA0;         
   \   00000104   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable14_7
   \   0000010A   0x2288             MOVS     R2,#+136
   \   0000010C   0xF801 0x2030      STRB     R2,[R1, R0, LSL #+3]
    168                FLAG_CLR(u8EndPointFlag,gu8USB_Toogle_flags);//清零相应端点的gu8USB_Toogle_flags
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0x2101             MOVS     R1,#+1
   \   00000118   0x4099             LSLS     R1,R1,R3
   \   0000011A   0x4388             BICS     R0,R0,R1
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   00000120   0x7008             STRB     R0,[R1, #+0]
   \   00000122   0xE00E             B.N      ??EP_IN_Transfer_7
    169            } 
    170            else
    171            {
    172                tBDTtable[u8EP].Stat._byte= kUDATA1;          
   \                     ??EP_IN_Transfer_6:
   \   00000124   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000126   0x.... 0x....      LDR.W    R1,??DataTable14_7
   \   0000012A   0x22C8             MOVS     R2,#+200
   \   0000012C   0xF801 0x2030      STRB     R2,[R1, R0, LSL #+3]
    173                FLAG_SET(u8EndPointFlag,gu8USB_Toogle_flags);//置位gu8USB_Toogle_flags
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   00000134   0x7800             LDRB     R0,[R0, #+0]
   \   00000136   0x2101             MOVS     R1,#+1
   \   00000138   0x4099             LSLS     R1,R1,R3
   \   0000013A   0x4308             ORRS     R0,R1,R0
   \   0000013C   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   00000140   0x7008             STRB     R0,[R1, #+0]
    174            }
    175          }
   \                     ??EP_IN_Transfer_7:
   \   00000142   0xBC30             POP      {R4,R5}
   \   00000144   0x4770             BX       LR               ;; return
    176          
    177          /*
    178          * EP_OUT_Transfer
    179          *   端点OUT传送，在不同USB模式下OUT的含义不同
    180          *     在USB主机模式下（USB host）  OUT表示  USB Host向 USB Device发送数据包
    181          *     在USB设备模式下（USB Device）OUT表示  USB Host从 USB Device接收数据包
    182          *   当前在USB Device模式下，该函数的作用是Device设备接收数据包
    183          *   返回值，返回接收到的数据的长度
    184          */

   \                                 In section .text, align 2, keep-with-next
    185          UINT8 EP_OUT_Transfer(UINT8 u8EP,UINT8 *pu8DataPointer)
    186          {
   \                     EP_OUT_Transfer:
   \   00000000   0xB410             PUSH     {R4}
    187              UINT8 *pu8EPBuffer;
    188              UINT8 u8EPSize; 
    189              /* 调整缓冲区的位置 */
    190              u8EP++;
   \   00000002   0x1C40             ADDS     R0,R0,#+1
    191              /* 分配合适的EP缓冲，EP0是控制点，EP1为输入中断点，EP2是输入BULK点 */
    192              pu8EPBuffer=BufferPointer[u8EP];
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable14_1
   \   0000000A   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
    193              
    194              u8EPSize=tBDTtable[u8EP].Cnt;
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      LDR.W    R3,??DataTable14_7
   \   00000014   0xEB13 0x00C0      ADDS     R0,R3,R0, LSL #+3
   \   00000018   0x8843             LDRH     R3,[R0, #+2]
    195              u8EP=u8EPSize;
   \   0000001A   0x0018             MOVS     R0,R3
   \   0000001C   0xE003             B.N      ??EP_OUT_Transfer_0
    196              /* 将EP缓冲的数据复制给用户区 */
    197              while(u8EPSize--)
    198                *pu8DataPointer++=*pu8EPBuffer++;
   \                     ??EP_OUT_Transfer_1:
   \   0000001E   0x7814             LDRB     R4,[R2, #+0]
   \   00000020   0x700C             STRB     R4,[R1, #+0]
   \   00000022   0x1C52             ADDS     R2,R2,#+1
   \   00000024   0x1C49             ADDS     R1,R1,#+1
   \                     ??EP_OUT_Transfer_0:
   \   00000026   0x001C             MOVS     R4,R3
   \   00000028   0x1E63             SUBS     R3,R4,#+1
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD1F6             BNE.N    ??EP_OUT_Transfer_1
    199              return(u8EP);
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0xBC10             POP      {R4}
   \   00000034   0x4770             BX       LR               ;; return
    200          }
    201          
    202          /*
    203          * USB_EP_OUT_SizeCheck
    204          *   端点输入数据长度检查
    205          *
    206          */

   \                                 In section .text, align 2, keep-with-next
    207          UINT16 USB_EP_OUT_SizeCheck(UINT8 u8EP)
    208          {
    209            UINT8 u8EPSize; 
    210             /* 读取缓冲区的长度 */
    211            u8EPSize = tBDTtable[u8EP<<2].Cnt;
   \                     USB_EP_OUT_SizeCheck:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x0080             LSLS     R0,R0,#+2
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable14_7
   \   00000008   0xEB11 0x00C0      ADDS     R0,R1,R0, LSL #+3
   \   0000000C   0x8840             LDRH     R0,[R0, #+2]
    212            //u8EPSize=SWAP16(tBDTtable[u8EP<<2].Cnt);
    213            return(u8EPSize & 0x03FF);
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   0x4770             BX       LR               ;; return
    214          }
    215          
    216          /*
    217          * USB_Set_Interface
    218          *   USB设置端点函数
    219          *
    220          */

   \                                 In section .text, align 2, keep-with-next
    221          void USB_Set_Interface(void)
    222          {
    223            /* 端点寄存器设置 */
    224            USB0_ENDPT1= EP1_VALUE | USB_ENDPT_EPHSHK_MASK; //设置端点1为中断端点                       
   \                     USB_Set_Interface:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable14_9  ;; 0x400720c4
   \   00000004   0x2105             MOVS     R1,#+5
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    225            USB0_ENDPT2= EP2_VALUE | USB_ENDPT_EPHSHK_MASK; //设置端点2为输入 BULK端点                     
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable14_10  ;; 0x400720c8
   \   0000000C   0x2105             MOVS     R1,#+5
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
    226            USB0_ENDPT3= EP3_VALUE | USB_ENDPT_EPHSHK_MASK; //设置端点3为输出 BULK端点                         
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14_11  ;; 0x400720cc
   \   00000014   0x2109             MOVS     R1,#+9
   \   00000016   0x7001             STRB     R1,[R0, #+0]
    227            USB0_ENDPT4= EP4_VALUE | USB_ENDPT_EPHSHK_MASK; //禁止端点                        
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable14_12  ;; 0x400720d0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
    228            USB0_ENDPT5= EP5_VALUE | USB_ENDPT_EPHSHK_MASK; //禁止端点                         
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable14_13  ;; 0x400720d4
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x7001             STRB     R1,[R0, #+0]
    229            USB0_ENDPT6= EP6_VALUE | USB_ENDPT_EPHSHK_MASK; //禁止端点                         
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable14_14  ;; 0x400720d8
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x7001             STRB     R1,[R0, #+0]
    230          
    231            /* 端点 1 BDT 设置*/
    232            tBDTtable[bEP1IN_ODD].Stat._byte= kMCU;//USB-FS 有专有权访问 BD
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0xF880 0x1030      STRB     R1,[R0, #+48]
    233                                                   //定义DATA0允许发送或者接收
    234            tBDTtable[bEP1IN_ODD].Cnt = 0x00;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x8641             STRH     R1,[R0, #+50]
    235            tBDTtable[bEP1IN_ODD].Addr =(UINT32)gu8EP1_IN_ODD_Buffer;
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable14_15
   \   0000004A   0x6341             STR      R1,[R0, #+52]
    236          
    237            /* 端点 2 BDT 设置*/
    238            tBDTtable[bEP2IN_ODD].Stat._byte= kMCU;//USB-FS 有专有权访问 BD
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0xF880 0x1050      STRB     R1,[R0, #+80]
    239                                                   //定义DATA0允许发送或者接收  
    240            tBDTtable[bEP2IN_ODD].Cnt = 0x00;
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0xF8A0 0x1052      STRH     R1,[R0, #+82]
    241            tBDTtable[bEP2IN_ODD].Addr =(UINT32)gu8EP2_IN_ODD_Buffer;            
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable14_16
   \   00000068   0x6541             STR      R1,[R0, #+84]
    242          
    243            /* 端点 3 BDT 设置*/
    244            tBDTtable[bEP3OUT_ODD].Stat._byte= kSIE;//USB-FS 有专有权访问 BD
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   0000006E   0x2180             MOVS     R1,#+128
   \   00000070   0xF880 0x1060      STRB     R1,[R0, #+96]
    245                                                    //使能USB-FS去扮演数据翻转同步
    246                                                    //定义DATA0允许发送或者接收 
    247            tBDTtable[bEP3OUT_ODD].Cnt = 0xFF;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   00000078   0x21FF             MOVS     R1,#+255
   \   0000007A   0xF8A0 0x1062      STRH     R1,[R0, #+98]
    248            tBDTtable[bEP3OUT_ODD].Addr =(UINT32)gu8EP3_OUT_ODD_Buffer;            
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable14_17
   \   00000086   0x6641             STR      R1,[R0, #+100]
    249          }
   \   00000088   0x4770             BX       LR               ;; return
    250          
    251          
    252          /*
    253          * USB_StdReq_Handler
    254          *   如果USB接收的Setup的请求形式时设备请求（标准请求）形式
    255          *   进入到标准请求中断服务函数中
    256          *
    257          */

   \                                 In section .text, align 2, keep-with-next
    258          void USB_StdReq_Handler(void)
    259          {
   \                     USB_StdReq_Handler:
   \   00000000   0xB580             PUSH     {R7,LR}
    260            switch(Setup_Pkt->bRequest) //判断该请求形式下数据包中的命令
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x7840             LDRB     R0,[R0, #+1]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD06E             BEQ.N    ??USB_StdReq_Handler_0
   \   0000000E   0x2805             CMP      R0,#+5
   \   00000010   0xD006             BEQ.N    ??USB_StdReq_Handler_1
   \   00000012   0x2806             CMP      R0,#+6
   \   00000014   0xD00E             BEQ.N    ??USB_StdReq_Handler_2
   \   00000016   0x2808             CMP      R0,#+8
   \   00000018   0xD061             BEQ.N    ??USB_StdReq_Handler_3
   \   0000001A   0x2809             CMP      R0,#+9
   \   0000001C   0xD03B             BEQ.N    ??USB_StdReq_Handler_4
   \   0000001E   0xE070             B.N      ??USB_StdReq_Handler_5
    261            {
    262              case mSET_ADDRESS:          //USB device设置地址命令
    263                  EP_IN_Transfer(EP0,0,0);//端点0开始发送自己的地址
   \                     ??USB_StdReq_Handler_1:
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       EP_IN_Transfer
    264                  gu8USB_State=uADDRESS;  //将USB的状态位改为已设置地址状态
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14_18
   \   0000002E   0x2103             MOVS     R1,#+3
   \   00000030   0x7001             STRB     R1,[R0, #+0]
    265                  break;
   \   00000032   0xE068             B.N      ??USB_StdReq_Handler_6
    266            
    267              case mGET_DESC:             //PC获得USB设置描述符命令
    268                  switch(Setup_Pkt->wValue_h) //判断Setup数据包中的要发送的描述符
   \                     ??USB_StdReq_Handler_2:
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD004             BEQ.N    ??USB_StdReq_Handler_7
   \   00000040   0xD326             BCC.N    ??USB_StdReq_Handler_8
   \   00000042   0x2803             CMP      R0,#+3
   \   00000044   0xD00F             BEQ.N    ??USB_StdReq_Handler_9
   \   00000046   0xD307             BCC.N    ??USB_StdReq_Handler_10
   \   00000048   0xE022             B.N      ??USB_StdReq_Handler_8
    269                  {
    270                      case mDEVICE:           //要求底层设备发送设备描述符
    271                          EP_IN_Transfer(EP0,(UINT8*)Device_Descriptor,sizeof(Device_Descriptor));
   \                     ??USB_StdReq_Handler_7:
   \   0000004A   0x2212             MOVS     R2,#+18
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable14_19
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      BL       EP_IN_Transfer
    272                          break;
   \   00000056   0xE01D             B.N      ??USB_StdReq_Handler_11
    273                          
    274                      case mCONFIGURATION:    //要求发送配置描述符
    275                          EP_IN_Transfer(EP0,(UINT8*)Configuration_Descriptor,sizeof(Configuration_Descriptor));
   \                     ??USB_StdReq_Handler_10:
   \   00000058   0x2243             MOVS     R2,#+67
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable14_20
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      BL       EP_IN_Transfer
    276                          break;
   \   00000064   0xE016             B.N      ??USB_StdReq_Handler_11
    277              
    278                      case mSTRING:           //要求发送字符串描述符
    279                          EP_IN_Transfer(EP0,(UINT8*)String_Table[Setup_Pkt->wValue_l],String_Table[Setup_Pkt->wValue_l][0]);
   \                     ??USB_StdReq_Handler_9:
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x7880             LDRB     R0,[R0, #+2]
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable14_21
   \   00000072   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000076   0x7802             LDRB     R2,[R0, #+0]
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x7880             LDRB     R0,[R0, #+2]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable14_21
   \   00000084   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x.... 0x....      BL       EP_IN_Transfer
    280                          break;
   \   0000008E   0xE001             B.N      ??USB_StdReq_Handler_11
    281          
    282                      default:               
    283                          USB_EP0_Stall();   //如果都不是，转为端点0 stall（停止）模式
   \                     ??USB_StdReq_Handler_8:
   \   00000090   0x.... 0x....      BL       USB_EP0_Stall
    284                          break;  
    285                  }
    286                  break;
   \                     ??USB_StdReq_Handler_11:
   \   00000094   0xE037             B.N      ??USB_StdReq_Handler_6
    287          
    288              case mSET_CONFIG:                             //USB device设备配置命令
    289                  gu8Dummy=Setup_Pkt->wValue_h+Setup_Pkt->wValue_l; //组合成16位数据
   \                     ??USB_StdReq_Handler_4:
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   000000A2   0x6809             LDR      R1,[R1, #+0]
   \   000000A4   0x7889             LDRB     R1,[R1, #+2]
   \   000000A6   0x1808             ADDS     R0,R1,R0
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable14_22
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
    290                  if(Setup_Pkt->wValue_h+Setup_Pkt->wValue_l) 
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x78C0             LDRB     R0,[R0, #+3]
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   000000BA   0x6809             LDR      R1,[R1, #+0]
   \   000000BC   0x7889             LDRB     R1,[R1, #+2]
   \   000000BE   0x1808             ADDS     R0,R1,R0
   \   000000C0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD00A             BEQ.N    ??USB_StdReq_Handler_12
    291                  {
    292                      USB_Set_Interface();                  // 配置USB device的中断端点、bulk端点                    
   \   000000C6   0x.... 0x....      BL       USB_Set_Interface
    293                      EP_IN_Transfer(EP0,0,0);              // 端点0开始传输
   \   000000CA   0x2200             MOVS     R2,#+0
   \   000000CC   0x2100             MOVS     R1,#+0
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x.... 0x....      BL       EP_IN_Transfer
    294                      gu8USB_State=uENUMERATED;             // 设置USB的状态为以被枚举状态
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable14_18
   \   000000D8   0x2101             MOVS     R1,#+1
   \   000000DA   0x7001             STRB     R1,[R0, #+0]
    295                  }
    296                  break;
   \                     ??USB_StdReq_Handler_12:
   \   000000DC   0xE013             B.N      ??USB_StdReq_Handler_6
    297            
    298              case mGET_CONFIG:                             //PC获得USB的设备配置命令  
    299                  EP_IN_Transfer(EP0,(UINT8*)&gu8Dummy,1);  //端点0发送组合而成的16位数据
   \                     ??USB_StdReq_Handler_3:
   \   000000DE   0x2201             MOVS     R2,#+1
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable14_22
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x.... 0x....      BL       EP_IN_Transfer
    300                  break;
   \   000000EA   0xE00C             B.N      ??USB_StdReq_Handler_6
    301          
    302              case mGET_STATUS:                             //PC获得USB的状态命令
    303                  gu8Status=0;                              //设置gu8Status = 0
   \                     ??USB_StdReq_Handler_0:
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable14_23
   \   000000F0   0x2100             MOVS     R1,#+0
   \   000000F2   0x8001             STRH     R1,[R0, #+0]
    304                  EP_IN_Transfer(EP0,(UINT8*)&gu8Status,2); //端点0发送状2个字节的状态
   \   000000F4   0x2202             MOVS     R2,#+2
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable14_23
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x.... 0x....      BL       EP_IN_Transfer
    305                  break;
   \   00000100   0xE001             B.N      ??USB_StdReq_Handler_6
    306          
    307              default:
    308                  USB_EP0_Stall();                          //如果都不是，转为端点0 stall（停止）模式                                                   
   \                     ??USB_StdReq_Handler_5:
   \   00000102   0x.... 0x....      BL       USB_EP0_Stall
    309                  break;
    310            }
    311          }
   \                     ??USB_StdReq_Handler_6:
   \   00000106   0xBD01             POP      {R0,PC}          ;; return
    312          
    313          
    314          /*
    315          * USB_Setup_Handler
    316          *  USB SETUP中断，表示一次控制传输的开始。
    317          *  SETUP是控制传输的第一阶段，
    318          *  并用来把一个请求从系统发往目标USB设备。
    319          */

   \                                 In section .text, align 2, keep-with-next
    320          void USB_Setup_Handler(void)
    321          {
   \                     USB_Setup_Handler:
   \   00000000   0xB580             PUSH     {R7,LR}
    322            UINT8 u8State;
    323            FLAG_CLR(0,gu8USB_Toogle_flags);        //将gu8USB_Toogle_flags = 0
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    324            switch(Setup_Pkt->bmRequestType & 0x1F) //判断Setup数据包中请求的形式
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD003             BEQ.N    ??USB_Setup_Handler_0
   \   00000024   0x2802             CMP      R0,#+2
   \   00000026   0xD01E             BEQ.N    ??USB_Setup_Handler_1
   \   00000028   0xD30E             BCC.N    ??USB_Setup_Handler_2
   \   0000002A   0xE023             B.N      ??USB_Setup_Handler_3
    325            {
    326                case DEVICE_REQ: //如果是设备请求形式
    327                    if((Setup_Pkt->bmRequestType & 0x1F)== STANDARD_REQ) //设备请求形式等于标准请求形式
   \                     ??USB_Setup_Handler_0:
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x211F             MOVS     R1,#+31
   \   00000036   0x4208             TST      R0,R1
   \   00000038   0xD101             BNE.N    ??USB_Setup_Handler_4
    328                    {            
    329                        USB_StdReq_Handler(); //标准请求中断服务函数           
   \   0000003A   0x.... 0x....      BL       USB_StdReq_Handler
    330                    }
    331                    tBDTtable[bEP0OUT_ODD].Stat._byte= kUDATA0;
   \                     ??USB_Setup_Handler_4:
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   00000042   0x2188             MOVS     R1,#+136
   \   00000044   0x7001             STRB     R1,[R0, #+0]
    332                    break;        
   \   00000046   0xE017             B.N      ??USB_Setup_Handler_5
    333            
    334                case INTERFACE_REQ://如果是接口请求形式
    335                    u8State = USB_InterfaceReq_Handler(); //当前接口请求为CDC类请求   
   \                     ??USB_Setup_Handler_2:
   \   00000048   0x.... 0x....      BL       CDC_InterfaceReq_Handler
    336            
    337                    if(u8State==uSETUP)
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD104             BNE.N    ??USB_Setup_Handler_6
    338                        tBDTtable[bEP0OUT_ODD].Stat._byte= kUDATA0;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   00000056   0x2188             MOVS     R1,#+136
   \   00000058   0x7001             STRB     R1,[R0, #+0]
   \   0000005A   0xE003             B.N      ??USB_Setup_Handler_7
    339                    else
    340                        tBDTtable[bEP0OUT_ODD].Stat._byte= kUDATA1;            
   \                     ??USB_Setup_Handler_6:
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   00000060   0x21C8             MOVS     R1,#+200
   \   00000062   0x7001             STRB     R1,[R0, #+0]
    341                    break;        
   \                     ??USB_Setup_Handler_7:
   \   00000064   0xE008             B.N      ??USB_Setup_Handler_5
    342            
    343                case ENDPOINT_REQ://如果是端点请求
    344                    USB_Endpoint_Setup_Handler();
   \                     ??USB_Setup_Handler_1:
   \   00000066   0x.... 0x....      BL       USB_Endpoint_Setup_Handler
    345                    tBDTtable[bEP0OUT_ODD].Stat._byte= kUDATA0;
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   0000006E   0x2188             MOVS     R1,#+136
   \   00000070   0x7001             STRB     R1,[R0, #+0]
    346                    break;        
   \   00000072   0xE001             B.N      ??USB_Setup_Handler_5
    347            
    348                default:
    349                    USB_EP0_Stall();  //stall请求
   \                     ??USB_Setup_Handler_3:
   \   00000074   0x.... 0x....      BL       USB_EP0_Stall
    350                    break;        
    351            }
    352            FLAG_CLR(USB_CTL_TXSUSPENDTOKENBUSY_SHIFT,USB0_CTL);
   \                     ??USB_Setup_Handler_5:
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable14_24  ;; 0x40072094
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable14_24  ;; 0x40072094
   \   00000086   0x7008             STRB     R0,[R1, #+0]
    353          }
   \   00000088   0xBD01             POP      {R0,PC}          ;; return
    354          
    355          
    356          /*
    357          * USB_Endpoint_Setup_Handler
    358          *   USB端点Setup中断处理函数
    359          *
    360          */

   \                                 In section .text, align 2, keep-with-next
    361          void USB_Endpoint_Setup_Handler(void)
    362          {
   \                     USB_Endpoint_Setup_Handler:
   \   00000000   0xB580             PUSH     {R7,LR}
    363            UINT16 u16Status;
    364            switch(Setup_Pkt->bRequest)
   \   00000002   0x....             LDR.N    R0,??DataTable14_5
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x7840             LDRB     R0,[R0, #+1]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD004             BEQ.N    ??USB_Endpoint_Setup_Handler_0
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD01B             BEQ.N    ??USB_Endpoint_Setup_Handler_1
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xD02A             BEQ.N    ??USB_Endpoint_Setup_Handler_2
   \   00000014   0xE03A             B.N      ??USB_Endpoint_Setup_Handler_3
    365            {        
    366              case GET_STATUS: //获取当前状态
    367                  if(FLAG_CHK(Setup_Pkt->wIndex_h,gu8HALT_EP))//判断gu8HALT_EP端点HALT是否为1
   \                     ??USB_Endpoint_Setup_Handler_0:
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable14_25
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x....             LDR.N    R2,??DataTable14_5
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0xF992 0x2005      LDRSB    R2,[R2, #+5]
   \   00000026   0x4091             LSLS     R1,R1,R2
   \   00000028   0x4208             TST      R0,R1
   \   0000002A   0xD004             BEQ.N    ??USB_Endpoint_Setup_Handler_4
    368                      u16Status=0x0100;
   \   0000002C   0xF44F 0x7080      MOV      R0,#+256
   \   00000030   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000034   0xE002             B.N      ??USB_Endpoint_Setup_Handler_5
    369                  else
    370                      u16Status=0x0000;
   \                     ??USB_Endpoint_Setup_Handler_4:
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    371                  
    372                  EP_IN_Transfer(EP0,(UINT8*)&u16Status,2); //通过端点0向PC发送状态
   \                     ??USB_Endpoint_Setup_Handler_5:
   \   0000003C   0x2202             MOVS     R2,#+2
   \   0000003E   0xA900             ADD      R1,SP,#+0
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      BL       EP_IN_Transfer
    373                  break;
   \   00000046   0xE021             B.N      ??USB_Endpoint_Setup_Handler_6
    374              
    375              case CLEAR_FEATURE:
    376                  FLAG_CLR(Setup_Pkt->wIndex_h,gu8HALT_EP); //gu8HALT_EP = 0
   \                     ??USB_Endpoint_Setup_Handler_1:
   \   00000048   0x....             LDR.N    R0,??DataTable14_25
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x....             LDR.N    R2,??DataTable14_5
   \   00000050   0x6812             LDR      R2,[R2, #+0]
   \   00000052   0xF992 0x2005      LDRSB    R2,[R2, #+5]
   \   00000056   0x4091             LSLS     R1,R1,R2
   \   00000058   0x4388             BICS     R0,R0,R1
   \   0000005A   0x....             LDR.N    R1,??DataTable14_25
   \   0000005C   0x7008             STRB     R0,[R1, #+0]
    377                  EP_IN_Transfer(EP0,0,0);
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      BL       EP_IN_Transfer
    378                  break;
   \   00000068   0xE010             B.N      ??USB_Endpoint_Setup_Handler_6
    379              
    380              case SET_FEATURE:
    381                  FLAG_SET(Setup_Pkt->wIndex_h,gu8HALT_EP); //gu8HALT_EP = 1
   \                     ??USB_Endpoint_Setup_Handler_2:
   \   0000006A   0x....             LDR.N    R0,??DataTable14_25
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x2101             MOVS     R1,#+1
   \   00000070   0x....             LDR.N    R2,??DataTable14_5
   \   00000072   0x6812             LDR      R2,[R2, #+0]
   \   00000074   0xF992 0x2005      LDRSB    R2,[R2, #+5]
   \   00000078   0x4091             LSLS     R1,R1,R2
   \   0000007A   0x4308             ORRS     R0,R1,R0
   \   0000007C   0x....             LDR.N    R1,??DataTable14_25
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
    382                  EP_IN_Transfer(EP0,0,0);
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x.... 0x....      BL       EP_IN_Transfer
    383                  break;
   \   0000008A   0xE7FF             B.N      ??USB_Endpoint_Setup_Handler_6
    384              
    385              default:
    386                  break;
    387            }
    388          }
   \                     ??USB_Endpoint_Setup_Handler_3:
   \                     ??USB_Endpoint_Setup_Handler_6:
   \   0000008C   0xBD01             POP      {R0,PC}          ;; return
    389          
    390          
    391          /*
    392          * USB_Handler
    393          *  USB令牌中断服务函数
    394          *
    395          */

   \                                 In section .text, align 2, keep-with-next
    396          void USB_Handler(void)
    397          {
   \                     USB_Handler:
   \   00000000   0xB580             PUSH     {R7,LR}
    398            UINT8 u8EndPoint;
    399            UINT8 u8IN;
    400            
    401            u8IN = USB0_STAT & 0x08;    //获得当前的传输状态，1发送；0接收
   \   00000002   0x....             LDR.N    R0,??DataTable14_26  ;; 0x40072090
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x0108      ANDS     R1,R0,#0x8
    402            u8EndPoint = USB0_STAT >> 4;//获得当前接收令牌的端点地址
   \   0000000A   0x....             LDR.N    R0,??DataTable14_26  ;; 0x40072090
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x0900             LSRS     R0,R0,#+4
    403            
    404            //端点发送PC接收模式表示有目标设备发送到PC上
    405            //端点接收PC发送模式表示PC发送目标设备接收
    406            
    407            /* Data EndPoints */
    408            if(u8EndPoint) //如果非零表示是数据端点，因为端点0作为控制端点
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD018             BEQ.N    ??USB_Handler_0
    409            {
    410              if(!u8IN)    //如果是端点接收模式
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD127             BNE.N    ??USB_Handler_1
    411              {
    412                usbMCU_CONTROL(u8EndPoint);         //转换成单片机访问BDT
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x0081             LSLS     R1,R0,#+2
   \   00000022   0x....             LDR.N    R2,??DataTable14_7
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0xF802 0x3031      STRB     R3,[R2, R1, LSL #+3]
    413                FLAG_SET(u8EndPoint,gu8USB_Flags);  //设置 gu8USB_Flags = 1   
   \   0000002A   0x....             LDR.N    R1,??DataTable14_27
   \   0000002C   0x7809             LDRB     R1,[R1, #+0]
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0xFA12 0xF000      LSLS     R0,R2,R0
   \   00000034   0x4308             ORRS     R0,R0,R1
   \   00000036   0x....             LDR.N    R1,??DataTable14_27
   \   00000038   0x7008             STRB     R0,[R1, #+0]
    414          
    415                if(usb_rev_data_isr !=(USB_REV_CALLBACK)0)
   \   0000003A   0x....             LDR.N    R0,??DataTable14
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD015             BEQ.N    ??USB_Handler_1
    416                  usb_rev_data_isr();      
   \   00000042   0x....             LDR.N    R0,??DataTable14
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x4780             BLX      R0
   \   00000048   0xE011             B.N      ??USB_Handler_1
    417              }
    418            }
    419            /* Control EndPoint */
    420            else       //如果是端点0，端点0作为控制端点
    421            {
    422              if(u8IN)    //如果是端点发送PC接收
   \                     ??USB_Handler_0:
   \   0000004A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004C   0x2900             CMP      R1,#+0
   \   0000004E   0xD002             BEQ.N    ??USB_Handler_2
    423              {
    424                USB_EP0_IN_Handler();  
   \   00000050   0x.... 0x....      BL       USB_EP0_IN_Handler
   \   00000054   0xE00B             B.N      ??USB_Handler_1
    425              }
    426              else       //如果是端点接收PC发送模式
    427              {
    428                if(tBDTtable[bEP0OUT_ODD].Stat.RecPid.PID == mSETUP_TOKEN) //如果接收的是启动令牌
   \                     ??USB_Handler_2:
   \   00000056   0x....             LDR.N    R0,??DataTable14_7
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0xF3C0 0x0083      UBFX     R0,R0,#+2,#+4
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x280D             CMP      R0,#+13
   \   00000062   0xD102             BNE.N    ??USB_Handler_3
    429                    USB_Setup_Handler();
   \   00000064   0x.... 0x....      BL       USB_Setup_Handler
   \   00000068   0xE001             B.N      ??USB_Handler_1
    430                else     //如果接收的不是启动令牌
    431                    USB_EP0_OUT_Handler();
   \                     ??USB_Handler_3:
   \   0000006A   0x.... 0x....      BL       USB_EP0_OUT_Handler
    432              }
    433            }
    434          }
   \                     ??USB_Handler_1:
   \   0000006E   0xBD01             POP      {R0,PC}          ;; return
    435          
    436          
    437          /*
    438          * USB_EP0_IN_Handler
    439          *   端点0发送PC接收模式中断服务函数，此时端点0是控制端点，
    440          *
    441          */

   \                                 In section .text, align 2, keep-with-next
    442          void USB_EP0_IN_Handler(void)
    443          {
   \                     USB_EP0_IN_Handler:
   \   00000000   0xB580             PUSH     {R7,LR}
    444            if(gu8USB_State == uADDRESS)        //如果当前USB处于地址状态
   \   00000002   0x....             LDR.N    R0,??DataTable14_18
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xD10D             BNE.N    ??USB_EP0_IN_Handler_0
    445            {
    446              USB0_ADDR = Setup_Pkt->wValue_l; //将Setup_Pkt的值给USB地址寄存器
   \   0000000A   0x....             LDR.N    R0,??DataTable14_5
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x7880             LDRB     R0,[R0, #+2]
   \   00000010   0x....             LDR.N    R1,??DataTable14_28  ;; 0x40072098
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    447              gu8USB_State = uREADY;           //改变当前USB状态
   \   00000014   0x....             LDR.N    R0,??DataTable14_18
   \   00000016   0x2104             MOVS     R1,#+4
   \   00000018   0x7001             STRB     R1,[R0, #+0]
    448              FLAG_SET(fIN,gu8USBClearFlags);  //将gu8USBClearFlags设置为1
   \   0000001A   0x....             LDR.N    R0,??DataTable14_2
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000022   0x....             LDR.N    R1,??DataTable14_2
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    449            }
    450            EP_IN_Transfer(0,0,0);             //端点0开始传输
   \                     ??USB_EP0_IN_Handler_0:
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       EP_IN_Transfer
    451          }
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
    452          
    453          
    454          /*
    455          * USB_EP0_Stall
    456          *   端点0 stall停止处理
    457          *
    458          */

   \                                 In section .text, align 2, keep-with-next
    459          void USB_EP0_Stall(void)
    460          {
    461            FLAG_SET(USB_ENDPT_EPSTALL_SHIFT,USB0_ENDPT0);  // USB0_ENDPT0的 STALL =1                
   \                     USB_EP0_Stall:
   \   00000000   0x....             LDR.N    R0,??DataTable14_29  ;; 0x400720c0
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000008   0x....             LDR.N    R1,??DataTable14_29  ;; 0x400720c0
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    462            tBDTtable[bEP0OUT_ODD].Stat._byte = kUDATA0;    // USB-FS 有专有权访问 BD
   \   0000000C   0x....             LDR.N    R0,??DataTable14_7
   \   0000000E   0x2188             MOVS     R1,#+136
   \   00000010   0x7001             STRB     R1,[R0, #+0]
    463                                                            //使能USB-FS去扮演数据翻转同步
    464                                                            //定义DATA1允许发送或者接收 
    465            tBDTtable[bEP0OUT_ODD].Cnt = EP0_SIZE;          //设置EP0的长度32字节
   \   00000012   0x....             LDR.N    R0,??DataTable14_7
   \   00000014   0x2140             MOVS     R1,#+64
   \   00000016   0x8041             STRH     R1,[R0, #+2]
    466          }
   \   00000018   0x4770             BX       LR               ;; return
    467          
    468          
    469          /*
    470          * USB_EP0_OUT_Handler
    471          *   端点0接收PC接收数据中断服务函数
    472          *
    473          */

   \                                 In section .text, align 2, keep-with-next
    474          void USB_EP0_OUT_Handler(void)
    475          {   
    476            FLAG_SET(0,gu8USB_Flags);   //将EP0的gu8USB_Flags置1
   \                     USB_EP0_OUT_Handler:
   \   00000000   0x....             LDR.N    R0,??DataTable14_27
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000008   0x....             LDR.N    R1,??DataTable14_27
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    477            tBDTtable[bEP0OUT_ODD].Stat._byte = kUDATA0;   //USB-FS 有专有权访问 BD
   \   0000000C   0x....             LDR.N    R0,??DataTable14_7
   \   0000000E   0x2188             MOVS     R1,#+136
   \   00000010   0x7001             STRB     R1,[R0, #+0]
    478                                                           //使能USB-FS去扮演数据翻转同步
    479                                                           //定义DATA1允许发送或者接收  
    480          }
   \   00000012   0x4770             BX       LR               ;; return
    481          
    482          
    483          /*
    484          *   USB_Stall_Handler
    485          *     如果USB工作在Device模式，如果获得stall证明表明其不能完成传输。
    486          */

   \                                 In section .text, align 2, keep-with-next
    487          void USB_Stall_Handler(void) 
    488          {
    489            if(FLAG_CHK(USB_ENDPT_EPSTALL_SHIFT,USB0_ENDPT0)) //检查USB的端点0的stall位是否置位
   \                     USB_Stall_Handler:
   \   00000000   0x....             LDR.N    R0,??DataTable14_29  ;; 0x400720c0
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x0780             LSLS     R0,R0,#+30
   \   00000006   0xD505             BPL.N    ??USB_Stall_Handler_0
    490                FLAG_CLR(USB_ENDPT_EPSTALL_SHIFT,USB0_ENDPT0);//清空端点0的stall位
   \   00000008   0x....             LDR.N    R0,??DataTable14_29  ;; 0x400720c0
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   00000010   0x....             LDR.N    R1,??DataTable14_29  ;; 0x400720c0
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    491            FLAG_SET(USB_ISTAT_STALL_SHIFT,USB0_ISTAT);       //清空全局状态寄存器中的Stall位
   \                     ??USB_Stall_Handler_0:
   \   00000014   0x....             LDR.N    R0,??DataTable14_30  ;; 0x40072080
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000001C   0x....             LDR.N    R1,??DataTable14_30  ;; 0x40072080
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    492          }
   \   00000020   0x4770             BX       LR               ;; return
    493          
    494          
    495          /*
    496          *   USB_Reset_Handler
    497          *     USB复位中断服务函数,在该函数中进行设置软件标志位、
    498          *   禁止所有EP(端点寄存器)，同时将EP0初始为控制端点
    499          *   并对EP0的输入、输出奇偶缓冲进行初始化，
    500          *   开启USB令牌中断、USB第一帧传输中断、USB错误中断、USB复位中断
    501          */

   \                                 In section .text, align 2, keep-with-next
    502          void USB_Reset_Handler(void)
    503          {
    504            /*设置软件标志位*/
    505            gu8USBClearFlags=0xFF;
   \                     USB_Reset_Handler:
   \   00000000   0x....             LDR.N    R0,??DataTable14_2
   \   00000002   0x21FF             MOVS     R1,#+255
   \   00000004   0x7001             STRB     R1,[R0, #+0]
    506            gu8USB_Toogle_flags=0xFE;
   \   00000006   0x....             LDR.N    R0,??DataTable14_8
   \   00000008   0x21FE             MOVS     R1,#+254
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    507            
    508            /*禁止所有EP寄存器*/
    509            USB0_ENDPT1=0x00;
   \   0000000C   0x....             LDR.N    R0,??DataTable14_9  ;; 0x400720c4
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7001             STRB     R1,[R0, #+0]
    510            USB0_ENDPT2=0x00;
   \   00000012   0x....             LDR.N    R0,??DataTable14_10  ;; 0x400720c8
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7001             STRB     R1,[R0, #+0]
    511            USB0_ENDPT3=0x00;
   \   00000018   0x....             LDR.N    R0,??DataTable14_11  ;; 0x400720cc
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x7001             STRB     R1,[R0, #+0]
    512            USB0_ENDPT4=0x00;
   \   0000001E   0x....             LDR.N    R0,??DataTable14_12  ;; 0x400720d0
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x7001             STRB     R1,[R0, #+0]
    513            USB0_ENDPT5=0x00;
   \   00000024   0x....             LDR.N    R0,??DataTable14_13  ;; 0x400720d4
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    514            USB0_ENDPT6=0x00;
   \   0000002A   0x....             LDR.N    R0,??DataTable14_14  ;; 0x400720d8
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x7001             STRB     R1,[R0, #+0]
    515          
    516            /*端点0 BDT 启动端点设置*/
    517            tBDTtable[bEP0OUT_ODD].Cnt = EP0_SIZE;   // EP0 OUT BDT 设置
   \   00000030   0x....             LDR.N    R0,??DataTable14_7
   \   00000032   0x2140             MOVS     R1,#+64
   \   00000034   0x8041             STRH     R1,[R0, #+2]
    518            tBDTtable[bEP0OUT_ODD].Addr =(UINT32)gu8EP0_OUT_ODD_Buffer;
   \   00000036   0x....             LDR.N    R0,??DataTable14_7
   \   00000038   0x....             LDR.N    R1,??DataTable14_31
   \   0000003A   0x6041             STR      R1,[R0, #+4]
    519            tBDTtable[bEP0OUT_ODD].Stat._byte = kUDATA1;//USB-FS 有专有权访问 BD
   \   0000003C   0x....             LDR.N    R0,??DataTable14_7
   \   0000003E   0x21C8             MOVS     R1,#+200
   \   00000040   0x7001             STRB     R1,[R0, #+0]
    520                                                        //使能USB-FS去扮演数据翻转同步
    521                                                        //定义DATA1允许发送或者接收        
    522             
    523            tBDTtable[bEP0OUT_EVEN].Cnt = EP0_SIZE; // EP0 OUT BDT 设置
   \   00000042   0x....             LDR.N    R0,??DataTable14_7
   \   00000044   0x2140             MOVS     R1,#+64
   \   00000046   0x8141             STRH     R1,[R0, #+10]
    524            tBDTtable[bEP0OUT_EVEN].Addr =(UINT32)gu8EP0_OUT_EVEN_Buffer;
   \   00000048   0x....             LDR.N    R0,??DataTable14_7
   \   0000004A   0x....             LDR.N    R1,??DataTable14_32
   \   0000004C   0x60C1             STR      R1,[R0, #+12]
    525            tBDTtable[bEP0OUT_EVEN].Stat._byte = kUDATA1;//USB-FS 有专有权访问 BD
   \   0000004E   0x....             LDR.N    R0,??DataTable14_7
   \   00000050   0x21C8             MOVS     R1,#+200
   \   00000052   0x7201             STRB     R1,[R0, #+8]
    526                                                         //使能USB-FS去扮演数据翻转同步
    527                                                         //定义DATA1允许发送或者接收       
    528             
    529            tBDTtable[bEP0IN_ODD].Cnt = EP0_SIZE;   // EP0 IN BDT 设置     
   \   00000054   0x....             LDR.N    R0,??DataTable14_7
   \   00000056   0x2140             MOVS     R1,#+64
   \   00000058   0x8241             STRH     R1,[R0, #+18]
    530            tBDTtable[bEP0IN_ODD].Addr =(UINT32)gu8EP0_IN_ODD_Buffer;      
   \   0000005A   0x....             LDR.N    R0,??DataTable14_7
   \   0000005C   0x....             LDR.N    R1,??DataTable14_33
   \   0000005E   0x6141             STR      R1,[R0, #+20]
    531            tBDTtable[bEP0IN_ODD].Stat._byte = kUDATA0;//USB-FS 有专有权访问 BD
   \   00000060   0x....             LDR.N    R0,??DataTable14_7
   \   00000062   0x2188             MOVS     R1,#+136
   \   00000064   0x7401             STRB     R1,[R0, #+16]
    532                                                       //使能USB-FS去扮演数据翻转同步
    533                                                       //定义DATA0允许发送或者接收 
    534             
    535            tBDTtable[bEP0IN_EVEN].Cnt = EP0_SIZE;  // EP0 IN BDT 设置            
   \   00000066   0x....             LDR.N    R0,??DataTable14_7
   \   00000068   0x2140             MOVS     R1,#+64
   \   0000006A   0x8341             STRH     R1,[R0, #+26]
    536            tBDTtable[bEP0IN_EVEN].Addr =(UINT32)gu8EP0_IN_EVEN_Buffer;      
   \   0000006C   0x....             LDR.N    R0,??DataTable14_7
   \   0000006E   0x....             LDR.N    R1,??DataTable14_34
   \   00000070   0x61C1             STR      R1,[R0, #+28]
    537            tBDTtable[bEP0IN_EVEN].Stat._byte = kUDATA0;//USB-FS 有专有权访问 BD
   \   00000072   0x....             LDR.N    R0,??DataTable14_7
   \   00000074   0x2188             MOVS     R1,#+136
   \   00000076   0x7601             STRB     R1,[R0, #+24]
    538                                                        //使能USB-FS去扮演数据翻转同步
    539                                                        //定义DATA0允许发送或者接收        
    540            
    541            USB0_ENDPT0=0x0D; //使能端点0
   \   00000078   0x....             LDR.N    R0,??DataTable14_29  ;; 0x400720c0
   \   0000007A   0x210D             MOVS     R1,#+13
   \   0000007C   0x7001             STRB     R1,[R0, #+0]
    542            
    543            USB0_ERRSTAT=0xFF;//清空所有错误标志位
   \   0000007E   0x....             LDR.N    R0,??DataTable14_35  ;; 0x40072088
   \   00000080   0x21FF             MOVS     R1,#+255
   \   00000082   0x7001             STRB     R1,[R0, #+0]
    544            
    545            USB0_ISTAT=0xFF;  //清空所有USB中断标志位
   \   00000084   0x....             LDR.N    R0,??DataTable14_30  ;; 0x40072080
   \   00000086   0x21FF             MOVS     R1,#+255
   \   00000088   0x7001             STRB     R1,[R0, #+0]
    546          
    547            USB0_ADDR=0x00;   // 设置USB缺省定值为0
   \   0000008A   0x....             LDR.N    R0,??DataTable14_28  ;; 0x40072098
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x7001             STRB     R1,[R0, #+0]
    548          
    549            USB0_ERREN=0xFF;  // 使能所有错误中断源
   \   00000090   0x....             LDR.N    R0,??DataTable14_36  ;; 0x4007208c
   \   00000092   0x21FF             MOVS     R1,#+255
   \   00000094   0x7001             STRB     R1,[R0, #+0]
    550          
    551            /*使能USB中断*/
    552            FLAG_SET(USB_INTEN_TOKDNEEN_SHIFT,USB0_INTEN);  //使能USB TOKDNE中断 
   \   00000096   0x....             LDR.N    R0,??DataTable14_37  ;; 0x40072084
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000009E   0x....             LDR.N    R1,??DataTable14_37  ;; 0x40072084
   \   000000A0   0x7008             STRB     R0,[R1, #+0]
    553            FLAG_SET(USB_INTEN_SOFTOKEN_SHIFT,USB0_INTEN);  //使能USB SOFTOK中断 
   \   000000A2   0x....             LDR.N    R0,??DataTable14_37  ;; 0x40072084
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000AA   0x....             LDR.N    R1,??DataTable14_37  ;; 0x40072084
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
    554            FLAG_SET(USB_INTEN_ERROREN_SHIFT,USB0_INTEN);   //使能USB错误中断 
   \   000000AE   0x....             LDR.N    R0,??DataTable14_37  ;; 0x40072084
   \   000000B0   0x7800             LDRB     R0,[R0, #+0]
   \   000000B2   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000B6   0x....             LDR.N    R1,??DataTable14_37  ;; 0x40072084
   \   000000B8   0x7008             STRB     R0,[R1, #+0]
    555            FLAG_SET(USB_INTEN_USBRSTEN_SHIFT,USB0_INTEN);  //使能USB复位中断  
   \   000000BA   0x....             LDR.N    R0,??DataTable14_37  ;; 0x40072084
   \   000000BC   0x7800             LDRB     R0,[R0, #+0]
   \   000000BE   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000C2   0x....             LDR.N    R1,??DataTable14_37  ;; 0x40072084
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
    556          }
   \   000000C6   0x4770             BX       LR               ;; return
    557          
    558          
    559          /*
    560          * USB_Protocol_Handler
    561          *   USB协议中断服务函数
    562          *      在该函数中调用USB的底层协议
    563          */

   \                                 In section .text, align 4, keep-with-next
    564          void USB_Protocol_Handler(void)
    565          {
   \                     USB_Protocol_Handler:
   \   00000000   0xB580             PUSH     {R7,LR}
    566            uint8 err;
    567            FLAG_SET(1,GPIOC_PDOR);
   \   00000002   0x....             LDR.N    R0,??DataTable14_38  ;; 0x400ff080
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000000A   0x....             LDR.N    R1,??DataTable14_38  ;; 0x400ff080
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    568            /*USB 程序初始化后会首先进入复位中断 */
    569            if(FLAG_CHK(USB_ISTAT_USBRST_SHIFT,USB0_ISTAT))//产生USB复位中断
   \   0000000E   0x....             LDR.N    R0,??DataTable14_30  ;; 0x40072080
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x07C0             LSLS     R0,R0,#+31
   \   00000014   0xD502             BPL.N    ??USB_Protocol_Handler_0
    570            { 
    571              USB_Reset_Handler();                         //进入USB复位中断服务函数
   \   00000016   0x.... 0x....      BL       USB_Reset_Handler
    572              return;
   \   0000001A   0xE037             B.N      ??USB_Protocol_Handler_1
    573            }
    574            if(FLAG_CHK(USB_ISTAT_SOFTOK_SHIFT,USB0_ISTAT))//产生USB SOFTOK中断
   \                     ??USB_Protocol_Handler_0:
   \   0000001C   0x....             LDR.N    R0,??DataTable14_30  ;; 0x40072080
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x0740             LSLS     R0,R0,#+29
   \   00000022   0xD502             BPL.N    ??USB_Protocol_Handler_2
    575            {
    576              USB0_ISTAT = USB_ISTAT_SOFTOK_MASK;          //清空SOFTOK标志位
   \   00000024   0x....             LDR.N    R0,??DataTable14_30  ;; 0x40072080
   \   00000026   0x2104             MOVS     R1,#+4
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    577            }
    578            if(FLAG_CHK(USB_ISTAT_STALL_SHIFT,USB0_ISTAT)) //接收USB停止包数据处理
   \                     ??USB_Protocol_Handler_2:
   \   0000002A   0x....             LDR.N    R0,??DataTable14_30  ;; 0x40072080
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x0600             LSLS     R0,R0,#+24
   \   00000030   0xD501             BPL.N    ??USB_Protocol_Handler_3
    579            {
    580              USB_Stall_Handler();                         //进入Stall中断服务函数
   \   00000032   0x.... 0x....      BL       USB_Stall_Handler
    581            }
    582            if(FLAG_CHK(USB_ISTAT_TOKDNE_SHIFT,USB0_ISTAT))//产生USB令牌中断
   \                     ??USB_Protocol_Handler_3:
   \   00000036   0x....             LDR.N    R0,??DataTable14_30  ;; 0x40072080
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x0700             LSLS     R0,R0,#+28
   \   0000003C   0xD50D             BPL.N    ??USB_Protocol_Handler_4
    583            {
    584              FLAG_SET(USB_CTL_ODDRST_SHIFT,USB0_CTL);     //复位所有BDT ODD，然后可以配置EVEN BDT
   \   0000003E   0x....             LDR.N    R0,??DataTable14_24  ;; 0x40072094
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000046   0x....             LDR.N    R1,??DataTable14_24  ;; 0x40072094
   \   00000048   0x7008             STRB     R0,[R1, #+0]
    585              USB_Handler();
   \   0000004A   0x.... 0x....      BL       USB_Handler
    586              FLAG_SET(USB_ISTAT_TOKDNE_SHIFT,USB0_ISTAT); //清零USB令牌标志位
   \   0000004E   0x....             LDR.N    R0,??DataTable14_30  ;; 0x40072080
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000056   0x....             LDR.N    R1,??DataTable14_30  ;; 0x40072080
   \   00000058   0x7008             STRB     R0,[R1, #+0]
    587            }
    588            if(FLAG_CHK(USB_ISTAT_SLEEP_SHIFT,USB0_ISTAT)) 
   \                     ??USB_Protocol_Handler_4:
   \   0000005A   0x....             LDR.N    R0,??DataTable14_30  ;; 0x40072080
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x06C0             LSLS     R0,R0,#+27
   \   00000060   0xD505             BPL.N    ??USB_Protocol_Handler_5
    589            {
    590              FLAG_SET(USB_ISTAT_SLEEP_SHIFT,USB0_ISTAT);   
   \   00000062   0x....             LDR.N    R0,??DataTable14_30  ;; 0x40072080
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000006A   0x....             LDR.N    R1,??DataTable14_30  ;; 0x40072080
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
    591            }
    592            if(FLAG_CHK(USB_ISTAT_ERROR_SHIFT,USB0_ISTAT)) 
   \                     ??USB_Protocol_Handler_5:
   \   0000006E   0x....             LDR.N    R0,??DataTable14_30  ;; 0x40072080
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x0780             LSLS     R0,R0,#+30
   \   00000074   0xD50A             BPL.N    ??USB_Protocol_Handler_6
    593            {
    594              err = USB0_ERRSTAT;
   \   00000076   0x....             LDR.N    R0,??DataTable14_35  ;; 0x40072088
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
    595              if(err==0)
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD100             BNE.N    ??USB_Protocol_Handler_7
    596                asm("nop");
   \   00000080   0xBF00             nop              
    597              FLAG_CHK(USB_ISTAT_ERROR_SHIFT,USB0_ISTAT);
   \                     ??USB_Protocol_Handler_7:
   \   00000082   0x....             LDR.N    R0,??DataTable14_30  ;; 0x40072080
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0xF010 0x0002      ANDS     R0,R0,#0x2
    598            }
    599          }
   \                     ??USB_Protocol_Handler_6:
   \                     ??USB_Protocol_Handler_1:
   \   0000008C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     usb_rev_data_isr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     BufferPointer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     gu8USBClearFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     pu8IN_DataPointer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     gu8IN_Counter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     Setup_Pkt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x........         DC32     cEP_Size

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x........         DC32     tBDTtable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x........         DC32     gu8USB_Toogle_flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x400720C4         DC32     0x400720c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x400720C8         DC32     0x400720c8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x400720CC         DC32     0x400720cc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \   00000000   0x400720D0         DC32     0x400720d0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \   00000000   0x400720D4         DC32     0x400720d4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \   00000000   0x400720D8         DC32     0x400720d8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \   00000000   0x........         DC32     gu8EP1_IN_ODD_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \   00000000   0x........         DC32     gu8EP2_IN_ODD_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_17:
   \   00000000   0x........         DC32     gu8EP3_OUT_ODD_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_18:
   \   00000000   0x........         DC32     gu8USB_State

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_19:
   \   00000000   0x........         DC32     Device_Descriptor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_20:
   \   00000000   0x........         DC32     Configuration_Descriptor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_21:
   \   00000000   0x........         DC32     String_Table

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_22:
   \   00000000   0x........         DC32     gu8Dummy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_23:
   \   00000000   0x........         DC32     gu8Status

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_24:
   \   00000000   0x40072094         DC32     0x40072094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_25:
   \   00000000   0x........         DC32     gu8HALT_EP

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_26:
   \   00000000   0x40072090         DC32     0x40072090

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_27:
   \   00000000   0x........         DC32     gu8USB_Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_28:
   \   00000000   0x40072098         DC32     0x40072098

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_29:
   \   00000000   0x400720C0         DC32     0x400720c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_30:
   \   00000000   0x40072080         DC32     0x40072080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_31:
   \   00000000   0x........         DC32     gu8EP0_OUT_ODD_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_32:
   \   00000000   0x........         DC32     gu8EP0_OUT_EVEN_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_33:
   \   00000000   0x........         DC32     gu8EP0_IN_ODD_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_34:
   \   00000000   0x........         DC32     gu8EP0_IN_EVEN_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_35:
   \   00000000   0x40072088         DC32     0x40072088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_36:
   \   00000000   0x4007208C         DC32     0x4007208c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_37:
   \   00000000   0x40072084         DC32     0x40072084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_38:
   \   00000000   0x400FF080         DC32     0x400ff080
    600          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  EP_IN_Transfer
        4  EP_OUT_Transfer
        8  USB_EP0_IN_Handler
             8 -> EP_IN_Transfer
        0  USB_EP0_OUT_Handler
        0  USB_EP0_Stall
        0  USB_EP_OUT_SizeCheck
        8  USB_Endpoint_Setup_Handler
             8 -> EP_IN_Transfer
        8  USB_Handler
             8 -- Indirect call
             8 -> USB_EP0_IN_Handler
             8 -> USB_EP0_OUT_Handler
             8 -> USB_Setup_Handler
        8  USB_Protocol_Handler
             8 -> USB_Handler
             8 -> USB_Reset_Handler
             8 -> USB_Stall_Handler
        0  USB_Reset_Handler
        0  USB_Rev_SetIsr
        0  USB_Set_Interface
        8  USB_Setup_Handler
             8 -> CDC_InterfaceReq_Handler
             8 -> USB_EP0_Stall
             8 -> USB_Endpoint_Setup_Handler
             8 -> USB_StdReq_Handler
        0  USB_Stall_Handler
        8  USB_StdReq_Handler
             8 -> EP_IN_Transfer
             8 -> USB_EP0_Stall
             8 -> USB_Set_Interface


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_17
       4  ??DataTable14_18
       4  ??DataTable14_19
       4  ??DataTable14_2
       4  ??DataTable14_20
       4  ??DataTable14_21
       4  ??DataTable14_22
       4  ??DataTable14_23
       4  ??DataTable14_24
       4  ??DataTable14_25
       4  ??DataTable14_26
       4  ??DataTable14_27
       4  ??DataTable14_28
       4  ??DataTable14_29
       4  ??DataTable14_3
       4  ??DataTable14_30
       4  ??DataTable14_31
       4  ??DataTable14_32
       4  ??DataTable14_33
       4  ??DataTable14_34
       4  ??DataTable14_35
       4  ??DataTable14_36
       4  ??DataTable14_37
       4  ??DataTable14_38
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      64  BufferPointer
      68  Configuration_Descriptor
      20  Device_Descriptor
     326  EP_IN_Transfer
      54  EP_OUT_Transfer
       4  Setup_Pkt
       4  String_Descriptor0
      20  String_Descriptor1
      20  String_Descriptor2
      20  String_Descriptor3
      16  String_Table
      50  USB_EP0_IN_Handler
      20  USB_EP0_OUT_Handler
      26  USB_EP0_Stall
      20  USB_EP_OUT_SizeCheck
     142  USB_Endpoint_Setup_Handler
     112  USB_Handler
     142  USB_Protocol_Handler
     200  USB_Reset_Handler
       8  USB_Rev_SetIsr
     138  USB_Set_Interface
     138  USB_Setup_Handler
      34  USB_Stall_Handler
     264  USB_StdReq_Handler
      16  cEP_Size
       1  gu8Dummy
      64  gu8EP0_IN_EVEN_Buffer
      64  gu8EP0_IN_ODD_Buffer
      64  gu8EP0_OUT_EVEN_Buffer
      64  gu8EP0_OUT_ODD_Buffer
      64  gu8EP1_IN_EVEN_Buffer
      64  gu8EP1_IN_ODD_Buffer
      64  gu8EP1_OUT_EVEN_Buffer
      64  gu8EP1_OUT_ODD_Buffer
      64  gu8EP2_IN_EVEN_Buffer
      64  gu8EP2_IN_ODD_Buffer
      64  gu8EP2_OUT_EVEN_Buffer
      64  gu8EP2_OUT_ODD_Buffer
      64  gu8EP3_IN_EVEN_Buffer
      64  gu8EP3_IN_ODD_Buffer
      64  gu8EP3_OUT_EVEN_Buffer
      64  gu8EP3_OUT_ODD_Buffer
       1  gu8HALT_EP
       1  gu8IN_Counter
       1  gu8Interface
       2  gu8Status
       1  gu8USBClearFlags
       1  gu8USB_Flags
       1  gu8USB_State
       1  gu8USB_Toogle_flags
       4  pu8IN_DataPointer
     128  tBDTtable
       4  usb_rev_data_isr

 
 1 174 bytes in section .bss
    80 bytes in section .data
   168 bytes in section .rodata
 1 830 bytes in section .text
 
 1 830 bytes of CODE  memory
   168 bytes of CONST memory
 1 254 bytes of DATA  memory

Errors: none
Warnings: none
