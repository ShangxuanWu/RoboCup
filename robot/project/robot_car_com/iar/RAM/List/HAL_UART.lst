###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     25/Sep/2013  21:07:07 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\中国机器人大赛\robot_project\lib\LPLD\HAL_UART.c      #
#    Command line =  D:\中国机器人大赛\robot_project\lib\LPLD\HAL_UART.c -D   #
#                    IAR -D LPLD_K60 -lCN D:\中国机器人大赛\robot_project\pro #
#                    ject\LPLD_Template\iar\RAM\List\ -lB                     #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\RAM\List\ -o D:\中国机器人大赛\robot_project\project\L #
#                    PLD_Template\iar\RAM\Obj\ --no_cse --no_unroll           #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I D:\中国机器人大赛\robot_project\project\LPLD_T #
#                    emplate\iar\..\app\ -I D:\中国机器人大赛\robot_project\p #
#                    roject\LPLD_Template\iar\..\..\..\lib\common\ -I         #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\cpu\ -I D:\中国机器人大赛\robot_project\p #
#                    roject\LPLD_Template\iar\..\..\..\lib\cpu\headers\ -I    #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\adc16\ -I                         #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\enet\ -I                          #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\lptmr\ -I                         #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\mcg\ -I                           #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\pmc\ -I                           #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\rtc\ -I                           #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\uart\ -I                          #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\drivers\wdog\ -I                          #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\platforms\ -I                             #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\LPLD\ -I D:\中国机器人大赛\robot_project\ #
#                    project\LPLD_Template\iar\..\..\..\lib\LPLD\FatFs\ -I    #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\LPLD\USB\ -I                              #
#                    D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\..\..\..\lib\iar_config_files\ -Ol                     #
#    List file    =  D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\RAM\List\HAL_UART.lst                                  #
#    Object file  =  D:\中国机器人大赛\robot_project\project\LPLD_Template\ia #
#                    r\RAM\Obj\HAL_UART.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\中国机器人大赛\robot_project\lib\LPLD\HAL_UART.c
      1          /*
      2           * --------------"拉普兰德K60底层库"-----------------
      3           *
      4           * 测试硬件平台:LPLD_K60 Card
      5           * 版权所有:北京拉普兰德电子技术有限公司
      6           * 网络销售:http://laplenden.taobao.com
      7           * 公司门户:http://www.lpld.cn
      8           *
      9           * 文件名: HAL_UART.c
     10           * 用途: UART底层模块相关函数
     11           * 最后修改日期: 20120330
     12           *
     13           * 开发者使用协议:
     14           *  本代码面向所有使用者开放源代码，开发者可以随意修改源代码。但本段及以上注释应
     15           *  予以保留，不得更改或删除原版权所有者姓名。二次开发者可以加注二次版权所有者，
     16           *  但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     17          */
     18          /*
     19           *******需用到UART中断，请在isr.h中粘贴一下代码:*********
     20          
     21          //UART模块中断服务定义
     22          #undef  VECTOR_061
     23          #define VECTOR_061 LPLD_UART_Isr
     24          #undef  VECTOR_063
     25          #define VECTOR_063 LPLD_UART_Isr
     26          #undef  VECTOR_065
     27          #define VECTOR_065 LPLD_UART_Isr
     28          #undef  VECTOR_067
     29          #define VECTOR_067 LPLD_UART_Isr
     30          #undef  VECTOR_069
     31          #define VECTOR_069 LPLD_UART_Isr
     32          #undef  VECTOR_071
     33          #define VECTOR_071 LPLD_UART_Isr
     34          //以下函数在LPLD_Kinetis底层包，不必修改
     35          extern void LPLD_UART_Isr(void);
     36          
     37           ***********************代码结束*************************
     38          */
     39          
     40          #include "common.h"
     41          #include "HAL_UART.h"
     42          
     43          
     44          extern int core_clk_khz;          //系统主频时钟频率
     45          extern int periph_clk_khz;        //总线时钟频率
     46          
     47          

   \                                 In section .bss, align 4
     48          UART_ISR_CALLBACK UART_R_ISR[6];  //用户接收中断函数入口地址数组
   \                     UART_R_ISR:
   \   00000000                      DS8 24

   \                                 In section .bss, align 4
     49          UART_ISR_CALLBACK UART_T_ISR[6];  //用户发送中断函数入口地址数组
   \                     UART_T_ISR:
   \   00000000                      DS8 24
     50          
     51          //UART映射地址数组

   \                                 In section .data, align 4
     52          volatile UART_MemMapPtr UARTx_Ptr[6] = {UART0_BASE_PTR, 
   \                     UARTx_Ptr:
   \   00000000   0x4006A000         DC32 4006A000H, 4006B000H, 4006C000H, 4006D000H, 400EA000H, 400EB000H
   \              0x4006B000   
   \              0x4006C000   
   \              0x4006D000   
   \              0x400EA000   
   \              0x400EB000   
     53                                                  UART1_BASE_PTR, 
     54                                                  UART2_BASE_PTR, 
     55                                                  UART3_BASE_PTR, 
     56                                                  UART4_BASE_PTR, 
     57                                                  UART5_BASE_PTR};
     58          
     59          /*
     60           * LPLD_UART_Init
     61           * 初始化UART通道及其波特率
     62           * 
     63           * 参数:
     64           *    uartx--UART模块号
     65           *      |__UART0          --UART0  -Txd:PTB17 -Rxd:PTB16
     66           *      |__UART1          --UART1  -Txd:PTC4  -Rxd:PTC3
     67           *      |__UART2          --UART2  -Txd:PTD3  -Rxd:PTD2
     68           *      |__UART3          --UART3  -Txd:PTC17 -Rxd:PTC16
     69           *      |__UART4          --UART4  -Txd:PTC15 -Rxd:PTC14
     70           *      |__UART5          --UART5  -Txd:PTE8  -Rxd:PTE9
     71           *    baud--波特率，推荐设置以下常用波特率
     72           *      |__4800
     73           *      |__9600
     74           *      |__19200
     75           *      |__38400
     76           *      |__57600
     77           *      |__115200
     78           *
     79           * 输出:
     80           *    无
     81           *
     82           */

   \                                 In section .text, align 2, keep-with-next
     83          void LPLD_UART_Init(UARTx uartx, int baud)
     84          {
   \                     LPLD_UART_Init:
   \   00000000   0xB430             PUSH     {R4,R5}
     85            UART_MemMapPtr uartptr = UARTx_Ptr[uartx];
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x....             LDR.N    R2,??DataTable5
   \   00000006   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
     86            register uint16 sbr, brfa;
     87            int sysclk;
     88            uint8 temp;
     89            
     90            if ((uartptr == UART0_BASE_PTR) | (uartptr == UART1_BASE_PTR))
   \   0000000A   0x....             LDR.N    R2,??DataTable5_1  ;; 0x4006a000
   \   0000000C   0x4290             CMP      R0,R2
   \   0000000E   0xD008             BEQ.N    ??LPLD_UART_Init_0
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x....             LDR.N    R3,??DataTable5_2  ;; 0x4006b000
   \   00000014   0x4298             CMP      R0,R3
   \   00000016   0xD004             BEQ.N    ??LPLD_UART_Init_0
   \   00000018   0xF052 0x0200      ORRS     R2,R2,#0x0
   \   0000001C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD002             BEQ.N    ??LPLD_UART_Init_1
     91              sysclk = core_clk_khz;
   \                     ??LPLD_UART_Init_0:
   \   00000022   0x....             LDR.N    R2,??DataTable5_3
   \   00000024   0x6812             LDR      R2,[R2, #+0]
   \   00000026   0xE001             B.N      ??LPLD_UART_Init_2
     92            else
     93              sysclk = periph_clk_khz;
   \                     ??LPLD_UART_Init_1:
   \   00000028   0x....             LDR.N    R2,??DataTable5_4
   \   0000002A   0x6812             LDR      R2,[R2, #+0]
     94            
     95            //使能选中的UART串口通道时钟   
     96            if(uartptr == UART0_BASE_PTR)
   \                     ??LPLD_UART_Init_2:
   \   0000002C   0x....             LDR.N    R3,??DataTable5_1  ;; 0x4006a000
   \   0000002E   0x4298             CMP      R0,R3
   \   00000030   0xD10E             BNE.N    ??LPLD_UART_Init_3
     97            {
     98              SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;
   \   00000032   0x....             LDR.N    R3,??DataTable5_5  ;; 0x40048034
   \   00000034   0x681B             LDR      R3,[R3, #+0]
   \   00000036   0xF453 0x6380      ORRS     R3,R3,#0x400
   \   0000003A   0x....             LDR.N    R4,??DataTable5_5  ;; 0x40048034
   \   0000003C   0x6023             STR      R3,[R4, #+0]
     99              //使能 PTB17 引脚的 UART0_TXD 功能 
    100              PORTB_PCR17 = PORT_PCR_MUX(0x3); 
   \   0000003E   0x....             LDR.N    R3,??DataTable5_6  ;; 0x4004a044
   \   00000040   0xF44F 0x7440      MOV      R4,#+768
   \   00000044   0x601C             STR      R4,[R3, #+0]
    101              //使能 PTB16 引脚的 UART0_RXD 功能 
    102              PORTB_PCR16 = PORT_PCR_MUX(0x3);
   \   00000046   0x....             LDR.N    R3,??DataTable5_7  ;; 0x4004a040
   \   00000048   0xF44F 0x7440      MOV      R4,#+768
   \   0000004C   0x601C             STR      R4,[R3, #+0]
   \   0000004E   0xE05B             B.N      ??LPLD_UART_Init_4
    103            }
    104            else
    105            {
    106              if (uartptr == UART1_BASE_PTR)
   \                     ??LPLD_UART_Init_3:
   \   00000050   0x....             LDR.N    R3,??DataTable5_2  ;; 0x4006b000
   \   00000052   0x4298             CMP      R0,R3
   \   00000054   0xD114             BNE.N    ??LPLD_UART_Init_5
    107              {
    108                SIM_SCGC4 |= SIM_SCGC4_UART1_MASK;
   \   00000056   0x....             LDR.N    R3,??DataTable5_5  ;; 0x40048034
   \   00000058   0x681B             LDR      R3,[R3, #+0]
   \   0000005A   0xF453 0x6300      ORRS     R3,R3,#0x800
   \   0000005E   0x....             LDR.N    R4,??DataTable5_5  ;; 0x40048034
   \   00000060   0x6023             STR      R3,[R4, #+0]
    109                SIM_SCGC4 |= SIM_SCGC4_UART2_MASK;
   \   00000062   0x....             LDR.N    R3,??DataTable5_5  ;; 0x40048034
   \   00000064   0x681B             LDR      R3,[R3, #+0]
   \   00000066   0xF453 0x5380      ORRS     R3,R3,#0x1000
   \   0000006A   0x....             LDR.N    R4,??DataTable5_5  ;; 0x40048034
   \   0000006C   0x6023             STR      R3,[R4, #+0]
    110                //使能 PTC4 引脚的 UART1_TXD 功能 
    111                PORTC_PCR4 = PORT_PCR_MUX(0x3); 
   \   0000006E   0x....             LDR.N    R3,??DataTable5_8  ;; 0x4004b010
   \   00000070   0xF44F 0x7440      MOV      R4,#+768
   \   00000074   0x601C             STR      R4,[R3, #+0]
    112                //使能 PTC3 引脚的 UART1_RXD 功能 
    113                PORTC_PCR3 = PORT_PCR_MUX(0x3);
   \   00000076   0x....             LDR.N    R3,??DataTable5_9  ;; 0x4004b00c
   \   00000078   0xF44F 0x7440      MOV      R4,#+768
   \   0000007C   0x601C             STR      R4,[R3, #+0]
   \   0000007E   0xE043             B.N      ??LPLD_UART_Init_4
    114              }
    115              else
    116              {
    117                if (uartptr == UART2_BASE_PTR)
   \                     ??LPLD_UART_Init_5:
   \   00000080   0x....             LDR.N    R3,??DataTable5_10  ;; 0x4006c000
   \   00000082   0x4298             CMP      R0,R3
   \   00000084   0xD10E             BNE.N    ??LPLD_UART_Init_6
    118                {
    119                  SIM_SCGC4 |= SIM_SCGC4_UART2_MASK;
   \   00000086   0x....             LDR.N    R3,??DataTable5_5  ;; 0x40048034
   \   00000088   0x681B             LDR      R3,[R3, #+0]
   \   0000008A   0xF453 0x5380      ORRS     R3,R3,#0x1000
   \   0000008E   0x....             LDR.N    R4,??DataTable5_5  ;; 0x40048034
   \   00000090   0x6023             STR      R3,[R4, #+0]
    120                  //使能 PTD3 引脚的 UART2_TXD 功能 
    121                  PORTD_PCR3 = PORT_PCR_MUX(0x3); 
   \   00000092   0x....             LDR.N    R3,??DataTable5_11  ;; 0x4004c00c
   \   00000094   0xF44F 0x7440      MOV      R4,#+768
   \   00000098   0x601C             STR      R4,[R3, #+0]
    122                  //使能 PTD2 引脚的 UART2_RXD 功能 
    123                  PORTD_PCR2 = PORT_PCR_MUX(0x3);
   \   0000009A   0x....             LDR.N    R3,??DataTable5_12  ;; 0x4004c008
   \   0000009C   0xF44F 0x7440      MOV      R4,#+768
   \   000000A0   0x601C             STR      R4,[R3, #+0]
   \   000000A2   0xE031             B.N      ??LPLD_UART_Init_4
    124                }
    125                else
    126                {
    127                  if(uartptr == UART3_BASE_PTR)
   \                     ??LPLD_UART_Init_6:
   \   000000A4   0x....             LDR.N    R3,??DataTable5_13  ;; 0x4006d000
   \   000000A6   0x4298             CMP      R0,R3
   \   000000A8   0xD10E             BNE.N    ??LPLD_UART_Init_7
    128                  {
    129                    SIM_SCGC4 |= SIM_SCGC4_UART3_MASK;
   \   000000AA   0x....             LDR.N    R3,??DataTable5_5  ;; 0x40048034
   \   000000AC   0x681B             LDR      R3,[R3, #+0]
   \   000000AE   0xF453 0x5300      ORRS     R3,R3,#0x2000
   \   000000B2   0x....             LDR.N    R4,??DataTable5_5  ;; 0x40048034
   \   000000B4   0x6023             STR      R3,[R4, #+0]
    130                    //使能 PTC17 引脚的 UART3_TXD 功能 
    131                    PORTC_PCR15 = PORT_PCR_MUX(0x3); 
   \   000000B6   0x....             LDR.N    R3,??DataTable5_14  ;; 0x4004b03c
   \   000000B8   0xF44F 0x7440      MOV      R4,#+768
   \   000000BC   0x601C             STR      R4,[R3, #+0]
    132                    //使能 PTC16 引脚的 UART3_RXD 功能 
    133                    PORTC_PCR14 = PORT_PCR_MUX(0x3);
   \   000000BE   0x....             LDR.N    R3,??DataTable5_15  ;; 0x4004b038
   \   000000C0   0xF44F 0x7440      MOV      R4,#+768
   \   000000C4   0x601C             STR      R4,[R3, #+0]
   \   000000C6   0xE01F             B.N      ??LPLD_UART_Init_4
    134                  }
    135                  else
    136                  {
    137                    if(uartptr == UART4_BASE_PTR)
   \                     ??LPLD_UART_Init_7:
   \   000000C8   0x....             LDR.N    R3,??DataTable5_16  ;; 0x400ea000
   \   000000CA   0x4298             CMP      R0,R3
   \   000000CC   0xD10E             BNE.N    ??LPLD_UART_Init_8
    138                    {
    139                      SIM_SCGC1 |= SIM_SCGC1_UART4_MASK;
   \   000000CE   0x....             LDR.N    R3,??DataTable5_17  ;; 0x40048028
   \   000000D0   0x681B             LDR      R3,[R3, #+0]
   \   000000D2   0xF453 0x6380      ORRS     R3,R3,#0x400
   \   000000D6   0x....             LDR.N    R4,??DataTable5_17  ;; 0x40048028
   \   000000D8   0x6023             STR      R3,[R4, #+0]
    140                      //使能 PTC15 引脚的 UART4_TXD 功能 
    141                      PORTC_PCR15 = PORT_PCR_MUX(0x3); 
   \   000000DA   0x....             LDR.N    R3,??DataTable5_14  ;; 0x4004b03c
   \   000000DC   0xF44F 0x7440      MOV      R4,#+768
   \   000000E0   0x601C             STR      R4,[R3, #+0]
    142                      //使能 PTC14 引脚的 UART4_RXD 功能 
    143                      PORTC_PCR14 = PORT_PCR_MUX(0x3);
   \   000000E2   0x....             LDR.N    R3,??DataTable5_15  ;; 0x4004b038
   \   000000E4   0xF44F 0x7440      MOV      R4,#+768
   \   000000E8   0x601C             STR      R4,[R3, #+0]
   \   000000EA   0xE00D             B.N      ??LPLD_UART_Init_4
    144                    }
    145                    else
    146                    {
    147                      SIM_SCGC1 |= SIM_SCGC1_UART5_MASK;
   \                     ??LPLD_UART_Init_8:
   \   000000EC   0x....             LDR.N    R3,??DataTable5_17  ;; 0x40048028
   \   000000EE   0x681B             LDR      R3,[R3, #+0]
   \   000000F0   0xF453 0x6300      ORRS     R3,R3,#0x800
   \   000000F4   0x....             LDR.N    R4,??DataTable5_17  ;; 0x40048028
   \   000000F6   0x6023             STR      R3,[R4, #+0]
    148                      //使能 PTE8 引脚的 UART3_TXD 功能 
    149                      PORTE_PCR8 = PORT_PCR_MUX(0x3); 
   \   000000F8   0x....             LDR.N    R3,??DataTable5_18  ;; 0x4004d020
   \   000000FA   0xF44F 0x7440      MOV      R4,#+768
   \   000000FE   0x601C             STR      R4,[R3, #+0]
    150                      //使能 PTE9 引脚的 UART3_RXD 功能 
    151                      PORTE_PCR9 = PORT_PCR_MUX(0x3); 
   \   00000100   0x....             LDR.N    R3,??DataTable5_19  ;; 0x4004d024
   \   00000102   0xF44F 0x7440      MOV      R4,#+768
   \   00000106   0x601C             STR      R4,[R3, #+0]
    152                    }
    153                  }
    154                }
    155              }
    156            }
    157            
    158            //在配置好其他寄存器前，先关闭发送器和接收器
    159            UART_C2_REG(uartptr) &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK );
   \                     ??LPLD_UART_Init_4:
   \   00000108   0x78C3             LDRB     R3,[R0, #+3]
   \   0000010A   0xF013 0x03F3      ANDS     R3,R3,#0xF3
   \   0000010E   0x70C3             STRB     R3,[R0, #+3]
    160            
    161            //配置UART为 8位, 无奇偶校验 */
    162            UART_C1_REG(uartptr) = 0;	
   \   00000110   0x2300             MOVS     R3,#+0
   \   00000112   0x7083             STRB     R3,[R0, #+2]
    163            
    164            //计算波特率
    165            sbr = (uint16)((sysclk*1000)/(baud * 16));
   \   00000114   0xF44F 0x737A      MOV      R3,#+1000
   \   00000118   0xFB03 0xF302      MUL      R3,R3,R2
   \   0000011C   0x010C             LSLS     R4,R1,#+4
   \   0000011E   0xFB93 0xF3F4      SDIV     R3,R3,R4
    166            
    167            //保存UARTx_BDH寄存器中除了SBR的值
    168            temp = UART_BDH_REG(uartptr) & ~(UART_BDH_SBR(0x1F));
   \   00000122   0x7804             LDRB     R4,[R0, #+0]
   \   00000124   0xF014 0x04E0      ANDS     R4,R4,#0xE0
    169            
    170            UART_BDH_REG(uartptr) = temp |  UART_BDH_SBR(((sbr & 0x1F00) >> 8));
   \   00000128   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000012A   0x0A1D             LSRS     R5,R3,#+8
   \   0000012C   0xF015 0x051F      ANDS     R5,R5,#0x1F
   \   00000130   0x432C             ORRS     R4,R5,R4
   \   00000132   0x7004             STRB     R4,[R0, #+0]
    171            UART_BDL_REG(uartptr) = (uint8)(sbr & UART_BDL_SBR_MASK);
   \   00000134   0x7043             STRB     R3,[R0, #+1]
    172            
    173            //配置波特率的微调分数
    174            brfa = (((sysclk*32000)/(baud * 16)) - (sbr * 32));
   \   00000136   0xF44F 0x44FA      MOV      R4,#+32000
   \   0000013A   0x4362             MULS     R2,R4,R2
   \   0000013C   0x0109             LSLS     R1,R1,#+4
   \   0000013E   0xFB92 0xF1F1      SDIV     R1,R2,R1
   \   00000142   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000144   0xEBB1 0x1143      SUBS     R1,R1,R3, LSL #+5
    175            
    176            //保存UARTx_C4寄存器中除了BRFA的值
    177            temp = UART_C4_REG(uartptr) & ~(UART_C4_BRFA(0x1F));
   \   00000148   0x7A82             LDRB     R2,[R0, #+10]
   \   0000014A   0xF012 0x04E0      ANDS     R4,R2,#0xE0
    178            
    179            UART_C4_REG(uartptr) = temp |  UART_C4_BRFA(brfa);    
   \   0000014E   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000152   0x4321             ORRS     R1,R1,R4
   \   00000154   0x7281             STRB     R1,[R0, #+10]
    180            
    181            //使能发送器和接收器
    182            UART_C2_REG(uartptr) |= (UART_C2_TE_MASK | UART_C2_RE_MASK );
   \   00000156   0x78C1             LDRB     R1,[R0, #+3]
   \   00000158   0xF051 0x010C      ORRS     R1,R1,#0xC
   \   0000015C   0x70C1             STRB     R1,[R0, #+3]
    183          }
   \   0000015E   0xBC30             POP      {R4,R5}
   \   00000160   0x4770             BX       LR               ;; return
    184          
    185          /*
    186           * LPLD_UART_GetChar
    187           * 串口查询方式读取一个字节
    188           * 
    189           * 参数:
    190           *    uartx--UART模块号
    191           *      |__UART0          --UART0  -Txd:PTB17 -Rxd:PTB16
    192           *      |__UART1          --UART1  -Txd:PTC4  -Rxd:PTC3
    193           *      |__UART2          --UART2  -Txd:PTD3  -Rxd:PTD2
    194           *      |__UART3          --UART3  -Txd:PTC17 -Rxd:PTC16
    195           *      |__UART4          --UART4  -Txd:PTC15 -Rxd:PTC14
    196           *      |__UART5          --UART5  -Txd:PTE8  -Rxd:PTE9
    197           *
    198           * 输出:
    199           *    串口接收的1个字节
    200           *
    201           */

   \                                 In section .text, align 2, keep-with-next
    202          char LPLD_UART_GetChar(UARTx uartx)
    203          {
    204            UART_MemMapPtr uartptr = UARTx_Ptr[uartx];
   \                     LPLD_UART_GetChar:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R1,??DataTable5
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
    205            
    206            //等待数据接收
    207            while (!(UART_S1_REG(uartptr) & UART_S1_RDRF_MASK));
   \                     ??LPLD_UART_GetChar_0:
   \   00000008   0x7901             LDRB     R1,[R0, #+4]
   \   0000000A   0x0689             LSLS     R1,R1,#+26
   \   0000000C   0xD5FC             BPL.N    ??LPLD_UART_GetChar_0
    208            
    209            //返回接收的1个字节数据
    210            return UART_D_REG(uartptr);
   \   0000000E   0x79C0             LDRB     R0,[R0, #+7]
   \   00000010   0x4770             BX       LR               ;; return
    211          }
    212          
    213          /*
    214           * LPLD_UART_PutChar
    215           * 串口查询方式发送一个字节
    216           * 
    217           * 参数:
    218           *    uartx--UART模块号
    219           *      |__UART0          --UART0  -Txd:PTB17 -Rxd:PTB16
    220           *      |__UART1          --UART1  -Txd:PTC4  -Rxd:PTC3
    221           *      |__UART2          --UART2  -Txd:PTD3  -Rxd:PTD2
    222           *      |__UART3          --UART3  -Txd:PTC17 -Rxd:PTC16
    223           *      |__UART4          --UART4  -Txd:PTC15 -Rxd:PTC14
    224           *      |__UART5          --UART5  -Txd:PTE8  -Rxd:PTE9
    225           *    ch--待发送的1个字节
    226           *
    227           * 输出:
    228           *    无
    229           *
    230           */

   \                                 In section .text, align 2, keep-with-next
    231          void LPLD_UART_PutChar(UARTx uartx, char ch)
    232          {
    233            UART_MemMapPtr uartptr = UARTx_Ptr[uartx];
   \                     LPLD_UART_PutChar:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x....             LDR.N    R2,??DataTable5
   \   00000004   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
    234            
    235            //等待FIFO准备就绪
    236            while(!(UART_S1_REG(uartptr) & UART_S1_TDRE_MASK));
   \                     ??LPLD_UART_PutChar_0:
   \   00000008   0x7902             LDRB     R2,[R0, #+4]
   \   0000000A   0x0612             LSLS     R2,R2,#+24
   \   0000000C   0xD5FC             BPL.N    ??LPLD_UART_PutChar_0
    237            
    238            //将要发送的1个字节发给UART数据寄存器
    239            UART_D_REG(uartptr) = (uint8)ch;
   \   0000000E   0x71C1             STRB     R1,[R0, #+7]
    240          }
   \   00000010   0x4770             BX       LR               ;; return
    241          
    242          
    243          /*
    244           * LPLD_UART_PutCharArr
    245           * 串口查询方式发送字节型数组
    246           * 
    247           * 参数:
    248           *    uartx--UART模块号
    249           *      |__UART0          --UART0  -Txd:PTB17 -Rxd:PTB16
    250           *      |__UART1          --UART1  -Txd:PTC4  -Rxd:PTC3
    251           *      |__UART2          --UART2  -Txd:PTD3  -Rxd:PTD2
    252           *      |__UART3          --UART3  -Txd:PTC17 -Rxd:PTC16
    253           *      |__UART4          --UART4  -Txd:PTC15 -Rxd:PTC14
    254           *      |__UART5          --UART5  -Txd:PTE8  -Rxd:PTE9
    255           *    *ch--待发送的字节数组头地址
    256           *    len--字节数组长度
    257           *
    258           * 输出:
    259           *    无
    260           *
    261           */

   \                                 In section .text, align 2, keep-with-next
    262          void LPLD_UART_PutCharArr(UARTx uartx, char *ch, int len)
    263          {
   \                     LPLD_UART_PutCharArr:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0xE005             B.N      ??LPLD_UART_PutCharArr_0
    264            while(len--)
    265            {
    266              LPLD_UART_PutChar(uartx, *(ch++));
   \                     ??LPLD_UART_PutCharArr_1:
   \   0000000A   0x7829             LDRB     R1,[R5, #+0]
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       LPLD_UART_PutChar
   \   00000014   0x1C6D             ADDS     R5,R5,#+1
    267            }
   \                     ??LPLD_UART_PutCharArr_0:
   \   00000016   0x0030             MOVS     R0,R6
   \   00000018   0x1E46             SUBS     R6,R0,#+1
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD1F5             BNE.N    ??LPLD_UART_PutCharArr_1
    268          }
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    269          
    270          /*
    271           * LPLD_UART_RIE_Enable
    272           * 使能串口数据接收中断，设置中断函数入口
    273           * 
    274           * 参数:
    275           *    uartx--UART模块号
    276           *      |__UART0          --UART0  -Txd:PTB17 -Rxd:PTB16
    277           *      |__UART1          --UART1  -Txd:PTC4  -Rxd:PTC3
    278           *      |__UART2          --UART2  -Txd:PTD3  -Rxd:PTD2
    279           *      |__UART3          --UART3  -Txd:PTC17 -Rxd:PTC16
    280           *      |__UART4          --UART4  -Txd:PTC15 -Rxd:PTC14
    281           *      |__UART5          --UART5  -Txd:PTE8  -Rxd:PTE9
    282           *    isr_func--数据接收中断程序入口地址
    283           *      |__用户在工程文件下定义的中断函数名，函数必须为:无返回值,无参数(eg. void isr(void);)
    284           *
    285           * 输出:
    286           *    无
    287           *
    288           */

   \                                 In section .text, align 2, keep-with-next
    289          void LPLD_UART_RIE_Enable(UARTx uartx, UART_ISR_CALLBACK isr_func)
    290          {
   \                     LPLD_UART_RIE_Enable:
   \   00000000   0xB580             PUSH     {R7,LR}
    291            UART_MemMapPtr uartptr = UARTx_Ptr[uartx];
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x....             LDR.N    R2,??DataTable5
   \   00000006   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
    292            
    293            UART_R_ISR[uartx] = isr_func;
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x....             LDR.N    R3,??DataTable5_20
   \   0000000E   0xF843 0x1020      STR      R1,[R3, R0, LSL #+2]
    294           
    295            //使能UART接收中断
    296            UART_C2_REG(uartptr) |= UART_C2_RIE_MASK; 
   \   00000012   0x78D1             LDRB     R1,[R2, #+3]
   \   00000014   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   00000018   0x70D1             STRB     R1,[R2, #+3]
    297            
    298            //根据中断请求号使能相应中断
    299            enable_irq( 45 + uartx*2);
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x0040             LSLS     R0,R0,#+1
   \   0000001E   0x302D             ADDS     R0,R0,#+45
   \   00000020   0x.... 0x....      BL       enable_irq
    300          }
   \   00000024   0xBD01             POP      {R0,PC}          ;; return
    301          
    302          /*
    303           * LPLD_UART_RIE_Disable
    304           * 禁用串口数据接收中断
    305           * 
    306           * 参数:
    307           *    uartx--UART模块号
    308           *      |__UART0          --UART0  -Txd:PTB17 -Rxd:PTB16
    309           *      |__UART1          --UART1  -Txd:PTC4  -Rxd:PTC3
    310           *      |__UART2          --UART2  -Txd:PTD3  -Rxd:PTD2
    311           *      |__UART3          --UART3  -Txd:PTC17 -Rxd:PTC16
    312           *      |__UART4          --UART4  -Txd:PTC15 -Rxd:PTC14
    313           *      |__UART5          --UART5  -Txd:PTE8  -Rxd:PTE9
    314           *
    315           * 输出:
    316           *    无
    317           *
    318           */

   \                                 In section .text, align 2, keep-with-next
    319          void LPLD_UART_RIE_Disable(UARTx uartx)
    320          {
   \                     LPLD_UART_RIE_Disable:
   \   00000000   0xB580             PUSH     {R7,LR}
    321            UART_MemMapPtr uartptr = UARTx_Ptr[uartx];
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x....             LDR.N    R1,??DataTable5
   \   00000006   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
    322           
    323            //禁用UART接收中断
    324            UART_C2_REG(uartptr) &= ~UART_C2_RIE_MASK;  
   \   0000000A   0x78CA             LDRB     R2,[R1, #+3]
   \   0000000C   0xF012 0x02DF      ANDS     R2,R2,#0xDF
   \   00000010   0x70CA             STRB     R2,[R1, #+3]
    325            
    326            disable_irq( 45 + uartx*2);
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x0040             LSLS     R0,R0,#+1
   \   00000016   0x302D             ADDS     R0,R0,#+45
   \   00000018   0x.... 0x....      BL       disable_irq
    327          }
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    328          
    329          /*
    330           * LPLD_UART_Isr
    331           * UART通用中断底层入口函数
    332           * 
    333           * 用户无需修改，程序自动进入对应通道中断函数
    334           */

   \                                 In section .text, align 2, keep-with-next
    335          void LPLD_UART_Isr(void)
    336          {
   \                     LPLD_UART_Isr:
   \   00000000   0xB580             PUSH     {R7,LR}
    337            #define UART_VECTORNUM   (*(volatile uint8_t*)(0xE000ED04))
    338            uint8_t uart_ch = (UART_VECTORNUM - 61)/2;
   \   00000002   0x....             LDR.N    R0,??DataTable5_21  ;; 0xe000ed04
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x383D             SUBS     R0,R0,#+61
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0xFB90 0xF0F1      SDIV     R0,R0,R1
    339            UART_MemMapPtr uartch = (UART_MemMapPtr)((0x4006A+uart_ch)<<12);
   \   00000010   0x....             LDR.N    R1,??DataTable5_22  ;; 0x4006a
   \   00000012   0xFA51 0xF180      UXTAB    R1,R1,R0
   \   00000016   0x0309             LSLS     R1,R1,#+12
    340            if(uart_ch>3){
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x2804             CMP      R0,#+4
   \   0000001C   0xD303             BCC.N    ??LPLD_UART_Isr_0
    341              uartch = (UART_MemMapPtr)((0x400E6+uart_ch)<<12);  
   \   0000001E   0x....             LDR.N    R1,??DataTable5_23  ;; 0x400e6
   \   00000020   0xFA51 0xF180      UXTAB    R1,R1,R0
   \   00000024   0x0309             LSLS     R1,R1,#+12
    342            }
    343            
    344            //进入接收中断函数
    345            if(UART_S1_REG(uartch) & UART_S1_RDRF_MASK)
   \                     ??LPLD_UART_Isr_0:
   \   00000026   0x7909             LDRB     R1,[R1, #+4]
   \   00000028   0x0689             LSLS     R1,R1,#+26
   \   0000002A   0xD504             BPL.N    ??LPLD_UART_Isr_1
    346            {
    347              UART_R_ISR[uart_ch]();
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x....             LDR.N    R1,??DataTable5_20
   \   00000030   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000034   0x4780             BLX      R0
    348            }
    349          }
   \                     ??LPLD_UART_Isr_1:
   \   00000036   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     UARTx_Ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x4006B000         DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     core_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     periph_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x4004A044         DC32     0x4004a044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x4004A040         DC32     0x4004a040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x4004B010         DC32     0x4004b010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x4004B00C         DC32     0x4004b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x4006C000         DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x4004C00C         DC32     0x4004c00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x4004C008         DC32     0x4004c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x4006D000         DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x4004B03C         DC32     0x4004b03c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x4004B038         DC32     0x4004b038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x400EA000         DC32     0x400ea000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x40048028         DC32     0x40048028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x4004D020         DC32     0x4004d020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x4004D024         DC32     0x4004d024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_20:
   \   00000000   0x........         DC32     UART_R_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_21:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_22:
   \   00000000   0x0004006A         DC32     0x4006a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_23:
   \   00000000   0x000400E6         DC32     0x400e6

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  LPLD_UART_GetChar
        8  LPLD_UART_Init
        8  LPLD_UART_Isr
              8 -- Indirect call
        0  LPLD_UART_PutChar
       16  LPLD_UART_PutCharArr
             16 -> LPLD_UART_PutChar
        8  LPLD_UART_RIE_Disable
              8 -> disable_irq
        8  LPLD_UART_RIE_Enable
              8 -> enable_irq


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_22
       4  ??DataTable5_23
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      18  LPLD_UART_GetChar
     354  LPLD_UART_Init
      56  LPLD_UART_Isr
      18  LPLD_UART_PutChar
      32  LPLD_UART_PutCharArr
      30  LPLD_UART_RIE_Disable
      38  LPLD_UART_RIE_Enable
      24  UART_R_ISR
      24  UART_T_ISR
      24  UARTx_Ptr

 
  48 bytes in section .bss
  24 bytes in section .data
 642 bytes in section .text
 
 642 bytes of CODE memory
  72 bytes of DATA memory

Errors: none
Warnings: none
